--- ./doc/auto_rst4api.py	(original)
+++ ./doc/auto_rst4api.py	(refactored)
@@ -28,6 +28,8 @@
 the API of a python module with sphinx'''
 from __future__ import print_function
 
+from builtins import zip
+from builtins import object
 import sys
 import os
 import imp
@@ -172,7 +174,7 @@
                 if self.verbose:
                     print(' skipping (file already exists)')
         # recurse for submodules
-        for sminfo in info['submodules'].itervalues():
+        for sminfo in info['submodules'].values():
             self.createStubs(sminfo, absdocpath)
 
     def documentModule(self, modulename, docparentpath, exclude_patterns=None):
@@ -204,7 +206,7 @@
         if len(w) == 0:
             return []
         else:
-            return zip(*w)[1]
+            return list(zip(*w))[1]
 
 
 def main():
--- ./doc/source/devel/examples/TaurusTest.py	(original)
+++ ./doc/source/devel/examples/TaurusTest.py	(refactored)
@@ -1,4 +1,7 @@
 from __future__ import print_function
+from __future__ import division
+from builtins import range
+from past.utils import old_div
 import PyTango
 import sys
 import math
@@ -21,7 +24,7 @@
         self._velocity = 20.0
         self._acceleration = 4.0
         self._simulation_mode = False
-        self._abscissas = [x / 50.0 for x in xrange(1024)]
+        self._abscissas = [old_div(x, 50.0) for x in range(1024)]
         self._curve = [math.sin(x) for x in self._abscissas]
 
     def always_executed_hook(self):
--- ./doc/source/devel/examples/label06.py	(original)
+++ ./doc/source/devel/examples/label06.py	(refactored)
@@ -1,3 +1,4 @@
+from builtins import range
 import sys
 from taurus.external.qt import Qt
 from taurus.qt.qtgui.display import TaurusLabel
--- ./doc/source/sphinxext/taurusextension.py	(original)
+++ ./doc/source/sphinxext/taurusextension.py	(refactored)
@@ -26,6 +26,8 @@
 """helper methods for taurus sphinx documentation"""
 from __future__ import print_function
 
+from builtins import str
+from builtins import map
 __expr = ('or',)
 
 
--- ./lib/taurus/__init__.py	(original)
+++ ./lib/taurus/__init__.py	(refactored)
@@ -26,13 +26,14 @@
 """The main taurus module. It contains a reduced set of wrappers around the
 real taurus model classes and information regarding the current release."""
 
+from builtins import object
 from .core import release as __R
 
 
-class Release:
+class Release(object):
     pass
 
-for key, value in __R.__dict__.items():
+for key, value in list(__R.__dict__.items()):
     setattr(Release, key, value)
 Release.__doc__ = __R.__doc__
 
--- ./lib/taurus/console/list.py	(original)
+++ ./lib/taurus/console/list.py	(refactored)
@@ -26,6 +26,8 @@
 """ """
 from __future__ import absolute_import
 
+from builtins import map
+from builtins import range
 __all__ = ["List"]
 
 __docformat__ = "restructuredtext"
@@ -62,7 +64,7 @@
             self.append(header)
 
     def setHeaderSeparator(self, header_separator):
-        if isinstance(header_separator, (str, unicode)):
+        if isinstance(header_separator, (str, str)):
             header_separator = self.col_nb * [header_separator]
         self.HeaderSeparator = header_separator
 
@@ -72,7 +74,7 @@
     header_separator = property(getHeaderSeparator, setHeaderSeparator)
 
     def setRowSeparator(self, row_separator):
-        if isinstance(row_separator, (str, unicode)):
+        if isinstance(row_separator, (str, str)):
             row_separator = self.col_nb * [row_separator]
         self.RowSeparator = row_separator
 
@@ -104,7 +106,7 @@
     text_alignment = property(getTextAlignment, setTextAlignment)
 
     def _transform_row(self, row):
-        return map(str, row[:self.col_nb])
+        return list(map(str, row[:self.col_nb]))
 
     def __setitem__(self, i, row):
         return list.__setitem__(self, i, self._transform_row(row))
--- ./lib/taurus/console/table.py	(original)
+++ ./lib/taurus/console/table.py	(refactored)
@@ -24,6 +24,11 @@
 #############################################################################
 
 """ """
+from __future__ import division
+from builtins import map
+from builtins import range
+from builtins import object
+from past.utils import old_div
 from functools import reduce
 
 __all__ = ["Table"]
@@ -31,7 +36,7 @@
 __docformat__ = "restructuredtext"
 
 
-class Table:
+class Table(object):
 
     DefTermWidth = 80
 
@@ -58,7 +63,7 @@
         self.col_head_sep = col_head_sep
         self.border = border
 
-        max_len_fn = lambda x: reduce(max, map(len, x))
+        max_len_fn = lambda x: reduce(max, list(map(len, x)))
 
         self.row_head_str = row_head_str
         self.row_head_fmt = row_head_fmt
@@ -81,7 +86,7 @@
             raise ValueError(msg)
         if col_head_width is None:
             if col_head_str is not None:
-                col_head_width = reduce(max, map(max_len_fn, col_head_str))
+                col_head_width = reduce(max, list(map(max_len_fn, col_head_str)))
             else:
                 col_head_width = 10
         self.col_head_width = col_head_width
@@ -107,7 +112,7 @@
         width = term_width - chw   # At least one disp column!
         if rhw > 0:
             width -= rhw + lcs
-        disp_cols = width / (chw + lcs) + 1
+        disp_cols = old_div(width, (chw + lcs)) + 1
         tot_width = chw + (disp_cols - 1) * (chw + lcs)
         tot_rows = chl + self.nr_row
         if rhw > 0:
@@ -124,36 +129,36 @@
         else:
             row_head = [''] * tot_rows
 
-        for i in xrange(0, self.nr_col, disp_cols):
+        for i in range(0, self.nr_col, disp_cols):
             if i > 0:
-                nr_sep = tot_width / len(self.row_sep)
+                nr_sep = old_div(tot_width, len(self.row_sep))
                 output.append(self.row_sep * nr_sep)
 
             row_end = min(i + disp_cols, self.nr_col)
             line = list(row_head)
-            for j in xrange(i, row_end):
+            for j in range(i, row_end):
                 elem = self.elem_list[j]
                 if chl:
                     col_head = self.col_head_str[j]
                     if j > i:
-                        for k in xrange(tot_rows):
+                        for k in range(tot_rows):
                             line[k] += self.col_sep
                     fmt = self.col_head_fmt
-                    for k in xrange(chl):
+                    for k in range(chl):
                         line[k] += fmt % (chw, col_head[k])
 
-                for k in xrange(self.nr_row):
+                for k in range(self.nr_row):
                     fmt = self.elem_fmt[k]
                     line[chl + k] += fmt % (chw, elem[k])
 
-            max_width = reduce(max, map(len, line))
+            max_width = reduce(max, list(map(len, line)))
             if self.border is not None:
-                nr_border = max_width / len(self.border)
+                nr_border = old_div(max_width, len(self.border))
                 output.append(self.border * nr_border)
             for l in line[:chl]:
                 output.append(l)
             if self.col_head_sep is not None:
-                nr_sep = max_width / len(self.col_head_sep)
+                nr_sep = old_div(max_width, len(self.col_head_sep))
                 output.append(self.col_head_sep * nr_sep)
             for l in line[chl:]:
                 output.append(l)
--- ./lib/taurus/core/release.py	(original)
+++ ./lib/taurus/core/release.py	(refactored)
@@ -23,6 +23,7 @@
 ##
 #############################################################################
 
+from builtins import str
 __docformat__ = "restructuredtext"
 
 """
--- ./lib/taurus/core/taurusattribute.py	(original)
+++ ./lib/taurus/core/taurusattribute.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module contains the base class for a taurus attribute"""
 
+from builtins import str
 __all__ = ["TaurusAttribute"]
 
 __docformat__ = "restructuredtext"
--- ./lib/taurus/core/taurusbasetypes.py	(original)
+++ ./lib/taurus/core/taurusbasetypes.py	(refactored)
@@ -26,6 +26,7 @@
 a misc collection of basic types
 '''
 
+from builtins import object
 __all__ = ["TaurusSWDevState", "TaurusSWDevHealth", "OperationMode",
            "TaurusSerializationMode", "SubscriptionState", "TaurusEventType",
            "MatchLevel", "TaurusElementType", "LockStatus", "DataFormat",
@@ -149,7 +150,7 @@
 __PYTHON_TYPE_TO_TAURUS_DATATYPE = {
     str: DataType.String,
     int: DataType.Integer,
-    long: DataType.Integer,
+    int: DataType.Integer,
     float: DataType.Float,
     bool: DataType.Boolean,
     # bytes : DataType.Bytes, # see below...
--- ./lib/taurus/core/taurusconfiguration.py	(original)
+++ ./lib/taurus/core/taurusconfiguration.py	(refactored)
@@ -27,6 +27,7 @@
 """[DEPRECATED since taurus v4]
 This module contains the base class for a taurus attribute configuration"""
 
+from builtins import object
 __all__ = ["TaurusConfigurationProxy", "TaurusConfiguration"]
 
 __docformat__ = "restructuredtext"
--- ./lib/taurus/core/taurusdevice.py	(original)
+++ ./lib/taurus/core/taurusdevice.py	(refactored)
@@ -126,7 +126,7 @@
         # synchronous polling.
         if asynch is True:
             return 1
-        for attr in attrs.values():
+        for attr in list(attrs.values()):
             attr.poll()
 
     @property
--- ./lib/taurus/core/taurusexception.py	(original)
+++ ./lib/taurus/core/taurusexception.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module contains the taurus base exception classes"""
 
+from builtins import str
 __all__ = ["TaurusException", "DoubleRegistration"]
 
 __docformat__ = "restructuredtext"
--- ./lib/taurus/core/taurusfactory.py	(original)
+++ ./lib/taurus/core/taurusfactory.py	(refactored)
@@ -57,6 +57,7 @@
 """
 from __future__ import absolute_import
 
+from builtins import object
 __all__ = ["TaurusFactory"]
 
 __docformat__ = "restructuredtext"
@@ -324,14 +325,14 @@
         if not self.isPollingEnabled():
             return
         self._polling_enabled = False
-        for period, timer in self.polling_timers.iteritems():
+        for period, timer in self.polling_timers.items():
             timer.stop()
 
     def enablePolling(self):
         """Enable the application tango polling"""
         if self.isPollingEnabled():
             return
-        for period, timer in self.polling_timers.iteritems():
+        for period, timer in self.polling_timers.items():
             timer.start()
         self._polling_enabled = True
 
@@ -354,7 +355,7 @@
            :param attribute: (str) attribute name.
         """
         p = None
-        for period, timer in self.polling_timers.iteritems():
+        for period, timer in self.polling_timers.items():
             if timer.containsAttribute(attribute):
                 timer.removeAttribute(attribute)
                 if timer.getAttributeCount() == 0:
--- ./lib/taurus/core/taurushelper.py	(original)
+++ ./lib/taurus/core/taurushelper.py	(refactored)
@@ -26,6 +26,7 @@
 """a list of helper methods"""
 from __future__ import print_function
 
+from builtins import str
 __all__ = ['check_dependencies', 'log_dependencies', 'getSchemeFromName',
            'getValidTypesForName', 'isValidName', 'makeSchemeExplicit',
            'Manager', 'Factory', 'Device', 'Attribute', 'Configuration',
--- ./lib/taurus/core/tauruslistener.py	(original)
+++ ./lib/taurus/core/tauruslistener.py	(refactored)
@@ -26,6 +26,8 @@
 """This module contains the taurus base listeners classes"""
 from __future__ import print_function
 
+from builtins import str
+from builtins import object
 __all__ = ["TaurusListener", "TaurusExceptionListener"]
 
 __docformat__ = "restructuredtext"
--- ./lib/taurus/core/taurusmanager.py	(original)
+++ ./lib/taurus/core/taurusmanager.py	(refactored)
@@ -26,6 +26,7 @@
 """This module contains the taurus base manager class"""
 from __future__ import print_function
 
+from builtins import range
 __all__ = ["TaurusManager"]
 
 __docformat__ = "restructuredtext"
@@ -346,7 +347,7 @@
                     self.debug('Failed to inspect %s' % (full_module_name))
                     self.debug('Details:', exc_info=1)
                     continue
-            for s in m.__dict__.values():
+            for s in list(m.__dict__.values()):
                 plugin = None
                 try:
                     if issubclass(s, TaurusFactory) and \
@@ -369,7 +370,7 @@
 
     def _find_scheme(self, factory_class):
         class_name = factory_class.__name__
-        for i in xrange(1, len(class_name)):
+        for i in range(1, len(class_name)):
             if class_name[i].isupper():
                 return class_name[:i].lower()
 
--- ./lib/taurus/core/taurusmodel.py	(original)
+++ ./lib/taurus/core/taurusmodel.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module contains the base TaurusModel class"""
 
+from builtins import object
 __all__ = ["TaurusModel"]
 
 __docformat__ = "restructuredtext"
@@ -219,7 +220,7 @@
     def _getCallableRef(self, listener, cb=None):
         # return weakref.ref(listener, self._listenerDied)
         meth = getattr(listener, 'eventReceived', None)
-        if meth is not None and operator.isCallable(meth):
+        if meth is not None and hasattr(meth, '__call__'):
             return weakref.ref(listener, cb)
         else:
             return CallableRef(listener, cb)
@@ -249,7 +250,7 @@
         return True
 
     def forceListening(self):
-        class __DummyListener:
+        class __DummyListener(object):
 
             def eventReceived(self, *args):
                 pass
@@ -292,9 +293,9 @@
             if l is None:
                 continue
             meth = getattr(l, 'eventReceived', None)
-            if meth is not None and operator.isCallable(meth):
+            if meth is not None and hasattr(meth, '__call__'):
                 l.eventReceived(self, event_type, event_value)
-            elif operator.isCallable(l):
+            elif hasattr(l, '__call__'):
                 l(self, event_type, event_value)
 
     def isWritable(self):
--- ./lib/taurus/core/tauruspollingtimer.py	(original)
+++ ./lib/taurus/core/tauruspollingtimer.py	(refactored)
@@ -24,7 +24,9 @@
 #############################################################################
 
 """This module contains the polling class"""
+from __future__ import division
 
+from past.utils import old_div
 __all__ = ["TaurusPollingTimer"]
 
 __docformat__ = "restructuredtext"
@@ -52,7 +54,7 @@
         self.call__init__(Logger, name, parent)
         self.dev_dict = {}
         self.attr_nb = 0
-        self.timer = Timer(period / 1000.0, self._pollAttributes, self)
+        self.timer = Timer(old_div(period, 1000.0), self._pollAttributes, self)
         self.lock = threading.RLock()
 
     def start(self):
@@ -134,14 +136,14 @@
            when it is time to poll. Do not call this method directly
         """
         req_ids = {}
-        for dev, attrs in self.dev_dict.items():
+        for dev, attrs in list(self.dev_dict.items()):
             try:
                 req_id = dev.poll(attrs, asynch=True)
                 req_ids[dev] = attrs, req_id
             except Exception as e:
                 self.error("poll_asynch error")
                 self.debug("Details:", exc_info=1)
-        for dev, (attrs, req_id) in req_ids.items():
+        for dev, (attrs, req_id) in list(req_ids.items()):
             try:
                 dev.poll(attrs, req_id=req_id)
             except Exception as e:
--- ./lib/taurus/core/epics/test/test_epicsattribute.py	(original)
+++ ./lib/taurus/core/epics/test/test_epicsattribute.py	(refactored)
@@ -101,7 +101,7 @@
         self.assertTrue(isinstance(read_value, TaurusAttrValue), msg)
 
         # Test attribute
-        for k, exp in expected.iteritems():
+        for k, exp in expected.items():
             try:
                 got = getattr(a, k)
             except AttributeError:
@@ -113,7 +113,7 @@
             self.__assertValidValue(exp, got, msg)
 
         # Test attribute value
-        for k, exp in expected_attrv.iteritems():
+        for k, exp in expected_attrv.items():
             try:
                 got = getattr(read_value, k)
             except AttributeError:
--- ./lib/taurus/core/evaluation/evalattribute.py	(original)
+++ ./lib/taurus/core/evaluation/evalattribute.py	(refactored)
@@ -22,6 +22,7 @@
 ##
 #############################################################################
 
+from builtins import str
 __all__ = ['EvaluationAttribute']
 
 import numpy
@@ -260,7 +261,7 @@
             trstring = v.replaceUnquotedRef(trstring, '{%s}' % r, symbol)
 
         # validate the expression (look for missing symbols)
-        safesymbols = evaluator.getSafe().keys()
+        safesymbols = list(evaluator.getSafe().keys())
         # remove literal text strings from the validation
         trimmedstring = re.sub(QUOTED_TEXT_RE, '', trstring)
         for s in set(re.findall(PY_VAR_RE, trimmedstring)):
--- ./lib/taurus/core/evaluation/evaldevice.py	(original)
+++ ./lib/taurus/core/evaluation/evaldevice.py	(refactored)
@@ -22,6 +22,7 @@
 ##
 #############################################################################
 
+from builtins import str
 __all__ = ['EvaluationDevice']
 
 from taurus import Factory
--- ./lib/taurus/core/evaluation/evalvalidator.py	(original)
+++ ./lib/taurus/core/evaluation/evalvalidator.py	(refactored)
@@ -23,6 +23,7 @@
 #############################################################################
 
 from __future__ import absolute_import
+from builtins import zip
 __all__ = ['EvaluationDeviceNameValidator',
            'EvaluationAttributeNameValidator']
 
@@ -263,7 +264,7 @@
 
         # Substitute each k by its v in the expr (unless they are in
         # references)
-        for k, v in substmap.iteritems():
+        for k, v in substmap.items():
             # create a pattern for matching complete word k
             # unless it is within between curly brackets
             keyPattern = r'(?<!\w)%s(?!\w)(?![^\{]*\})' % k
@@ -271,7 +272,7 @@
             ret = re.sub(keyPattern, v, ret)
 
         # restore the protected strings
-        for placeholder, s in protected.iteritems():
+        for placeholder, s in protected.items():
             ret = re.sub(placeholder, s, ret)
         return ret
 
@@ -295,7 +296,7 @@
         # print refs
 
         if refs and not ign_quoted:
-            _, refs = zip(*refs)
+            _, refs = list(zip(*refs))
             return refs
 
         ret = []
@@ -362,7 +363,7 @@
 
         # create the groups dict with unmangled refs in its values
         groups = {}
-        for n, g in _groups.items():
+        for n, g in list(_groups.items()):
             if isinstance(g, str):  # avoid None or boolean values
                 g = g.format(**refs_dict)
             groups[n] = g
--- ./lib/taurus/core/evaluation/test/test_evalattribute.py	(original)
+++ ./lib/taurus/core/evaluation/test/test_evalattribute.py	(refactored)
@@ -278,7 +278,7 @@
         self.assertTrue(isinstance(read_value, EvaluationAttrValue), msg)
 
         # Test attribute
-        for k, exp in expected.iteritems():
+        for k, exp in expected.items():
             try:
                 got = getattr(a, k)
             except AttributeError:
@@ -290,7 +290,7 @@
             self.__assertValidValue(exp, got, msg)
 
         # Test attribute value
-        for k, exp in expected_attrv.iteritems():
+        for k, exp in expected_attrv.items():
             try:
                 got = getattr(read_value, k)
             except AttributeError:
@@ -330,7 +330,7 @@
         self.assertTrue(isinstance(read_value, EvaluationAttrValue), msg)
 
         # Test attribute
-        for k, exp in expected.iteritems():
+        for k, exp in expected.items():
             try:
                 got = getattr(a, k)
             except AttributeError:
@@ -342,7 +342,7 @@
             self.__assertValidValue(exp, got, msg)
 
         # Test attribute value
-        for k, exp in expected_attrv.iteritems():
+        for k, exp in expected_attrv.items():
             try:
                 got = getattr(read_value, k)
             except AttributeError:
--- ./lib/taurus/core/evaluation/test/res/mymod.py	(original)
+++ ./lib/taurus/core/evaluation/test/res/mymod.py	(refactored)
@@ -28,6 +28,8 @@
 """
 from __future__ import print_function
 
+from builtins import str
+from builtins import object
 import os
 from taurus.core.units import Quantity
 
--- ./lib/taurus/core/resource/resfactory.py	(original)
+++ ./lib/taurus/core/resource/resfactory.py	(refactored)
@@ -28,6 +28,7 @@
 """
 from __future__ import absolute_import
 
+from past.builtins import basestring
 import os
 import imp
 import operator
@@ -38,6 +39,7 @@
 from taurus.core.util.log import Logger
 from taurus.core.taurusfactory import TaurusFactory
 from taurus.core.taurusexception import TaurusException
+import collections
 
 
 class ResourcesFactory(Singleton, TaurusFactory, Logger):
@@ -85,12 +87,12 @@
         """
         if priority < 1:
             raise ValueError('priority must be >=1')
-        if operator.isMappingType(obj):
+        if isinstance(obj, collections.Mapping):
             name = name or 'DICT%02d' % priority
         elif type(obj) in (str,) or obj is None:
             name, mod = self.__reloadResource(obj)
             obj = {}
-            for k, v in mod.__dict__.items():
+            for k, v in list(mod.__dict__.items()):
                 if not k.startswith('_') and isinstance(v, basestring):
                     obj[k] = v
         else:
@@ -106,7 +108,7 @@
         if pl is None:
             self._resource_priority[priority] = pl = []
         pl.append(name)
-        self._resource_priority_keys = self._resource_priority.keys()
+        self._resource_priority_keys = list(self._resource_priority.keys())
         self._resource_priority_keys.sort()
         return obj
 
--- ./lib/taurus/core/resource/resvalidator.py	(original)
+++ ./lib/taurus/core/resource/resvalidator.py	(refactored)
@@ -22,6 +22,7 @@
 ##
 #############################################################################
 
+from builtins import object
 __all__ = ['ResDeviceNameValidator',
            'ResAttributeNameValidator']
 
--- ./lib/taurus/core/tango/starter.py	(original)
+++ ./lib/taurus/core/tango/starter.py	(refactored)
@@ -31,6 +31,8 @@
 """
 from __future__ import print_function
 
+from builtins import range
+from builtins import object
 __docformat__ = 'restructuredtext'
 
 
--- ./lib/taurus/core/tango/tangoattribute.py	(original)
+++ ./lib/taurus/core/tango/tangoattribute.py	(refactored)
@@ -25,6 +25,8 @@
 
 """This module contains all taurus tango attribute"""
 
+from builtins import str
+from builtins import range
 __all__ = ["TangoAttribute", "TangoAttributeEventListener", "TangoAttrValue"]
 
 __docformat__ = "restructuredtext"
@@ -114,7 +116,7 @@
                 if not (numerical or self._attrRef.type == DataType.Boolean):
                     # generate a nested empty list of given shape
                     p.value = []
-                    for _ in xrange(len(shape) - 1):
+                    for _ in range(len(shape) - 1):
                         p.value = [p.value]
 
         rvalue = p.value
@@ -378,7 +380,7 @@
             elif PyTango.is_int_type(tgtype):
                 # changed as a partial workaround to a problem in PyTango
                 # writing to DevULong64 attributes (see ALBA RT#29793)
-                attrvalue = long(magnitude)
+                attrvalue = int(magnitude)
             elif tgtype == PyTango.CmdArgType.DevBoolean:
                 try:
                     attrvalue = bool(int(magnitude))
--- ./lib/taurus/core/tango/tangodatabase.py	(original)
+++ ./lib/taurus/core/tango/tangodatabase.py	(refactored)
@@ -25,7 +25,14 @@
 
 """This module contains all taurus tango authority"""
 from __future__ import print_function
-
+from __future__ import division
+
+from builtins import str
+from builtins import map
+from builtins import range
+from past.utils import old_div
+from builtins import object
+import collections
 __all__ = ["TangoInfo", "TangoAttrInfo", "TangoDevInfo", "TangoServInfo",
            "TangoDevClassInfo", "TangoDatabaseCache", "TangoDatabase",
            "TangoAuthority"]
@@ -105,7 +112,7 @@
     def getDeviceNames(self):
         if not hasattr(self, "_device_name_list"):
             self._device_name_list = sorted(map(TangoDevInfo.name,
-                                                self._devices.values()))
+                                                list(self._devices.values())))
         return self._device_name_list
 
 
@@ -122,8 +129,8 @@
         self._alive = None
         self._state = None
         self._host = host
-        self._domain, self._family, self._member = map(str.upper,
-                                                       name.split("/", 2))
+        self._domain, self._family, self._member = list(map(str.upper,
+                                                       name.split("/", 2)))
         self._attributes = None
         self._alivePending = False
 
@@ -245,12 +252,12 @@
     def getDeviceNames(self):
         if not hasattr(self, "_device_name_list"):
             self._device_name_list = sorted(map(TangoDevInfo.name,
-                                                self._devices.values()))
+                                                list(self._devices.values())))
         return self._device_name_list
 
     def getClassNames(self):
         if not hasattr(self, "_klass_name_list"):
-            klasses = set(map(TangoDevInfo.klass, self._devices.values()))
+            klasses = set(map(TangoDevInfo.klass, list(self._devices.values())))
             self._klass_name_list = sorted(map(TangoDevClassInfo.name,
                                                klasses))
         return self._klass_name_list
@@ -285,7 +292,7 @@
             try:
                 self._alivePending = True
                 alive = True
-                for d in self.devices().values():
+                for d in list(self.devices().values()):
                     alive = d.alive()
                     if not alive:
                         break
@@ -327,7 +334,7 @@
             r = db.command_inout("DbMySqlSelect", query)
             row_nb, column_nb = r[0][-2:]
             data = r[1]
-            assert row_nb == len(data) / column_nb
+            assert row_nb == old_div(len(data), column_nb)
         else:
             # fallback using tango commands (slow but works with sqlite DB)
             # see http://sf.net/p/tauruslib/tickets/148/
@@ -349,7 +356,7 @@
         CD = CaselessDict
         dev_dict, serv_dict, klass_dict, alias_dict = CD(), {}, {}, CD()
 
-        for i in xrange(0, len(data), column_nb):
+        for i in range(0, len(data), column_nb):
             name, alias, exported, host, server, klass = data[i:i + column_nb]
             if name.count("/") != 2:
                 continue  # invalid/corrupted entry: just ignore it
@@ -423,13 +430,13 @@
         :return: (sequence<str>) a sequence with all registered device names"""
         if self._device_name_list is None:
             self._device_name_list = sorted(
-                map(TangoDevInfo.name, self.devices().values()))
+                map(TangoDevInfo.name, list(self.devices().values())))
         return self._device_name_list
 
     def getAliasNames(self):
         if self._alias_name_list is None:
             self._alias_name_list = sorted(
-                map(TangoDevInfo.alias, self.aliases().values()))
+                map(TangoDevInfo.alias, list(self.aliases().values())))
         return self._alias_name_list
 
     def getServerNames(self):
@@ -438,7 +445,7 @@
         :return: (sequence<str>) a sequence with all registered server names"""
         if self._server_name_list is None:
             self._server_name_list = sorted(
-                map(TangoServInfo.name, self.servers().values()))
+                map(TangoServInfo.name, list(self.servers().values())))
         return self._server_name_list
 
     def getClassNames(self):
@@ -447,7 +454,7 @@
         :return: (sequence<str>) a sequence with all registered device classes"""
         if self._klass_name_list is None:
             self._klass_name_list = sorted(
-                map(TangoDevClassInfo.name, self.klasses().values()))
+                map(TangoDevClassInfo.name, list(self.klasses().values())))
         return self._klass_name_list
 
     def deviceTree(self):
@@ -474,13 +481,13 @@
         return self._klasses
 
     def getDeviceDomainNames(self):
-        return self._device_tree.keys()
+        return list(self._device_tree.keys())
 
     def getDeviceFamilyNames(self, domain):
         families = self._device_tree.get(domain)
         if families is None:
             return []
-        return families.keys()
+        return list(families.keys())
 
     def getDeviceMemberNames(self, domain, family):
         families = self._device_tree.get(domain)
@@ -489,7 +496,7 @@
         members = families.get(family)
         if members is None:
             return []
-        return members.keys()
+        return list(members.keys())
 
     def getDomainDevices(self, domain):
         return self.deviceTree().getDomainDevices(domain)
@@ -511,8 +518,8 @@
 
     def _update(self, other):
         try:
-            if operator.isMappingType(other):
-                other = other.values()
+            if isinstance(other, collections.Mapping):
+                other = list(other.values())
             for dev in other:
                 try:
                     self.addDevice(dev)
@@ -537,7 +544,7 @@
     def getDomainDevices(self, domain):
         """Returns all devices under the given domain. Returns empty list if
         the domain doesn't exist or doesn't contain any devices"""
-        return self._devices.get(domain, {}).values()
+        return list(self._devices.get(domain, {}).values())
 
     def getFamilyDevices(self, domain, family):
         """Returns all devices under the given domain/family. Returns empty list if
@@ -545,7 +552,7 @@
         families = self.get(domain)
         if families is None:
             return
-        return families.get(family, {}).values()
+        return list(families.get(family, {}).values())
 
 
 class TangoServerTree(dict):
@@ -557,8 +564,8 @@
 
     def _update(self, other):
         try:
-            if operator.isMappingType(other):
-                other = other.values()
+            if isinstance(other, collections.Mapping):
+                other = list(other.values())
             for serv in other:
                 try:
                     self.addServer(serv)
@@ -578,7 +585,7 @@
     def getServerNameInstances(self, serverName):
         """Returns all servers under the given serverName. Returns empty list if
         the server name doesn't exist or doesn't contain any instances"""
-        return self.get(serverName, {}).values()
+        return list(self.get(serverName, {}).values())
 
 
 def get_home():
@@ -649,7 +656,7 @@
             # illegal line!
             continue
 
-        key, val = map(str.strip, tup)
+        key, val = list(map(str.strip, tup))
         if key == env_var_name:
             return val
 
@@ -702,7 +709,7 @@
         serv_name = self.command_inout("DbGetDeviceInfo", dev_name)[1][3]
         devs = self.get_device_class_list(serv_name)
         dev_name_lower = dev_name.lower()
-        for i in xrange(len(devs) / 2):
+        for i in range(old_div(len(devs), 2)):
             idx = i * 2
             if devs[idx].lower() == dev_name_lower:
                 return devs[idx + 1]
--- ./lib/taurus/core/tango/tangodevice.py	(original)
+++ ./lib/taurus/core/tango/tangodevice.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module defines the TangoDevice object"""
 
+from builtins import object
 __all__ = ["TangoDevice"]
 
 __docformat__ = "restructuredtext"
@@ -320,7 +321,7 @@
 
     def __pollResult(self, attrs, ts, result, error=False):
         if error:
-            for attr in attrs.values():
+            for attr in list(attrs.values()):
                 attr.poll(single=False, value=None, error=result, time=ts)
             return
 
@@ -335,7 +336,7 @@
     def __pollAsynch(self, attrs):
         ts = time.time()
         try:
-            req_id = self.read_attributes_asynch(attrs.keys())
+            req_id = self.read_attributes_asynch(list(attrs.keys()))
         except DevFailed as e:
             return False, e, ts
         return True, req_id, ts
@@ -363,7 +364,7 @@
         error = False
         ts = time.time()
         try:
-            result = self.read_attributes(attrs.keys())
+            result = self.read_attributes(list(attrs.keys()))
         except DevFailed as e:
             error = True
             result = e
--- ./lib/taurus/core/tango/tangofactory.py	(original)
+++ ./lib/taurus/core/tango/tangofactory.py	(refactored)
@@ -131,16 +131,16 @@
     def cleanUp(self):
         """Cleanup the singleton instance"""
         self.trace("[TangoFactory] cleanUp")
-        for k, v in self.tango_attrs.items():
+        for k, v in list(self.tango_attrs.items()):
             v.cleanUp()
-        for k, v in self.tango_dev_queries.items():
+        for k, v in list(self.tango_dev_queries.items()):
             v.cleanUp()
-        for k, v in self.tango_devs.items():
+        for k, v in list(self.tango_devs.items()):
             v.cleanUp()
         self.dft_db = None
-        for k, v in self.tango_db_queries.items():
+        for k, v in list(self.tango_db_queries.items()):
             v.cleanUp()
-        for k, v in self.tango_db.items():
+        for k, v in list(self.tango_db.items()):
             v.cleanUp()
         self.reInit()
 
@@ -552,14 +552,14 @@
         if not self.isPollingEnabled():
             return
         self._polling_enabled = False
-        for period, timer in self.polling_timers.iteritems():
+        for period, timer in self.polling_timers.items():
             timer.stop()
 
     def enablePolling(self):
         """Enable the application tango polling"""
         if self.isPollingEnabled():
             return
-        for period, timer in self.polling_timers.iteritems():
+        for period, timer in self.polling_timers.items():
             timer.start()
         self._polling_enabled = True
 
--- ./lib/taurus/core/tango/img/img.py	(original)
+++ ./lib/taurus/core/tango/img/img.py	(refactored)
@@ -25,7 +25,9 @@
 
 """The img submodule. It contains specific device implementation for CCDs and
 2D detectors"""
+from __future__ import division
 
+from past.utils import old_div
 __all__ = ['ImageDevice', 'ImageCounterDevice', 'PyImageViewer', 'ImgGrabber',
            'CCDPVCAM', 'ImgBeamAnalyzer', 'Falcon', 'LimaCCDs']
 
@@ -164,9 +166,9 @@
     def getImageData(self, names=None):
         data = ImageCounterDevice.getImageData(self, names=names)
         if self._color:
-            for k, v in data.items():
+            for k, v in list(data.items()):
                 s = v[1].value.shape
-                v[1].value = v[1].value.reshape((s[0], s[1] / 3, 3))
+                v[1].value = v[1].value.reshape((s[0], old_div(s[1], 3), 3))
         return data
 
 
--- ./lib/taurus/core/tango/test/test_tangoattribute.py	(original)
+++ ./lib/taurus/core/tango/test/test_tangoattribute.py	(refactored)
@@ -27,6 +27,7 @@
 
 # __all__ = []
 
+from builtins import map
 __docformat__ = 'restructuredtext'
 
 import numpy
@@ -771,12 +772,12 @@
         got = getattr(attr, cfg)
         msg = '%s.%s from Taurus do not mach, expected %s read %s' %\
               (attr_name, cfg, expected, got)
-        map(self.__assertValidValue, got, expected, msg)
+        list(map(self.__assertValidValue, got, expected, msg))
 
         msg = '%s.%s from Tango do not mach, expected %s read %s' %\
               (attr_name, cfg, expected, got)
         tangovalue = self._getDecodePyTangoAttr(attr_name, cfg)
-        map(self.__assertValidValue, got, tangovalue, msg)
+        list(map(self.__assertValidValue, got, tangovalue, msg))
 
     def write_read_attr(self, attrname=None, setvalue=None, expected=None,
                         expected_attrv=None, expectedshape=None):
@@ -801,7 +802,7 @@
         self.assertTrue(isinstance(read_value, TangoAttrValue), msg)
 
         # Test attribute
-        for k, exp in expected.iteritems():
+        for k, exp in expected.items():
             try:
                 got = getattr(a, k)
             except AttributeError:
@@ -813,7 +814,7 @@
             self.__assertValidValue(exp, got, msg)
 
         # Test attribute value
-        for k, exp in expected_attrv.iteritems():
+        for k, exp in expected_attrv.items():
             try:
                 got = getattr(read_value, k)
             except AttributeError:
--- ./lib/taurus/core/tango/test/tgtestds.py	(original)
+++ ./lib/taurus/core/tango/test/tgtestds.py	(refactored)
@@ -25,6 +25,7 @@
 
 """Module containing base classes for using the TangoSchemeTest DS in tests"""
 
+from builtins import object
 __all__ = ['TangoSchemeTestLauncher']
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/core/test/basevalidator.py	(original)
+++ ./lib/taurus/core/test/basevalidator.py	(refactored)
@@ -27,6 +27,8 @@
 
 #__all__ = []
 
+from builtins import str
+from builtins import object
 __docformat__ = 'restructuredtext'
 
 
@@ -49,7 +51,7 @@
         self.assertTrue(self.validator().isValid(name, strict=strict), msg)
         if groups is not None:
             returned = self.validator().getUriGroups(name, strict=strict)
-            for k, v in groups.iteritems():
+            for k, v in groups.items():
                 msg = ('"%s" not in %s.getUriGroups("%s"). Returned %s' %
                        (k, self.validator.__name__, name, returned))
                 self.assertIn(k, returned, msg=msg)
--- ./lib/taurus/core/test/modelequality.py	(original)
+++ ./lib/taurus/core/test/modelequality.py	(refactored)
@@ -22,6 +22,7 @@
 ##
 #############################################################################
 
+from builtins import object
 import functools
 
 from taurus import Device, Attribute  # , Authority
--- ./lib/taurus/core/test/test_taurushelper.py	(original)
+++ ./lib/taurus/core/test/test_taurushelper.py	(refactored)
@@ -212,7 +212,7 @@
             elementType = [elementType]
         manager = taurus.Manager()
         scheme = manager.getScheme(name)
-        supportedSchemes = manager.getPlugins().keys()
+        supportedSchemes = list(manager.getPlugins().keys())
         if scheme not in supportedSchemes:
             self.skipTest('"%s" scheme not supported' % scheme)
         returned = taurus.isValidName(name, etypes=elementType, strict=strict)
@@ -240,7 +240,7 @@
             klass = TaurusAuthority
         manager = taurus.Manager()
         scheme = manager.getScheme(name)
-        supportedSchemes = manager.getPlugins().keys()
+        supportedSchemes = list(manager.getPlugins().keys())
         if scheme not in supportedSchemes:
             self.skipTest('"%s" scheme not supported' % scheme)
         a = taurus.Authority(name)
@@ -265,7 +265,7 @@
             klass = TaurusDevice
         manager = taurus.Manager()
         scheme = manager.getScheme(name)
-        supportedSchemes = manager.getPlugins().keys()
+        supportedSchemes = list(manager.getPlugins().keys())
         if scheme not in supportedSchemes:
             self.skipTest('"%s" scheme not supported' % scheme)
 
@@ -419,7 +419,7 @@
             klass = TaurusAttribute
         manager = taurus.Manager()
         scheme = manager.getScheme(name)
-        supportedSchemes = manager.getPlugins().keys()
+        supportedSchemes = list(manager.getPlugins().keys())
         if scheme not in supportedSchemes:
             self.skipTest('"%s" scheme not supported' % scheme)
         a = taurus.Attribute(name)
@@ -441,7 +441,7 @@
         msg = ('read() for "%s" did not return a TaurusAttrValue (got a %s)' %
                (name, readvalue.__class__.__name__))
         self.assertTrue(isinstance(readvalue, TaurusAttrValue), msg)
-        for k, exp in expected.iteritems():
+        for k, exp in expected.items():
             try:
                 got = getattr(readvalue, k)
             except AttributeError:
--- ./lib/taurus/core/util/codecs.py	(original)
+++ ./lib/taurus/core/util/codecs.py	(refactored)
@@ -64,6 +64,7 @@
 """
 from __future__ import absolute_import
 
+from builtins import str
 __all__ = ["Codec", "NullCodec", "ZIPCodec", "BZ2Codec", "JSONCodec",
            "FunctionCodec", "PlotCodec", "CodecPipeline", "CodecFactory"]
 
@@ -348,7 +349,7 @@
         return format, data
 
     def _transform_ascii(self, data):
-        if isinstance(data, unicode):
+        if isinstance(data, str):
             return data.encode('utf-8')
         elif isinstance(data, dict):
             return self._transform_dict(data)
@@ -364,7 +365,7 @@
 
     def _transform_dict(self, dct):
         newdict = {}
-        for k, v in dct.iteritems():
+        for k, v in dct.items():
             newdict[self._transform_ascii(k)] = self._transform_ascii(v)
         return newdict
 
@@ -426,7 +427,7 @@
         return format, data
 
     def _transform_ascii(self, data):
-        if isinstance(data, unicode):
+        if isinstance(data, str):
             return data.encode('utf-8')
         elif isinstance(data, dict):
             return self._transform_dict(data)
@@ -442,7 +443,7 @@
 
     def _transform_dict(self, dct):
         newdict = {}
-        for k, v in dct.iteritems():
+        for k, v in dct.items():
             newdict[self._transform_ascii(k)] = self._transform_ascii(v)
         return newdict
 
--- ./lib/taurus/core/util/colors.py	(original)
+++ ./lib/taurus/core/util/colors.py	(refactored)
@@ -26,6 +26,8 @@
 """This module contains color codes for state and quality"""
 from __future__ import print_function
 
+from builtins import str
+from builtins import object
 __all__ = ["DEVICE_STATE_DATA", "ATTRIBUTE_QUALITY_DATA", "ColorPalette",
            "DEVICE_STATE_PALETTE", "ATTRIBUTE_QUALITY_PALETTE"]
 
@@ -123,7 +125,7 @@
         return r[0] * 256 * 256 + r[1] * 256 + r[2]
 
     def __iter__(self):
-        return self._rgb_data.keys().__iter__()
+        return list(self._rgb_data.keys()).__iter__()
 
     def name(self, stoq, fg=False):
         """Returns the name of the color."""
--- ./lib/taurus/core/util/console.py	(original)
+++ ./lib/taurus/core/util/console.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module contains ANSI color codes"""
 
+from builtins import object
 __all__ = ["make_color_table", "NoColors", "TermColors", "HTMLColors"]
 
 __docformat__ = "restructuredtext"
@@ -63,13 +64,13 @@
                 setattr(in_class, name, in_class._base % value)
 
 
-class NoColors:
+class NoColors(object):
     NoColor = ''  # for color schemes in color-less terminals.
     Normal = ''   # Reset normal coloring
     _base = ''  # Template for all other colors
 
 
-class TermColors:
+class TermColors(object):
     """Color escape sequences.
 
     This class defines the escape sequences for all the standard (ANSI?)
@@ -86,7 +87,7 @@
     _base = '\033[%sm'  # Template for all other colors
 
 
-class HTMLColors:
+class HTMLColors(object):
 
     NoColor = ''
     Normal = '</font>'
--- ./lib/taurus/core/util/constant.py	(original)
+++ ./lib/taurus/core/util/constant.py	(refactored)
@@ -46,10 +46,11 @@
   consttype.__del__()     # Remove all attributes
 """
 
+from builtins import object
 __docformat__ = "restructuredtext"
 
 
-class _consttype:
+class _consttype(object):
 
     class _ConstTypeError(TypeError):
         pass
--- ./lib/taurus/core/util/containers.py	(original)
+++ ./lib/taurus/core/util/containers.py	(refactored)
@@ -29,6 +29,11 @@
 """
 from __future__ import print_function
 
+from builtins import zip
+from builtins import str
+from builtins import range
+from past.builtins import basestring
+from builtins import object
 __all__ = ["CaselessList", "CaselessDict", "CaselessWeakValueDict", "LoopList",
            "CircBuf", "LIFO", "TimedQueue", "self_locked", "ThreadDict",
            "defaultdict", "defaultdict_fromkey", "CaselessDefaultDict",
@@ -250,7 +255,7 @@
         if other:
             # Doesn't do keyword args
             if isinstance(other, dict):
-                for k, v in other.items():
+                for k, v in list(other.items()):
                     dict.__setitem__(self, k.lower(), v)
             else:
                 for k, v in other:
@@ -279,7 +284,7 @@
 
     def update(self, other):
         """overwritten from :meth:`dict.update`"""
-        for k, v in other.items():
+        for k, v in list(other.items()):
             dict.__setitem__(self, k.lower(), v)
 
     def fromkeys(self, iterable, value=None):
@@ -303,7 +308,7 @@
         if other:
             # Doesn't do keyword args
             if isinstance(other, dict):
-                for k, v in other.items():
+                for k, v in list(other.items()):
                     weakref.WeakValueDictionary.__setitem__(self, k.lower(), v)
             else:
                 for k, v in other:
@@ -334,7 +339,7 @@
 
     def update(self, other):
         """overwritten from :meth:`weakref.WeakValueDictionary.update`"""
-        for k, v in other.items():
+        for k, v in list(other.items()):
             weakref.WeakValueDictionary.__setitem__(self, k.lower(), v)
 
     def fromkeys(self, iterable, value=None):
@@ -413,7 +418,7 @@
 
     def dump(self, fileobj):
         if self.format == 'csv':
-            csv.writer(fileobj).writerows(self.items())
+            csv.writer(fileobj).writerows(list(self.items()))
         elif self.format == 'json':
             json.dump(self, fileobj, separators=(',', ':'))
         elif self.format == 'pickle':
@@ -487,7 +492,7 @@
         '''returns the current index'''
         return self._index
 
-    def next(self):
+    def __next__(self):
         '''advances one item in the list and returns it'''
         self._index += 1
         return self.current()
@@ -897,7 +902,7 @@
                     or a callable providing a sorting key algorithm.
         """
         import operator
-        if operator.isCallable(key):
+        if hasattr(key, '__call__'):
             self._keys = sorted(self._keys, key=key)
         else:
             for k in self._keys:
@@ -913,7 +918,7 @@
 
     def update(self, other):
         if hasattr(other, 'items'):
-            other = other.items()
+            other = list(other.items())
         for k, v in other:
             self.__setitem__(k, v)
 
@@ -989,7 +994,7 @@
                 args = tuple()
             else:
                 args = self.default_factory,
-            return type(self), args, None, None, self.items()
+            return type(self), args, None, None, list(self.items())
 
         def copy(self):
             return self.__copy__()
@@ -1000,7 +1005,7 @@
         def __deepcopy__(self, memo):
             import copy
             return type(self)(self.default_factory,
-                              copy.deepcopy(self.items()))
+                              copy.deepcopy(list(self.items())))
 
         def __repr__(self):
             return 'defaultdict(%s, %s)' % (self.default_factory,
@@ -1055,7 +1060,7 @@
     def add_to_level(l, d):
         lines = []
         if isinstance(d, dict):
-            for k, v in d.items():
+            for k, v in list(d.items()):
                 print('with key "%s"' % k)
                 lines.append([''] * l + [str(k)])
                 lines += add_to_level(l + 1, v)
@@ -1128,7 +1133,7 @@
     def __str__(self):
         return self.__buffer[:self.__end].__str__()
 
-    def __nonzero__(self):
+    def __bool__(self):
         return self.__buffer[:self.__end].__nonzero__()
 
     def __setitem__(self, i, x):
@@ -1317,5 +1322,5 @@
 
 def chunks(l, n):
     '''Generator which yields successive n-sized chunks from l'''
-    for i in xrange(0, len(l), n):
+    for i in range(0, len(l), n):
         yield l[i:i + n]
--- ./lib/taurus/core/util/enumeration.py	(original)
+++ ./lib/taurus/core/util/enumeration.py	(refactored)
@@ -33,6 +33,8 @@
 values (specified and unspecified) are unique. Enum values then are attributes
 of an Enumeration class (Volkswagen.BEETLE, Volkswagen.PASSAT, etc.)."""
 
+from builtins import str
+from builtins import object
 __all__ = ["EnumException", "Enumeration"]
 
 __docformat__ = "restructuredtext"
@@ -95,9 +97,9 @@
                     raise EnumException(
                         "flagable enum does not accept tuple items")
                 x, i = x
-                if not isinstance(x, (str, unicode)):
+                if not isinstance(x, (str, str)):
                     raise EnumException("enum name is not a string: " + str(x))
-                if not isinstance(i, (int, long)):
+                if not isinstance(i, (int, int)):
                     raise EnumException(
                         "enum value is not an integer: " + str(i))
                 if x in uniqueNames:
@@ -111,7 +113,7 @@
                 reverseLookup[i] = x
         for x in enumList:
             if not isinstance(x, tuple):
-                if not isinstance(x, (str, unicode)):
+                if not isinstance(x, (str, str)):
                     raise EnumException("enum name is not a string: " + str(x))
                 if x in uniqueNames:
                     raise EnumException("enum name is not unique: " + str(x))
@@ -143,15 +145,15 @@
         return n
 
     def __contains__(self, i):
-        if isinstance(i, (int, long)):
+        if isinstance(i, (int, int)):
             return i in self.reverseLookup
-        elif isinstance(i, (str, unicode)):
+        elif isinstance(i, (str, str)):
             return i in self.lookup
 
     def __getitem__(self, i):
-        if isinstance(i, (int, long)):
+        if isinstance(i, (int, int)):
             return self.whatis(i)
-        elif isinstance(i, (str, unicode)):
+        elif isinstance(i, (str, str)):
             return self.lookup[i]
 
     def __getattr__(self, attr):
@@ -193,7 +195,7 @@
         """Returns an iterable containning the valid enumeration keys
         :return: an interable containning the valid enumeration keys
         :rtype: iter<str>"""
-        return self.lookup.keys()
+        return list(self.lookup.keys())
 
     def whatis(self, value):
         """Returns a string representation of the value in the enumeration.
--- ./lib/taurus/core/util/event.py	(original)
+++ ./lib/taurus/core/util/event.py	(refactored)
@@ -29,6 +29,10 @@
 from __future__ import print_function
 from __future__ import absolute_import
 
+from past.builtins import cmp
+from builtins import str
+from builtins import range
+from builtins import object
 __all__ = ["BoundMethodWeakref", "CallableRef", "EventGenerator",
            "ConfigEventGenerator", "ListEventGenerator", "EventListener",
            "AttributeEventWait", "AttributeEventIterator"]
@@ -232,7 +236,7 @@
         try:
             self.lock()
             aux_list = list(self.cb_list)
-            for i in xrange(len(aux_list) - 1, -1, -1):
+            for i in range(len(aux_list) - 1, -1, -1):
                 pair = self.cb_list[i]
                 if pair[0] is cb_ref:
                     del self.cb_list[i]
@@ -446,7 +450,7 @@
                 if t and t >= after:
                     return
             else:
-                for v, t in s.items():
+                for v, t in list(s.items()):
                     if v == val:
                         continue
                     if t >= after:
@@ -646,7 +650,7 @@
                 retries += 1
             while retries != 0:
                 if any:
-                    for v, t in s.items():
+                    for v, t in list(s.items()):
                         if t >= after:
                             return
                 if equal:
@@ -654,7 +658,7 @@
                     if (t is not None) and (t >= after):
                         return
                 else:
-                    for v, t in s.items():
+                    for v, t in list(s.items()):
                         if v == val:
                             continue
                         if t >= after:
--- ./lib/taurus/core/util/eventfilters.py	(original)
+++ ./lib/taurus/core/util/eventfilters.py	(refactored)
@@ -27,6 +27,7 @@
 :meth:`taurus.qt.qtgui.base.TaurusBaseComponent.setFilters`"""
 
 
+from builtins import object
 def IGNORE_ALL(s, t, v):
     '''Will discard all events'''
     return None
--- ./lib/taurus/core/util/excepthook.py	(original)
+++ ./lib/taurus/core/util/excepthook.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module contains a base class for exception hooks"""
 
+from builtins import object
 __all__ = ["BaseExceptHook"]
 
 __docformat__ = "restructuredtext"
--- ./lib/taurus/core/util/fandango_search.py	(original)
+++ ./lib/taurus/core/util/fandango_search.py	(refactored)
@@ -31,6 +31,7 @@
 """
 # TODO: tango-centric
 
+from builtins import str
 import re
 import taurus
 
@@ -116,8 +117,8 @@
     #all_devs.extend('%s/%s'%(host,d) for d in odb.get_device_name('*','*'))
     result = [e for e in expressions if e.lower() in all_devs]
     expressions = [extend_regexp(e) for e in expressions if e not in result]
-    result.extend(filter(lambda d: any(matchCl(extend_regexp(e), d)
-                                       for e in expressions), all_devs))
+    result.extend([d for d in all_devs if any(matchCl(extend_regexp(e), d)
+                                       for e in expressions)])
     return result
 
 
--- ./lib/taurus/core/util/helper.py	(original)
+++ ./lib/taurus/core/util/helper.py	(refactored)
@@ -1,6 +1,6 @@
 import sys
 if sys.version_info < (3,):
-    text_type = unicode
+    text_type = str
     binary_type = str
 else:
     text_type = str
@@ -11,4 +11,4 @@
     return isinstance(element, (text_type, binary_type))
 
 def isnumber(element):
-    return isinstance(element, (int, long))
+    return isinstance(element, (int, int))
--- ./lib/taurus/core/util/init_bkcomp.py	(original)
+++ ./lib/taurus/core/util/init_bkcomp.py	(refactored)
@@ -78,7 +78,7 @@
     :return: (dict) dictionary built from the given sequence"""
     def _pairwise(iterable):
         """Utility method used by dictFromSequence"""
-        itnext = iter(iterable).next
+        itnext = iter(iterable).__next__
         while True:
             yield itnext(), itnext()
     return dict(_pairwise(seq))
--- ./lib/taurus/core/util/init_lightweight.py	(original)
+++ ./lib/taurus/core/util/init_lightweight.py	(refactored)
@@ -77,7 +77,7 @@
     :return: (dict) dictionary built from the given sequence"""
     def _pairwise(iterable):
         """Utility method used by dictFromSequence"""
-        itnext = iter(iterable).next
+        itnext = iter(iterable).__next__
         while True:
             yield itnext(), itnext()
     return dict(_pairwise(seq))
--- ./lib/taurus/core/util/lock.py	(original)
+++ ./lib/taurus/core/util/lock.py	(refactored)
@@ -26,6 +26,7 @@
 """This module defines a *slow* lock class that provides additional debugging
 information"""
 
+from builtins import object
 __all__ = ["TaurusLock"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/core/util/log.py	(original)
+++ ./lib/taurus/core/util/log.py	(refactored)
@@ -28,6 +28,8 @@
 from __future__ import print_function
 from __future__ import absolute_import
 
+from builtins import str
+from builtins import object
 __all__ = ["LogIt", "TraceIt", "DebugIt", "InfoIt", "WarnIt", "ErrorIt",
            "CriticalIt", "MemoryLogHandler", "LogExceptHook", "Logger",
            "LogFilter",
@@ -63,14 +65,14 @@
 
     def getTotal(self):
         c = 0
-        for v in self.itervalues():
+        for v in self.values():
             c += v
         return c
 
     def pretty(self):
         from operator import itemgetter
         sorted_items = sorted(
-            self.iteritems(), key=itemgetter(1), reverse=True)
+            iter(self.items()), key=itemgetter(1), reverse=True)
         ret = '\n'.join(['\t%d * "%s"' % (v, k) for k, v in sorted_items])
         return "< Deprecation Counts (%d):\n%s >" % (self.getTotal(), ret)
 
@@ -680,7 +682,7 @@
            :return: (sequence<logging.Logger) the list of log children
         """
         children = []
-        for _, ref in self.log_children.iteritems():
+        for _, ref in self.log_children.items():
             child = ref()
             if child is not None:
                 children.append(child)
@@ -783,7 +785,7 @@
                     out += '\n\t  -> line = [%d]: %s' % (line, lines[0])
             if frame:
                 out += '\n\t   locals = '
-                for k, v in frame.f_locals.items():
+                for k, v in list(frame.f_locals.items()):
                     out += '\n\t\t%20s = ' % k
                     try:
                         cut = False
--- ./lib/taurus/core/util/object.py	(original)
+++ ./lib/taurus/core/util/object.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module contains the base Object class for taurus."""
 
+from builtins import object
 __all__ = ["Object"]
 
 __docformat__ = "restructuredtext"
--- ./lib/taurus/core/util/property_parser.py	(original)
+++ ./lib/taurus/core/util/property_parser.py	(refactored)
@@ -26,6 +26,8 @@
 """This is an experimental property parser"""
 from __future__ import print_function
 
+from builtins import str
+from builtins import range
 import os
 
 import ply.lex as lex
@@ -48,7 +50,7 @@
           'COMMA',
           'LLST', 'RLST',
           #'LBRACKET', 'RBRACKET',
-          ] + reserved.values()
+          ] + list(reserved.values())
 
 t_EQUALS = r'\='
 t_LLST = r'\['
--- ./lib/taurus/core/util/propertyfile.py	(original)
+++ ./lib/taurus/core/util/propertyfile.py	(refactored)
@@ -34,6 +34,8 @@
 Modified - Tiago Coutinho
 """
 
+from builtins import next
+from builtins import object
 __all__ = ["Properties"]
 
 __docformat__ = "restructuredtext"
@@ -69,7 +71,7 @@
 
     def __str__(self):
         s = '{'
-        for key, value in self._props.items():
+        for key, value in list(self._props.items()):
             s = ''.join((s, key, '=', value, ', '))
 
         s = ''.join((s[:-2], '}'))
@@ -275,14 +277,14 @@
         """ Return an iterator over all the keys of the property
         dictionary, i.e the names of the properties """
 
-        return self._props.keys()
+        return list(self._props.keys())
 
     def list(self, out=sys.stdout):
         """ Prints a listing of the properties to the
         stream 'out' which defaults to the standard output """
 
         out.write('-- listing properties --\n')
-        for key, value in self._props.items():
+        for key, value in list(self._props.items()):
             out.write(''.join((key, '=', value, '\n')))
 
     def store(self, out, header=""):
@@ -298,7 +300,7 @@
             tstamp = time.strftime('%a %b %d %H:%M:%S %Z %Y', time.localtime())
             out.write(''.join(('#', tstamp, '\n')))
             # Write properties from the pristine dictionary
-            for prop, val in self._origprops.items():
+            for prop, val in list(self._origprops.items()):
                 out.write(''.join((prop, '=', self.escape(val), '\n')))
 
             out.close()
--- ./lib/taurus/core/util/remotelogmonitor.py	(original)
+++ ./lib/taurus/core/util/remotelogmonitor.py	(refactored)
@@ -28,6 +28,8 @@
 from __future__ import print_function
 from __future__ import with_statement
 
+from future import standard_library
+standard_library.install_aliases()
 __all__ = ["LogRecordStreamHandler", "LogRecordSocketReceiver", "log"]
 
 import time
@@ -41,7 +43,7 @@
 try:
     import socketserver
 except:
-    import SocketServer as socketserver
+    import socketserver as socketserver
 
 
 class LogRecordStreamHandler(socketserver.StreamRequestHandler):
--- ./lib/taurus/core/util/safeeval.py	(original)
+++ ./lib/taurus/core/util/safeeval.py	(refactored)
@@ -28,6 +28,8 @@
 """
 from __future__ import print_function
 
+from builtins import range
+from builtins import object
 __all__ = ["SafeEvaluator"]
 
 __docformat__ = "restructuredtext"
@@ -117,7 +119,7 @@
 
 if __name__ == '__main__':
 
-    x = range(6)
+    x = list(range(6))
     sev = SafeEvaluator()
     print("trying to evaluate a variable that has not been registered")
     try:
--- ./lib/taurus/core/util/singleton.py	(original)
+++ ./lib/taurus/core/util/singleton.py	(refactored)
@@ -26,6 +26,7 @@
 """This module contains a class which can be used as a super class for all
 classes that need to implement the Singleton design pattern."""
 
+from builtins import object
 __all__ = ["Singleton"]
 
 __docformat__ = "restructuredtext"
--- ./lib/taurus/core/util/tablepprint.py	(original)
+++ ./lib/taurus/core/util/tablepprint.py	(refactored)
@@ -25,11 +25,16 @@
 
 """Adapted from http://code.activestate.com/recipes/267662/"""
 from __future__ import print_function
+from future import standard_library
+standard_library.install_aliases()
+from builtins import zip
+from builtins import str
+from builtins import range
 from functools import reduce
 
 __docformat__ = "restructuredtext"
 
-import cStringIO
+import io
 import operator
 import re
 import math
@@ -58,13 +63,13 @@
     # closure for breaking logical rows to physical, using wrapfunc
     def rowWrapper(row):
         newRows = [wrapfunc(item).split('\n') for item in row]
-        return [[substr or '' for substr in item] for item in map(None, *newRows)]
+        return [[substr or '' for substr in item] for item in list(*newRows)]
 
     # break each logical row into one or more physical ones
     logicalRows = [rowWrapper(row) for row in rows]
     # columns of physical rows
 
-    columns = map(None, *reduce(operator.add, logicalRows))
+    columns = list(*reduce(operator.add, logicalRows))
 
     # get the maximum of each column by the string length of its items
     maxWidths = [max([len(str(item)) for item in column])
@@ -127,7 +132,7 @@
     """A simple word-wrap function that wraps text on exactly width characters.
        It doesn't split the text in words."""
     return '\n'.join([text[width * i:width * (i + 1)]
-                      for i in xrange(int(math.ceil(1. * len(text) / width)))])
+                      for i in range(int(math.ceil(1. * len(text) / width)))])
 
 if __name__ == '__main__':
     labels = ('First Name', 'Last Name', 'Age', 'Position')
--- ./lib/taurus/core/util/tb.py	(original)
+++ ./lib/taurus/core/util/tb.py	(refactored)
@@ -26,6 +26,7 @@
 """This module contains a set of useful traceback elements based on python's
 :mod:`traceback` system."""
 
+from builtins import str
 import sys
 import inspect
 import traceback
@@ -50,7 +51,7 @@
     frame_stacks = extract_frame_stacks(frames=frames, limit=limit)
     ret = []
 
-    for ident, (frame, frame_stack) in frame_stacks.items():
+    for ident, (frame, frame_stack) in list(frame_stacks.items()):
         curr_th, th = _get_thread(), _get_thread(ident)
         if th is None:
             th_name = "<Unknown>"
@@ -73,7 +74,7 @@
     if frames is None:
         frames = _get_frames()
     ret = {}
-    for ident, frame in frames.items():
+    for ident, frame in list(frames.items()):
         frame_stack = traceback.extract_stack(frame, limit=limit)
         ret[ident] = frame, frame_stack
     return ret
--- ./lib/taurus/core/util/threadpool.py	(original)
+++ ./lib/taurus/core/util/threadpool.py	(refactored)
@@ -26,13 +26,18 @@
 """adapted from http://code.activestate.com/recipes/576576/"""
 from __future__ import print_function
 from __future__ import absolute_import
-
+from __future__ import division
+
+from future import standard_library
+standard_library.install_aliases()
+from builtins import range
+from past.utils import old_div
 __all__ = ["ThreadPool", "Worker"]
 
 __docformat__ = "restructuredtext"
 
 from threading import Thread, currentThread
-from Queue import Queue
+from queue import Queue
 from time import sleep, time
 from traceback import extract_stack, format_list
 
@@ -166,7 +171,7 @@
 
     def badJob(*a, **k):
         print('\n !!! OOOPS !!!\n')
-        a = 1 / 0
+        a = old_div(1, 0)
 
     def show(*arg, **kw):
         print('callback : %s' % arg[0])
--- ./lib/taurus/core/util/argparse/taurusargparse.py	(original)
+++ ./lib/taurus/core/util/argparse/taurusargparse.py	(refactored)
@@ -78,6 +78,7 @@
         sys.exit(app.exec_())
 """
 
+from builtins import str
 __all__ = ["get_taurus_parser", "init_taurus_args", "parse_taurus_args",
            "split_taurus_args"]
 
--- ./lib/taurus/core/util/decorator/memoize.py	(original)
+++ ./lib/taurus/core/util/decorator/memoize.py	(refactored)
@@ -23,6 +23,7 @@
 ##
 #############################################################################
 
+from builtins import object
 import functools
 
 
--- ./lib/taurus/core/util/decorator/typecheck.py	(original)
+++ ./lib/taurus/core/util/decorator/typecheck.py	(refactored)
@@ -64,6 +64,8 @@
 """
 from __future__ import print_function
 
+from builtins import str
+from builtins import map
 __all__ = ["accepts", "returns"]
 
 __docformat__ = "restructuredtext"
--- ./lib/taurus/core/util/report/report.py	(original)
+++ ./lib/taurus/core/util/report/report.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides a panel to display taurus messages"""
 
+from builtins import object
 __all__ = ["TaurusMessageReportHandler"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/external/qt/QtCore.py	(original)
+++ ./lib/taurus/external/qt/QtCore.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module exposes QtCore module"""
 
+from builtins import object
 from taurus.external.qt import API_NAME
 
 __backend = API_NAME
@@ -57,7 +58,7 @@
     if convfunc is None:
         return qobj.toPyObject()
     elif callable(convfunc):
-        if convfunc in (unicode, str):
+        if convfunc in (str, str):
             return convfunc(qobj.toString())
         elif convfunc is bool:
             return qobj.toBool()
@@ -65,7 +66,7 @@
             return qobj.toInt()[0]
         elif convfunc is float:
             return qobj.toDouble()[0]
-    elif isinstance(convfunc, (str, unicode)):
+    elif isinstance(convfunc, (str, str)):
         return getattr(qobj, convfunc)()
 
 
--- ./lib/taurus/external/qt/uic.py	(original)
+++ ./lib/taurus/external/qt/uic.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module exposes PyQt4/PSide uic module"""
 
+from builtins import object
 from taurus.core.util import log
 from taurus.external.qt import API_NAME
 
@@ -36,7 +37,7 @@
     from PyQt4.uic import properties
 
     # prevent ui parser from logging debug messages
-    class __IgnoreCalls:
+    class __IgnoreCalls(object):
         def __call__(self, *args, **kwargs):
             pass
 
@@ -54,7 +55,7 @@
     from PyQt5.uic import properties
 
     # prevent ui parser from logging debug messages
-    class __IgnoreCalls:
+    class __IgnoreCalls(object):
         def __call__(self, *args, **kwargs):
             pass
 
--- ./lib/taurus/qt/qtcore/communication/communication.py	(original)
+++ ./lib/taurus/qt/qtcore/communication/communication.py	(refactored)
@@ -328,7 +328,7 @@
 
         :returns: (list<str>) UIDs of currently shared data.
         '''
-        return self.__models.keys()
+        return list(self.__models.keys())
 
     def debugReader(self, data):
         '''
@@ -338,6 +338,6 @@
 
     def info(self):
         s = ""
-        for uid, m in sorted(self.__models.iteritems()):
+        for uid, m in sorted(self.__models.items()):
             s += m.info() + '\n'
         return s
--- ./lib/taurus/qt/qtcore/configuration/configuration.py	(original)
+++ ./lib/taurus/qt/qtcore/configuration/configuration.py	(refactored)
@@ -27,12 +27,17 @@
 configuration features to the classes that inherit from them"""
 from __future__ import print_function
 
+from future import standard_library
+standard_library.install_aliases()
+from builtins import str
+from past.builtins import basestring
+from builtins import object
 __all__ = ["configurableProperty", "BaseConfigurableClass"]
 
 __docformat__ = 'restructuredtext'
 
 
-class configurableProperty:
+class configurableProperty(object):
     '''A dummy class used to handle properties with the configuration API
 
     .. warning:: this class is intended for internal use by the configuration
@@ -66,7 +71,7 @@
         return self.name
 
 
-class BaseConfigurableClass:
+class BaseConfigurableClass(object):
     '''
     A base class defining the API for configurable objects.
 
@@ -191,7 +196,7 @@
         # store the configurations for all registered configurable items as
         # well
         itemcfgs = {}
-        for k, v in self.__configurableItems.iteritems():
+        for k, v in self.__configurableItems.items():
             itemcfgs[k] = v.createConfig(allowUnpickable=allowUnpickable)
         configdict["__itemConfigurations__"] = itemcfgs
         configdict["__orderedConfigNames__"] = self.__configurableItemNames
@@ -403,7 +408,7 @@
         .. seealso:: :meth:`restoreQConfig`
         '''
         from taurus.external.qt import Qt
-        import cPickle as pickle
+        import pickle as pickle
         configdict = self.createConfig(allowUnpickable=False)
         return Qt.QByteArray(pickle.dumps(configdict))
 
@@ -417,7 +422,7 @@
         '''
         if qstate.isNull():
             return
-        import cPickle as pickle
+        import pickle as pickle
         configdict = pickle.loads(qstate.data())
         self.applyConfig(configdict)
 
@@ -428,10 +433,10 @@
 
         :return: (str) file name used
         """
-        import cPickle as pickle
+        import pickle as pickle
         if ofile is None:
             from taurus.external.qt import Qt
-            ofile = unicode(Qt.QFileDialog.getSaveFileName(
+            ofile = str(Qt.QFileDialog.getSaveFileName(
                 self, 'Save Configuration', '%s.pck' % self.__class__.__name__, 'Configuration File (*.pck)'))
             if not ofile:
                 return
@@ -449,10 +454,10 @@
 
         :return: (str) file name used
         """
-        import cPickle as pickle
+        import pickle as pickle
         if ifile is None:
             from taurus.external.qt import Qt
-            ifile = unicode(Qt.QFileDialog.getOpenFileName(
+            ifile = str(Qt.QFileDialog.getOpenFileName(
                 self, 'Load Configuration', '', 'Configuration File (*.pck)'))
             if not ifile:
                 return
--- ./lib/taurus/qt/qtcore/model/taurusdatabasemodel.py	(original)
+++ ./lib/taurus/qt/qtcore/model/taurusdatabasemodel.py	(refactored)
@@ -26,6 +26,7 @@
 """This module provides widgets that display the database in a tree format"""
 # TODO: tango-centric
 
+from builtins import str
 __all__ = ["TaurusTreeDevicePartItem", "TaurusTreeDeviceDomainItem",
            "TaurusTreeDeviceFamilyItem", "TaurusTreeDeviceMemberItem", "TaurusTreeSimpleDeviceItem",
            "TaurusTreeDeviceItem", "TaurusTreeAttributeItem", "TaurusTreeServerNameItem",
@@ -266,7 +267,7 @@
             alarms="[%s, %s]" % (di.alarms.min_alarm, di.alarms.max_alarm),
             warnings="[%s, %s]" % (di.alarms.min_warning, di.alarms.max_warning),)
 
-        for id, value in items.items():
+        for id, value in list(items.items()):
             ret += '<TR><TD WIDTH="80" ALIGN="RIGHT" VALIGN="MIDDLE"><B>%s:</B></TD><TD>%s</TD></TR>' % (
                 id.capitalize(), value)
         ret += '</TABLE>'
@@ -553,15 +554,15 @@
             data = data.deviceTree()
 
         rootItem = self._rootItem
-        for domain in data.keys():
+        for domain in list(data.keys()):
             families = data[domain]
             domainItem = TaurusTreeDeviceDomainItem(
                 self, domain.upper(), rootItem)
-            for family in families.keys():
+            for family in list(families.keys()):
                 members = families[family]
                 familyItem = TaurusTreeDeviceFamilyItem(
                     self, family.upper(), domainItem)
-                for member in members.keys():
+                for member in list(members.keys()):
                     dev = members[member]
                     memberItem = TaurusTreeDeviceItem(
                         self, dev, parent=familyItem)
@@ -586,7 +587,7 @@
         servers = data.servers()
         rootItem = self._rootItem
 
-        for server_name, server in servers.items():
+        for server_name, server in list(servers.items()):
             serverInstanceItem = TaurusTreeFullServerItem(
                 self, server, rootItem)
             rootItem.appendChild(serverInstanceItem)
--- ./lib/taurus/qt/qtcore/model/taurusmodel.py	(original)
+++ ./lib/taurus/qt/qtcore/model/taurusmodel.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides base taurus tree item and a base tree model"""
 
+from builtins import object
 __all__ = ["TaurusBaseTreeItem", "TaurusBaseModel", "TaurusBaseProxyModel"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtcore/util/emitter.py	(original)
+++ ./lib/taurus/qt/qtcore/util/emitter.py	(refactored)
@@ -27,8 +27,17 @@
 emitter.py: This module provides a task scheduler used by TaurusGrid and 
     TaurusDevTree widgets
 """
-
-from Queue import Queue, Empty
+from __future__ import division
+
+from future import standard_library
+standard_library.install_aliases()
+from builtins import next
+from builtins import str
+from builtins import map
+from past.builtins import basestring
+from past.utils import old_div
+from builtins import object
+from queue import Queue, Empty
 import traceback
 from functools import partial
 from collections import Iterable
@@ -218,7 +227,7 @@
         self.emitter.doSomething.connect(self._doSomething)
 
         if not self.refreshTimer:
-            self.emitter.somethingDone.connect(self.next)
+            self.emitter.somethingDone.connect(self.__next__)
 
     def onRefresh(self):
         try:
@@ -242,7 +251,7 @@
     def getDone(self):
         """ Returns % of done tasks in 0-1 range """
         pending = self.getQueue().qsize()
-        return float(self._done) / (self._done + pending)
+        return old_div(float(self._done), (self._done + pending))
 
     def clear(self):
         while not self.todo.empty():
@@ -279,12 +288,12 @@
                 method(*args)
             except:
                 self.log.error('At TaurusEmitterThread._doSomething(%s): \n%s'
-                               % (map(str, args), traceback.format_exc()))
+                               % (list(map(str, args)), traceback.format_exc()))
         self.emitter.somethingDone.emit()
         self._done += 1
         return
 
-    def next(self):
+    def __next__(self):
         queue = self.getQueue()
         msg = ('At TaurusEmitterThread.next(), %d items remaining.'
                % queue.qsize())
@@ -376,7 +385,7 @@
         """Check all pending subscriptions in the current factory
         """
         attrs = []
-        items = self._factory.getExistingAttributes().items()
+        items = list(self._factory.getExistingAttributes().items())
         for name, attr in items:
             if attr is None:
                 continue
@@ -416,7 +425,7 @@
         Logger.cleanUp(self)
 
 
-class SingletonWorker():
+class SingletonWorker(object):
     """
     SingletonWorker is used to manage TaurusEmitterThread as Singleton objects
 
@@ -498,8 +507,8 @@
         return self.thread.getDone()
 
     def start(self):
-        self.thread.emitter.somethingDone.connect(self.next)
-        self.thread.emitter.newQueue.connect(self.thread.next)
+        self.thread.emitter.somethingDone.connect(self.__next__)
+        self.thread.emitter.newQueue.connect(self.thread.__next__)
         try:
             self.thread.start()
         except:
@@ -509,8 +518,8 @@
         return
 
     def stop(self):
-        self.thread.emitter.somethingDone.disconnect(self.next)
-        self.thread.emitter.newQueue.disconnect(self.thread.next)
+        self.thread.emitter.somethingDone.disconnect(self.__next__)
+        self.thread.emitter.newQueue.disconnect(self.thread.__next__)
         self._running = False
         return
 
--- ./lib/taurus/qt/qtcore/util/properties.py	(original)
+++ ./lib/taurus/qt/qtcore/util/properties.py	(refactored)
@@ -55,6 +55,8 @@
 
 """
 
+from builtins import str
+from builtins import map
 from functools import partial
 from taurus.external.qt import Qt
 from taurus.core.util.fandango_search import isSequence, isDictionary
@@ -81,7 +83,7 @@
     other, dct = sorted((a, b), key=isDictionary)
     if not isDictionary(other):
         other = dict.fromkeys(other if isSequence(other) else [other, ])
-    for k, v in other.items():
+    for k, v in list(other.items()):
         dct[k] = v if not k in dct else djoin(dct[k], v)
     return dct
 
--- ./lib/taurus/qt/qtcore/util/signal.py	(original)
+++ ./lib/taurus/qt/qtcore/util/signal.py	(refactored)
@@ -1,6 +1,7 @@
 """Provide a Signal class for non-QObject objects"""
 from __future__ import print_function
 
+from builtins import object
 __all__ = ['baseSignal']
 
 from PyQt4 import Qt
--- ./lib/taurus/qt/qtdesigner/taurusdesigner.py	(original)
+++ ./lib/taurus/qt/qtdesigner/taurusdesigner.py	(refactored)
@@ -23,6 +23,7 @@
 ##
 #############################################################################
 
+from builtins import str
 import sys
 import os.path
 import optparse
--- ./lib/taurus/qt/qtdesigner/tauruspluginplugin.py	(original)
+++ ./lib/taurus/qt/qtdesigner/tauruspluginplugin.py	(refactored)
@@ -119,7 +119,7 @@
 
     def customWidgets(self):
         if self._widgets is None:
-            self._widgets = [w(self) for w in _plugins.values()]
+            self._widgets = [w(self) for w in list(_plugins.values())]
         return self._widgets
 
 if __name__ != "__main__":
--- ./lib/taurus/qt/qtdesigner/taurusplugin/taurusplugin.py	(original)
+++ ./lib/taurus/qt/qtdesigner/taurusplugin/taurusplugin.py	(refactored)
@@ -38,6 +38,8 @@
 """
 from __future__ import print_function
 
+from builtins import str
+from builtins import zip
 import inspect
 
 from taurus.external.qt import Qt
@@ -86,8 +88,8 @@
         if aspec.defaults is None:
             kwspec = {}
         else:
-            kwspec = dict(zip(aspec.args[-len(aspec.defaults):],
-                              aspec.defaults))
+            kwspec = dict(list(zip(aspec.args[-len(aspec.defaults):],
+                              aspec.defaults)))
         args, kwargs = [], {}
         if 'designMode' in kwspec:
             kwargs['designMode'] = designMode
--- ./lib/taurus/qt/qtgui/application/taurusapplication.py	(original)
+++ ./lib/taurus/qt/qtgui/application/taurusapplication.py	(refactored)
@@ -26,6 +26,7 @@
 """This module provides the base
 :class:`taurus.qt.qtgui.application.TaurusApplication` class."""
 
+from builtins import str
 from __future__ import with_statement
 
 __all__ = ["TaurusApplication"]
--- ./lib/taurus/qt/qtgui/base/taurusbase.py	(original)
+++ ./lib/taurus/qt/qtgui/base/taurusbase.py	(refactored)
@@ -27,6 +27,8 @@
 """This module provides the set of base classes from which the Qt taurus widgets
 should inherit to be considered valid taurus widgets."""
 
+from builtins import str
+from past.builtins import basestring
 __all__ = ["TaurusBaseComponent", "TaurusBaseWidget",
            "TaurusBaseWritableWidget", "defaultFormatter"]
 
@@ -330,7 +332,7 @@
               but it can also be called any time the buffer needs to be flushed
         '''
         with self._eventsBufferLock:
-            for evt in self._bufferedEvents.values():
+            for evt in list(self._bufferedEvents.values()):
                 self.taurusEvent.emit(*evt)
             self._bufferedEvents = {}
 
--- ./lib/taurus/qt/qtgui/base/tauruscontroller.py	(original)
+++ ./lib/taurus/qt/qtgui/base/tauruscontroller.py	(refactored)
@@ -26,6 +26,8 @@
 
 """This module provides the set of base class taurus controllers."""
 
+from builtins import str
+from builtins import object
 __all__ = ["TaurusBaseController", "TaurusAttributeControllerHelper",
            "TaurusScalarAttributeControllerHelper",
            "TaurusConfigurationControllerHelper",
--- ./lib/taurus/qt/qtgui/button/taurusbutton.py	(original)
+++ ./lib/taurus/qt/qtgui/button/taurusbutton.py	(refactored)
@@ -27,6 +27,9 @@
 """This module provides a taurus QPushButton based widgets"""
 from __future__ import print_function
 
+from builtins import map
+from builtins import str
+from past.builtins import basestring
 __all__ = ["TaurusLauncherButton", "TaurusCommandButton", "TaurusLockButton"]
 
 __docformat__ = 'restructuredtext'
@@ -406,7 +409,7 @@
             else:
                 return parameters
         else:
-            return map(cast_type, parameters)
+            return list(map(cast_type, parameters))
 
     def setCommand(self, commandName):
         '''sets the command to be executed when the button is clicked
@@ -638,7 +641,7 @@
     if len(args) == 0:
         w = demo()
     else:
-        models = map(str.lower, args)
+        models = list(map(str.lower, args))
 
         w = Qt.QWidget()
         layout = Qt.QGridLayout()
--- ./lib/taurus/qt/qtgui/compact/abstractswitcher.py	(original)
+++ ./lib/taurus/qt/qtgui/compact/abstractswitcher.py	(refactored)
@@ -26,6 +26,7 @@
 """This module provides base classes from which the compact widgets should inherit
 """
 
+from past.builtins import basestring
 __all__ = ["TaurusReadWriteSwitcher"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtgui/container/qcontainer.py	(original)
+++ ./lib/taurus/qt/qtgui/container/qcontainer.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides basic pure Qt container widgets"""
 
+from builtins import str
 __all__ = ["QGroupWidget"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtgui/container/taurusframe.py	(original)
+++ ./lib/taurus/qt/qtgui/container/taurusframe.py	(refactored)
@@ -26,6 +26,7 @@
 """This module provides basic taurus container widgets"""
 from __future__ import absolute_import
 
+from builtins import map
 __all__ = ["TaurusFrame"]
 
 __docformat__ = 'restructuredtext'
@@ -150,7 +151,7 @@
     if len(args) == 0:
         w = demo()
     else:
-        models = map(str.lower, args)
+        models = list(map(str.lower, args))
 
         w = Qt.QWidget()
         w.setWindowTitle(app.applicationName())
--- ./lib/taurus/qt/qtgui/container/taurusgroupbox.py	(original)
+++ ./lib/taurus/qt/qtgui/container/taurusgroupbox.py	(refactored)
@@ -26,6 +26,8 @@
 """This module provides basic taurus group box widget"""
 from __future__ import absolute_import
 
+from builtins import map
+from builtins import str
 __all__ = ["TaurusGroupBox"]
 
 __docformat__ = 'restructuredtext'
@@ -195,7 +197,7 @@
     if len(args) == 0:
         w = demo()
     else:
-        models = map(str.lower, args)
+        models = list(map(str.lower, args))
 
         w = Qt.QWidget()
         w.setWindowTitle(app.applicationName())
--- ./lib/taurus/qt/qtgui/container/taurusgroupwidget.py	(original)
+++ ./lib/taurus/qt/qtgui/container/taurusgroupwidget.py	(refactored)
@@ -26,6 +26,7 @@
 """This module provides a taurus group widget"""
 from __future__ import absolute_import
 
+from builtins import map
 __all__ = ["TaurusGroupWidget"]
 
 __docformat__ = 'restructuredtext'
@@ -195,7 +196,7 @@
     if len(args) == 0:
         w = demo()
     else:
-        models = map(str.lower, args)
+        models = list(map(str.lower, args))
 
         w = Qt.QWidget()
         w.setWindowTitle(app.applicationName())
--- ./lib/taurus/qt/qtgui/container/taurusmainwindow.py	(original)
+++ ./lib/taurus/qt/qtgui/container/taurusmainwindow.py	(refactored)
@@ -28,6 +28,9 @@
 """
 from __future__ import absolute_import
 
+from builtins import str
+from builtins import range
+from past.builtins import basestring
 __all__ = ["TaurusMainWindow"]
 
 __docformat__ = 'restructuredtext'
@@ -91,7 +94,7 @@
             self.externalAppsPage.setWidgetResizable(True)
             self._tabwidget.addTab(self.externalAppsPage,
                                    "External Application Paths")
-        label = "Command line for %s" % unicode(extapp.text())
+        label = "Command line for %s" % str(extapp.text())
         editWidget = CommandArgsLineEdit(extapp, " ".join(extapp.cmdArgs()))
         #editWidget = Qt.QLineEdit(" ".join(extapp.cmdArgs()))
         self.externalAppsPage.widget().layout().addRow(label, editWidget)
@@ -106,12 +109,12 @@
         '''
         from taurus.external.qt import Qt
         layout = self.externalAppsPage.widget().layout()
-        for cnt in reversed(range(layout.count())):
+        for cnt in reversed(list(range(layout.count()))):
             widget = layout.itemAt(cnt).widget()
             if widget is not None:
                 text = str(widget.text())  # command1
                 if isinstance(widget, Qt.QLabel):
-                    dialog_text = "Command line for %s" % unicode(
+                    dialog_text = "Command line for %s" % str(
                         extapp.text())
                     if text == dialog_text:
                         layout.removeWidget(widget)
@@ -623,7 +626,7 @@
             self.applyQConfig(ba)
         except Exception as e:
             msg = 'Problem loading configuration from "%s". Some settings may not be restored.\n Details: %s' % (
-                unicode(settings.fileName()), repr(e))
+                str(settings.fileName()), repr(e))
             self.error(msg)
             Qt.QMessageBox.warning(
                 self, 'Error Loading settings', msg, Qt.QMessageBox.Ok)
@@ -681,7 +684,7 @@
             if not ok:
                 return
         if name in perspectives:
-            ans = Qt.QMessageBox.question(self, "Overwrite perspective?", "overwrite existing perspective %s?" % unicode(name),
+            ans = Qt.QMessageBox.question(self, "Overwrite perspective?", "overwrite existing perspective %s?" % str(name),
                                           Qt.QMessageBox.Yes, Qt.QMessageBox.No)
             if ans != Qt.QMessageBox.Yes:
                 return
@@ -759,16 +762,16 @@
         :param fname: (str) name of output file. If None given, a file dialog will be shown.
         '''
         if fname is None:
-            fname = unicode(Qt.QFileDialog.getSaveFileName(self, 'Choose file where the current settings should be saved',
+            fname = str(Qt.QFileDialog.getSaveFileName(self, 'Choose file where the current settings should be saved',
                                                            '', "Ini files (*.ini);;All files (*)"))
             if not fname:
                 return
         self.saveSettings()
         ok = Qt.QFile.copy(self.getQSettings().fileName(), fname)
         if ok:
-            self.info('MainWindow settings saved in "%s"' % unicode(fname))
+            self.info('MainWindow settings saved in "%s"' % str(fname))
         else:
-            msg = 'Settings could not be exported to %s' % unicode(fname)
+            msg = 'Settings could not be exported to %s' % str(fname)
             Qt.QMessageBox.warning(self, 'Export error', msg)
 
     def importSettingsFile(self, fname=None):
@@ -779,7 +782,7 @@
         :param fname: (str) name of ini file. If None given, a file dialog will be shown.
         '''
         if fname is None:
-            fname = unicode(Qt.QFileDialog.getOpenFileName(self, 'Select a ini-format settings file',
+            fname = str(Qt.QFileDialog.getOpenFileName(self, 'Select a ini-format settings file',
                                                            '', "Ini files (*.ini);;All files (*)"))
             if not fname:
                 return
@@ -935,8 +938,8 @@
         self.setHelpManualURI(uri)
 
     def showHelpAbout(self):
-        appname = unicode(Qt.qApp.applicationName())
-        appversion = unicode(Qt.qApp.applicationVersion())
+        appname = str(Qt.qApp.applicationName())
+        appversion = str(Qt.qApp.applicationVersion())
         from taurus.core import release
         abouttext = "%s %s\n\nUsing %s %s" % (
             appname, appversion, release.name, release.version)
@@ -961,7 +964,7 @@
         if key is None:
             from taurus.core.util.user import getSystemUserName
             username = getSystemUserName()
-            appname = unicode(Qt.QApplication.applicationName())
+            appname = str(Qt.QApplication.applicationName())
             key = "__socket_%s-%s__" % (username, appname)
         from taurus.external.qt import QtNetwork
         socket = QtNetwork.QLocalSocket(self)
--- ./lib/taurus/qt/qtgui/container/taurusscrollarea.py	(original)
+++ ./lib/taurus/qt/qtgui/container/taurusscrollarea.py	(refactored)
@@ -26,6 +26,7 @@
 """This module provides basic taurus scroll area widget"""
 from __future__ import absolute_import
 
+from builtins import map
 __all__ = ["TaurusScrollArea"]
 
 __docformat__ = 'restructuredtext'
@@ -173,7 +174,7 @@
     if len(args) == 0:
         w = demo()
     else:
-        models = map(str.lower, args)
+        models = list(map(str.lower, args))
 
         w = Qt.QWidget()
         w.setWindowTitle(app.applicationName())
--- ./lib/taurus/qt/qtgui/dialog/taurusmessagebox.py	(original)
+++ ./lib/taurus/qt/qtgui/dialog/taurusmessagebox.py	(refactored)
@@ -25,6 +25,9 @@
 
 """This module provides a set of dialog based widgets"""
 
+from future import standard_library
+standard_library.install_aliases()
+from builtins import object
 __all__ = ["TaurusMessageBox", "protectTaurusMessageBox",
            "ProtectTaurusMessageBox", "TaurusExceptHookMessageBox"]
 
@@ -337,8 +340,8 @@
     except PyTango.DevFailed as df1:
         try:
             import traceback
-            import StringIO
-            origin = StringIO.StringIO()
+            import io
+            origin = io.StringIO()
             traceback.print_stack(file=origin)
             origin.seek(0)
             origin = origin.read()
--- ./lib/taurus/qt/qtgui/display/qled.py	(original)
+++ ./lib/taurus/qt/qtgui/display/qled.py	(refactored)
@@ -25,6 +25,7 @@
 
 """A pure Qt led widget"""
 
+from builtins import str
 __all__ = ["LedColor", "LedStatus", "LedSize", "QLed", "QLedOld"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtgui/display/qpixmapwidget.py	(original)
+++ ./lib/taurus/qt/qtgui/display/qpixmapwidget.py	(refactored)
@@ -25,7 +25,9 @@
 
 """This module contains a pure Qt widget that displays an image"""
 from __future__ import absolute_import
-
+from __future__ import division
+
+from past.utils import old_div
 __all__ = ["QPixmapWidget"]
 
 __docformat__ = 'restructuredtext'
@@ -80,11 +82,11 @@
         vAlign = align & Qt.Qt.AlignVertical_Mask
         x, y = 0, 0
         if hAlign & Qt.Qt.AlignHCenter:
-            x = (w - pw) / 2
+            x = old_div((w - pw), 2)
         elif hAlign & Qt.Qt.AlignRight:
             x = w - pw
         if vAlign & Qt.Qt.AlignVCenter:
-            y = (h - ph) / 2
+            y = old_div((h - ph), 2)
         elif vAlign & Qt.Qt.AlignBottom:
             y = h - ph
         x, y = max(0, x), max(0, y)
--- ./lib/taurus/qt/qtgui/display/qsevensegment.py	(original)
+++ ./lib/taurus/qt/qtgui/display/qsevensegment.py	(refactored)
@@ -27,7 +27,11 @@
 qsevensegmentdisplay.py
 """
 from __future__ import print_function
-
+from __future__ import division
+
+from builtins import str
+from builtins import range
+from past.utils import old_div
 __all__ = ['Q7SegDigit']
 
 __docformat__ = 'restructuredtext'
@@ -134,7 +138,7 @@
 
     DftWidth = 300
     DftHeight = 300
-    DftAspectRatio = DftWidth / DftHeight
+    DftAspectRatio = old_div(DftWidth, DftHeight)
     DftUseFrame = True
 
     def __init__(self, parent=None, **kwargs):
@@ -202,11 +206,11 @@
         painter.setRenderHint(Qt.QPainter.Antialiasing)
         painter.setWindow(0, 0, self.DftWidth, self.DftHeight)
         w, h = float(self.width()), float(self.height())
-        aspect = w / h
+        aspect = old_div(w, h)
         if aspect > 0.75:
             w = h * aspect
         else:
-            h = w / aspect
+            h = old_div(w, aspect)
         painter.setViewport(0, 0, w, h)
         self._paintBorder(painter)
         self._paintSegment(painter)
@@ -248,7 +252,7 @@
 
         pens, brushes = self._pens[idx], self._brushes[idx]
 
-        for i in xrange(7):
+        for i in range(7):
             seg = Qt.QPainterPath()
             seg.addPolygon(geom[i])
             painter.setPen(pens[i])
@@ -506,7 +510,7 @@
         self.setLayout(l)
 
         self._digits = []
-        for i in xrange(5):
+        for i in range(5):
             d = Q7SegDigit()
             d.setUseFrame(False)
             d.setValue(i)
--- ./lib/taurus/qt/qtgui/display/tauruslabel.py	(original)
+++ ./lib/taurus/qt/qtgui/display/tauruslabel.py	(refactored)
@@ -26,6 +26,8 @@
 """This module provides a set of basic Taurus widgets based on QLabel"""
 from __future__ import absolute_import
 
+from builtins import str
+from builtins import object
 __all__ = ["TaurusLabel"]
 
 __docformat__ = 'restructuredtext'
@@ -116,8 +118,8 @@
         toolTip = label.getFormatedToolTip()
         if self._trimmedText:
             toolTip = u"<p><b>Value:</b> %s</p><hr>%s" %\
-                      (unicode(self._text, errors='replace'),
-                       unicode(str(toolTip), errors='replace'))
+                      (str(self._text, errors='replace'),
+                       str(str(toolTip), errors='replace'))
         label.setToolTip(toolTip)
 
     _updateBackground = updateLabelBackground
--- ./lib/taurus/qt/qtgui/display/tauruslcd.py	(original)
+++ ./lib/taurus/qt/qtgui/display/tauruslcd.py	(refactored)
@@ -26,6 +26,9 @@
 """This module provides a Taurus widget based on QLCDNumber"""
 from __future__ import absolute_import
 
+from builtins import map
+from builtins import str
+from builtins import object
 __all__ = ["TaurusLCD"]
 
 __docformat__ = 'restructuredtext'
@@ -413,7 +416,7 @@
     if len(args) == 0:
         w = demo()
     else:
-        models = map(str.lower, args)
+        models = list(map(str.lower, args))
 
         w = Qt.QWidget()
         layout = Qt.QGridLayout()
--- ./lib/taurus/qt/qtgui/display/taurusled.py	(original)
+++ ./lib/taurus/qt/qtgui/display/taurusled.py	(refactored)
@@ -27,6 +27,9 @@
 """This module provides a set of basic Taurus widgets based on QLed"""
 from __future__ import absolute_import
 
+from builtins import map
+from builtins import str
+from builtins import object
 __all__ = ["TaurusLed"]
 
 __docformat__ = 'restructuredtext'
@@ -478,7 +481,7 @@
     if len(args) == 0:
         w = demo()
     else:
-        models = map(str.lower, args)
+        models = list(map(str.lower, args))
 
         w = Qt.QWidget()
         layout = Qt.QGridLayout()
--- ./lib/taurus/qt/qtgui/display/test/test_tauruslabel.py	(original)
+++ ./lib/taurus/qt/qtgui/display/test/test_tauruslabel.py	(refactored)
@@ -25,6 +25,7 @@
 
 """Unit tests for Taurus Label"""
 
+from builtins import str
 import unittest
 from taurus.external.qt import Qt
 from taurus.test import insertTest
--- ./lib/taurus/qt/qtgui/editor/tauruseditor.py	(original)
+++ ./lib/taurus/qt/qtgui/editor/tauruseditor.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module contains a taurus text editor widget."""
 
+from builtins import str
 __all__ = ["TaurusBaseEditor"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtgui/extra_guiqwt/curve.py	(original)
+++ ./lib/taurus/qt/qtgui/extra_guiqwt/curve.py	(refactored)
@@ -26,6 +26,7 @@
 """Extension of :mod:`guiqwt.curve`"""
 from __future__ import print_function
 
+from builtins import next
 __all__ = ["TaurusCurveItem"]
 
 from taurus.external.qt import Qt
--- ./lib/taurus/qt/qtgui/extra_guiqwt/curvesmodel.py	(original)
+++ ./lib/taurus/qt/qtgui/extra_guiqwt/curvesmodel.py	(refactored)
@@ -27,6 +27,11 @@
 curvesmodel Model and view for new CurveItem configuration
 """
 from __future__ import print_function
+from builtins import map
+from builtins import next
+from builtins import str
+from builtins import range
+from builtins import object
 __all__ = ['TaurusCurveItemTableModel', 'CurveItemConf', 'CurveItemConfDlg']
 #raise UnimplementedError('Under Construction!')
 
@@ -43,7 +48,7 @@
 from taurus.qt.qtgui.extra_guiqwt.styles import TaurusCurveParam
 
 import guiqwt
-__guiqwt_version = map(int, guiqwt.__version__.split('.')[:3])
+__guiqwt_version = list(map(int, guiqwt.__version__.split('.')[:3]))
 if __guiqwt_version <= [2, 3, 1]:
     import taurus.external.qt.Qwt5 as qwt
 else:
@@ -55,7 +60,7 @@
 # set some named constants
 # columns:
 NUMCOLS = 3
-X, Y, TITLE = range(NUMCOLS)
+X, Y, TITLE = list(range(NUMCOLS))
 SRC_ROLE = Qt.Qt.UserRole + 1
 
 
--- ./lib/taurus/qt/qtgui/extra_guiqwt/plot.py	(original)
+++ ./lib/taurus/qt/qtgui/extra_guiqwt/plot.py	(refactored)
@@ -26,6 +26,9 @@
 """
 Extension of :mod:`guiqwt.plot`
 """
+from builtins import next
+from builtins import str
+from past.builtins import basestring
 __all__ = ["TaurusCurveDialog", "TaurusTrendDialog", "TaurusImageDialog"]
 
 import copy
--- ./lib/taurus/qt/qtgui/extra_guiqwt/scales.py	(original)
+++ ./lib/taurus/qt/qtgui/extra_guiqwt/scales.py	(refactored)
@@ -27,6 +27,11 @@
 scales.py: Custom scales used by taurus.qt.qtgui.plot module
 """
 from __future__ import print_function
+from __future__ import division
+from builtins import map
+from builtins import str
+from builtins import range
+from past.utils import old_div
 __all__ = ["DateTimeScaleEngine", "DeltaTimeScaleEngine", "FixedLabelsScaleEngine",
            "FancyScaleDraw", "TaurusTimeScaleDraw", "DeltaTimeScaleDraw",
            "FixedLabelsScaleDraw"]
@@ -37,7 +42,7 @@
 from taurus.external.qt import Qt
 
 import guiqwt
-__guiqwt_version = map(int, guiqwt.__version__.split('.')[:3])
+__guiqwt_version = list(map(int, guiqwt.__version__.split('.')[:3]))
 
 if __guiqwt_version <= [2, 3, 1]:
     import taurus.external.qt.Qwt5 as qwt
@@ -226,7 +231,7 @@
 
         elif dx > 2:  # 2s
             format = "%H:%M:%S"
-            majticks = range(int(x1) + 1, int(x2))
+            majticks = list(range(int(x1) + 1, int(x2)))
 
         else:  # less than 2s (show microseconds)
             scaleDiv = qwt.QwtLinearScaleEngine.divideScale(
@@ -237,7 +242,7 @@
         # make sure to comply with maxMajTicks
         L = len(majticks)
         if L > maxMajSteps:
-            majticks = majticks[::int(numpy.ceil(float(L) / maxMajSteps))]
+            majticks = majticks[::int(numpy.ceil(old_div(float(L), maxMajSteps)))]
 
         scaleDiv = qwt.QwtScaleDiv(interval, minticks, medticks, majticks)
         self.scaleDraw().setDatetimeLabelFormat(format)
@@ -370,7 +375,7 @@
             s = 86400  # 1 day
         # calculate a step size that respects the base step (s) and also
         # enforces the maxMajSteps
-        stepSize = s * int(numpy.ceil(float(d_range // s) / maxMajSteps))
+        stepSize = s * int(numpy.ceil(old_div(float(d_range // s), maxMajSteps)))
         return qwt.QwtLinearScaleEngine.divideScale(self, x1, x2, maxMajSteps, maxMinSteps, stepSize)
 
     @staticmethod
--- ./lib/taurus/qt/qtgui/extra_guiqwt/taurustrend2d.py	(original)
+++ ./lib/taurus/qt/qtgui/extra_guiqwt/taurustrend2d.py	(refactored)
@@ -26,6 +26,7 @@
 """
 taurustrend.py: Generic trend widget for Taurus
 """
+from builtins import str
 __all__ = ["TaurusTrend2DDialog"]
 
 from guiqwt.plot import ImageDialog
--- ./lib/taurus/qt/qtgui/extra_guiqwt/tools.py	(original)
+++ ./lib/taurus/qt/qtgui/extra_guiqwt/tools.py	(refactored)
@@ -26,6 +26,7 @@
 """Extension of :mod:`guiqwt.tools`"""
 
 
+from builtins import zip
 __docformat__ = 'restructuredtext'
 
 import weakref
@@ -173,7 +174,7 @@
 
     def update_status(self, plot):
         active_scale = self._getAxesUseTime(plot)
-        for scale_type, scale_action in self.scale_menu.items():
+        for scale_type, scale_action in list(self.scale_menu.items()):
             scale_action.setEnabled(True)
             if active_scale == scale_type:
                 scale_action.setChecked(True)
--- ./lib/taurus/qt/qtgui/extra_nexus/taurusnexuswidget.py	(original)
+++ ./lib/taurus/qt/qtgui/extra_nexus/taurusnexuswidget.py	(refactored)
@@ -27,6 +27,7 @@
 nexusWidget.py:
 """
 
+from builtins import str
 __all__ = ["TaurusNexusBrowser"]
 
 import numpy
@@ -111,7 +112,7 @@
 
     def openFile(self, fname=None):
         if fname is None:
-            fname = unicode(Qt.QFileDialog.getOpenFileName(
+            fname = str(Qt.QFileDialog.getOpenFileName(
                 self, "Choose NeXus File", "/home/cpascual/local/tmp/scantest.h5"))  # @TODO!!
         if fname:
             self.__nexusFile = self.__fileModel.openFile(fname)
--- ./lib/taurus/qt/qtgui/graphic/taurusgraphic.py	(original)
+++ ./lib/taurus/qt/qtgui/graphic/taurusgraphic.py	(refactored)
@@ -26,9 +26,17 @@
 taurusgraphic.py:
 """
 from __future__ import print_function
+from __future__ import division
 
 # TODO: Tango-centric
 
+from future import standard_library
+standard_library.install_aliases()
+from builtins import str
+from builtins import range
+from past.builtins import basestring
+from builtins import object
+from past.utils import old_div
 __all__ = ['SynopticSelectionStyle',
            'parseTangoUri',
            'QEmitter',  # TODO: QEmitter should probably be removed (kept priv)
@@ -64,7 +72,7 @@
 import operator
 import types
 
-import Queue
+import queue
 
 from taurus import Manager
 from taurus.core import AttrQuality, DataType
@@ -373,7 +381,7 @@
         if not target.endswith('$'):
             target += '$'
         result = []
-        for k in self._itemnames.keys():
+        for k in list(self._itemnames.keys()):
             if re.match(target.lower(), k.lower()):
                 #self.debug('getItemByName(%s): _itemnames[%s]: %s'%(target,k,self._itemnames[k]))
                 result.extend(self._itemnames[k])
@@ -383,7 +391,7 @@
         """ This method will try first with named objects; if failed then with itemAt """
         pos = Qt.QPointF(x, y)
         itemsAtPos = []
-        for z, o in sorted((i.zValue(), i) for v in self._itemnames.values() for i in v if i.contains(pos) or i.isUnderMouse()):
+        for z, o in sorted((i.zValue(), i) for v in list(self._itemnames.values()) for i in v if i.contains(pos) or i.isUnderMouse()):
             if not hasattr(o, 'getExtensions'):
                 self.debug(
                     'getItemByPosition(%d,%d): adding Qt primitive %s' % (x, y, o))
@@ -685,7 +693,7 @@
                     SelectionMark = picture
                     SelectionMark.setRect(0, 0, w, h)
                     SelectionMark.hide()
-                elif operator.isCallable(picture):
+                elif hasattr(picture, '__call__'):
                     SelectionMark = picture()
                 else:
                     if isinstance(picture, Qt.QPixmap):
@@ -734,8 +742,8 @@
                 if w > MAX_CIRCLE_SIZE[0] or h > MAX_CIRCLE_SIZE[1]:
                     # Applying correction if the file is too big, half max
                     # circle size around the center
-                    x, y = (x + w / 2.) - .5 * \
-                        MAX_CIRCLE_SIZE[0], (y + h / 2.) - .5 * \
+                    x, y = (x + old_div(w, 2.)) - .5 * \
+                        MAX_CIRCLE_SIZE[0], (y + old_div(h, 2.)) - .5 * \
                         MAX_CIRCLE_SIZE[1],
                     w, h = [.5 * t for t in MAX_CIRCLE_SIZE]
                 else:
@@ -831,7 +839,7 @@
     def start(self):
         if self.updateThread:
             return
-        self.updateQueue = Queue.Queue()
+        self.updateQueue = queue.Queue()
         self.updateThread = TaurusGraphicsUpdateThread(self)
         self.updateThread.start()  # Qt.QThread.HighPriority)
 
@@ -985,7 +993,7 @@
             path.lineTo(cp[1])
         else:
             path.moveTo(cp[0])
-            for i in xrange(1, nb_points - 1, 3):
+            for i in range(1, nb_points - 1, 3):
                 p1 = cp[i + 0]
                 p2 = cp[i + 1]
                 end = cp[i + 2]
@@ -1438,7 +1446,7 @@
 }
 
 
-class TaurusBaseGraphicsFactory:
+class TaurusBaseGraphicsFactory(object):
 
     def __init__(self):
         pass
@@ -1506,7 +1514,7 @@
     def getGraphicsItem(self, type_, params):
         name = params.get(self.getNameParam())
         # applying alias
-        for k, v in getattr(self, 'alias', {}).items():
+        for k, v in list(getattr(self, 'alias', {}).items()):
             if k in name:
                 name = str(name).replace(k, v)
                 params[self.getNameParam()] = name
--- ./lib/taurus/qt/qtgui/graphic/jdraw/jdraw.py	(original)
+++ ./lib/taurus/qt/qtgui/graphic/jdraw/jdraw.py	(refactored)
@@ -26,6 +26,8 @@
 """This module contains the graphics factory for the jdraw file format"""
 from __future__ import absolute_import
 
+from builtins import str
+from builtins import range
 __all__ = ["TaurusJDrawGraphicsFactory"]
 
 __docformat__ = 'restructuredtext'
@@ -181,7 +183,7 @@
 
         polygon = Qt.QPolygonF()
         p = params.get('summit')
-        for i in xrange(0, len(p), 2):
+        for i in range(0, len(p), 2):
             polygon.append(Qt.QPointF(p[i], p[i + 1]))
         item.setPolygon(polygon)
 
@@ -190,7 +192,7 @@
     def getSplineObj(self, params):
         item = self.getGraphicsItem('Spline', params)
         p = params.get('summit')
-        p = [Qt.QPointF(p[i], p[i + 1]) for i in xrange(0, len(p), 2)]
+        p = [Qt.QPointF(p[i], p[i + 1]) for i in range(0, len(p), 2)]
         item.setControlPoints(p)
         isClosed = params.get('isClosed', True)
         item.setClose(isClosed)
@@ -213,8 +215,8 @@
         # it is parsed as a float
         vAlignment = int(params.get('vAlignment', 0))
         hAlignment = int(params.get('hAlignment', 0))
-        assert(vAlignment in VALIGNMENT.keys())
-        assert(hAlignment in ALIGNMENT.keys())
+        assert(vAlignment in list(VALIGNMENT.keys()))
+        assert(hAlignment in list(ALIGNMENT.keys()))
         vAlignment = VALIGNMENT[vAlignment]
         hAlignment = ALIGNMENT[hAlignment]
         item.setAlignment(hAlignment | vAlignment)
@@ -332,7 +334,7 @@
             params.get('extensions')["ignoreRepaint"] = "true"
 
         if self.alias:
-            for k, v in self.alias.items():
+            for k, v in list(self.alias.items()):
                 name = str(name).replace(k, v)
 
         # Forcing not-Taurus items to have a name and be able to trigger events
--- ./lib/taurus/qt/qtgui/graphic/jdraw/jdraw_parser.py	(original)
+++ ./lib/taurus/qt/qtgui/graphic/jdraw/jdraw_parser.py	(refactored)
@@ -27,6 +27,7 @@
 
 from __future__ import absolute_import
 
+from builtins import str
 __all__ = ["new_parser", "parse"]
 
 import os
--- ./lib/taurus/qt/qtgui/graphic/jdraw/jdraw_view.py	(original)
+++ ./lib/taurus/qt/qtgui/graphic/jdraw/jdraw_view.py	(refactored)
@@ -26,6 +26,8 @@
 """This module contains the graphics view widget for jdraw files"""
 from __future__ import absolute_import
 
+from builtins import str
+from past.builtins import basestring
 __all__ = ["TaurusJDrawSynopticsView"]
 
 __docformat__ = 'restructuredtext'
@@ -121,7 +123,7 @@
         self.emitColors()
 
     def openJDraw(self):
-        ifile = unicode(Qt.QFileDialog.getOpenFileName(
+        ifile = str(Qt.QFileDialog.getOpenFileName(
             self, 'Load JDraw File', '', 'JDraw File (*.jdw)'))
         if not ifile:
             return
@@ -139,7 +141,7 @@
         return
 
     def get_item_list(self):
-        return [item._name for item in self.scene().items() if hasattr(item, '_name') and item._name]
+        return [item._name for item in list(self.scene().items()) if hasattr(item, '_name') and item._name]
 
     def get_device_list(self):
         items = [(item, parseTangoUri(item)) for item in self.get_item_list()]
@@ -148,7 +150,7 @@
     def get_item_colors(self, emit=False):
         item_colors = {}
         try:
-            for item in self.scene().items():
+            for item in list(self.scene().items()):
                 if not getattr(item, '_name', '') or not getattr(item, '_currBgBrush', None):
                     continue
                 item_colors[item._name] = item._currBgBrush.color().name()
@@ -421,7 +423,7 @@
 
     def setModels(self):
         """ This method triggers item.setModel(item._name) in all internal items. """
-        for item in self.scene().items():
+        for item in list(self.scene().items()):
             if item._name and isinstance(item, TaurusGraphicsItem):
                 self.debug(
                     'TaurusJDrawGraphicsFactory.setModels(): calling item.setModel(%s)' % (item._name))
--- ./lib/taurus/qt/qtgui/help/assistant.py	(original)
+++ ./lib/taurus/qt/qtgui/help/assistant.py	(refactored)
@@ -39,13 +39,15 @@
     app.exec_()
 """
 
+from builtins import str
+from builtins import object
 __all__ = ["Assistant", "Widgets"]
 
 
 from taurus.external.qt import Qt
 
 
-class Widgets:
+class Widgets(object):
     contents = "contents"
     index = "index"
     bookmarks = "bookmarks"
--- ./lib/taurus/qt/qtgui/icon/catalog.py	(original)
+++ ./lib/taurus/qt/qtgui/icon/catalog.py	(refactored)
@@ -78,7 +78,7 @@
         pixmaps = {}
         choices = []
         row = []
-        for md5, choice in hashes.items():
+        for md5, choice in list(hashes.items()):
             try:
                 pixmaps[choice] = pixmaps_hashed[md5]
             except KeyError:
--- ./lib/taurus/qt/qtgui/icon/icon.py	(original)
+++ ./lib/taurus/qt/qtgui/icon/icon.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides taurus-specific functions related to icons"""
 
+from builtins import range
 __all__ = [
     'sanitizePrefix',
     'registerPathFiles',
@@ -68,7 +69,7 @@
 __3DQS = Qt.QSize(3 * __DW, __DH)
 
 # Indexes for the map below
-__IDX_ELEM_TYPE_ICON, __IDX_ELEM_TYPE_SIZE, __IDX_ELEM_TYPE_TOOLTIP = range(3)
+__IDX_ELEM_TYPE_ICON, __IDX_ELEM_TYPE_SIZE, __IDX_ELEM_TYPE_TOOLTIP = list(range(3))
 
 # New default role map
 # Elements are: icon theme, preferred size, description/tooltip
@@ -102,7 +103,7 @@
 }
 
 # Indexes for the map below
-__IDX_STATE_ICON, __IDX_STATE_TOOLTIP = range(2)
+__IDX_STATE_ICON, __IDX_STATE_TOOLTIP = list(range(2))
 
 _STATE_MAP = {
     TaurusDevState.Ready: ("status:available.svg", "Element ready"),
--- ./lib/taurus/qt/qtgui/input/choicedlg.py	(original)
+++ ./lib/taurus/qt/qtgui/input/choicedlg.py	(refactored)
@@ -26,6 +26,7 @@
 """This package provides a dialog for graphically choosing a Taurus class"""
 from __future__ import print_function
 
+from builtins import str
 __all__ = ["GraphicalChoiceDlg", "GraphicalChoiceWidget"]
 
 __docformat__ = 'restructuredtext'
@@ -196,7 +197,7 @@
 
     def onClick(self):
         '''slot called when a button is clicked'''
-        self._chosen = unicode(self.sender().text())
+        self._chosen = str(self.sender().text())
         self.choiceMade.emit(self._chosen)
 
     def getChosen(self):
--- ./lib/taurus/qt/qtgui/input/qwheel.py	(original)
+++ ./lib/taurus/qt/qtgui/input/qwheel.py	(refactored)
@@ -24,7 +24,11 @@
 #############################################################################
 
 """This module provides an arrow based widget."""
-
+from __future__ import division
+
+from builtins import map
+from builtins import range
+from past.utils import old_div
 __all__ = ["QWheelEdit"]
 
 __docformat__ = 'restructuredtext'
@@ -96,7 +100,7 @@
 class _DigitLabel(Qt.QLabel):
     """A private single digit label to be used by QWheelEdit widget"""
 
-    PixmapKeys = map(str, xrange(10)) + ['blank', 'minus', 'point']
+    PixmapKeys = list(map(str, range(10))) + ['blank', 'minus', 'point']
 
     def __init__(self, lbl, parent=None):
         Qt.QLabel.__init__(self, parent)
@@ -223,7 +227,7 @@
         @return (float) the minimum possible value
         """
         decmax = 0
-        for i in xrange(self.getDecDigitCount()):
+        for i in range(self.getDecDigitCount()):
             decmax += 9 * math.pow(10, -(i + 1))
         return -math.pow(10.0, self.getIntDigitCount()) + 1 - decmax
 
@@ -236,7 +240,7 @@
         @return (float) the maximum possible value
         """
         decmax = 0
-        for i in xrange(self.getDecDigitCount()):
+        for i in range(self.getDecDigitCount()):
             decmax += 9 * math.pow(10, -(i + 1))
         return math.pow(10.0, self.getIntDigitCount()) - 1 + decmax
 
@@ -270,7 +274,7 @@
         l.setColumnMinimumWidth(0, _ArrowButton.ButtonSize)
         l.setColumnStretch(0, 1)
 
-        for i in xrange(id):
+        for i in range(id):
             col = i + 1
             d = _DigitLabel('0')
             up = _UpArrowButton(id - i - 1)
@@ -293,7 +297,7 @@
             self._digitLabels.append(dotLabel)
             l.addWidget(dotLabel, 1, id + 1)
 
-        for i in xrange(id, digits):
+        for i in range(id, digits):
             col = i + 1
             if showDot:
                 col += 1
@@ -442,7 +446,7 @@
         if len(v_str) > len(self._digitLabels):
             # do auto adjust
             if '.' in v_str:
-                dc = map(len, v_str.split('.'))
+                dc = list(map(len, v_str.split('.')))
             else:
                 dc = len(v_str), 0
             self._setDigits(*dc)
@@ -767,8 +771,8 @@
         self.setFocus()
 
     def wheelEvent(self, evt):
-        numDegrees = evt.delta() / 8
-        numSteps = numDegrees / 15
+        numDegrees = old_div(evt.delta(), 8)
+        numSteps = old_div(numDegrees, 15)
         #w = Qt.QApplication.focusWidget()
         w = self.focusWidget()
         if not isinstance(w, _DigitLabel):
--- ./lib/taurus/qt/qtgui/input/tauruscheckbox.py	(original)
+++ ./lib/taurus/qt/qtgui/input/tauruscheckbox.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides a set of basic taurus widgets based on QCheckBox"""
 
+from builtins import str
 __all__ = ["TaurusValueCheckBox"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtgui/input/tauruscombobox.py	(original)
+++ ./lib/taurus/qt/qtgui/input/tauruscombobox.py	(refactored)
@@ -26,6 +26,7 @@
 
 """This module provides a set of basic taurus widgets based on QCheckBox"""
 
+from builtins import str
 __all__ = ["TaurusAttrListComboBox", "TaurusValueComboBox"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtgui/input/tauruslineedit.py	(original)
+++ ./lib/taurus/qt/qtgui/input/tauruslineedit.py	(refactored)
@@ -26,7 +26,11 @@
 """
 This module provides a set of basic taurus widgets based on QLineEdit
 """
-
+from __future__ import division
+
+from builtins import bytes
+from builtins import str
+from past.utils import old_div
 import sys
 import numpy
 from taurus.external.qt import Qt
@@ -176,8 +180,8 @@
             return Qt.QLineEdit.wheelEvent(self, evt)
 
         evt.accept()
-        numDegrees = evt.delta() / 8
-        numSteps = numDegrees / 15
+        numDegrees = old_div(evt.delta(), 8)
+        numSteps = old_div(numDegrees, 15)
         self._stepBy(numSteps)
 
     def keyPressEvent(self, evt):
--- ./lib/taurus/qt/qtgui/input/taurusspinbox.py	(original)
+++ ./lib/taurus/qt/qtgui/input/taurusspinbox.py	(refactored)
@@ -28,6 +28,7 @@
 """
 from __future__ import absolute_import
 
+from builtins import str
 from taurus.external.qt import Qt
 
 from .tauruslineedit import TaurusValueLineEdit
--- ./lib/taurus/qt/qtgui/model/qbasemodel.py	(original)
+++ ./lib/taurus/qt/qtgui/model/qbasemodel.py	(refactored)
@@ -236,7 +236,7 @@
         menu = Qt.QMenu("Perspective", b)
         b.setMenu(menu)
         af = ActionFactory()
-        for persp, persp_data in view.KnownPerspectives.items():
+        for persp, persp_data in list(view.KnownPerspectives.items()):
             label = persp_data["label"]
             icon = Qt.QIcon.fromTheme(persp_data["icon"])
             tip = persp_data["tooltip"]
--- ./lib/taurus/qt/qtgui/panel/qdataexportdialog.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/qdataexportdialog.py	(refactored)
@@ -27,6 +27,9 @@
 one or more curves"""
 from __future__ import print_function
 
+from builtins import zip
+from builtins import str
+from builtins import range
 __all__ = ["QDataExportDialog"]
 
 import os.path
@@ -76,7 +79,7 @@
         self.datadict = datadict
         self.dataSetCB.clear()
         self.dataSetCB.insertItems(0, sortedNames)
-        if len(self.datadict.keys()) > 1:
+        if len(list(self.datadict.keys())) > 1:
             self.dataSetCB.insertItems(
                 0, [self.allInSingleFile, self.allInMultipleFiles])
 
@@ -152,7 +155,7 @@
             if not outputdir:
                 return False
             preffix = os.path.join(str(outputdir), "set")
-        for i, k in zip(range(len(self.datadict)), self.sortedNames):
+        for i, k in zip(list(range(len(self.datadict))), self.sortedNames):
             ofile = "%s%03i.dat" % (preffix, i + 1)
             try:
                 self.exportCurrentData(
--- ./lib/taurus/qt/qtgui/panel/qdoublelist.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/qdoublelist.py	(refactored)
@@ -30,6 +30,8 @@
 """
 from __future__ import print_function
 
+from builtins import str
+from builtins import range
 __all__ = ["QDoubleListDlg"]
 
 __docformat__ = 'restructuredtext'
@@ -102,14 +104,14 @@
 
         :return: (list<str>)
         '''
-        return [unicode(self.ui.list1.item(row).text()) for row in xrange(self.ui.list1.count())]
+        return [str(self.ui.list1.item(row).text()) for row in range(self.ui.list1.count())]
 
     def getAll2(self):
         '''returns a copy the items in the second list
 
         :return: (list<str>)
         '''
-        return [unicode(self.ui.list2.item(row).text()) for row in xrange(self.ui.list2.count())]
+        return [str(self.ui.list2.item(row).text()) for row in range(self.ui.list2.count())]
 
     # note, for the moment we do not make it available in designer because it does not
     # behave well as a widget (only as a dialog) (e.g., it closes if ESC is pressed
--- ./lib/taurus/qt/qtgui/panel/qrawdatachooser.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/qrawdatachooser.py	(refactored)
@@ -27,6 +27,7 @@
 RawDataChooser.py:  widget for importing RawData (from file or from a function)
 """
 
+from builtins import str
 __all__ = ["QRawDataWidget"]
 
 import numpy
--- ./lib/taurus/qt/qtgui/panel/taurusconfigeditor.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusconfigeditor.py	(refactored)
@@ -27,12 +27,15 @@
 taurusconfigeditor.py:
 """
 
+from future import standard_library
+standard_library.install_aliases()
+from builtins import str
 __all__ = ["QConfigEditor"]
 
 __docformat__ = 'restructuredtext'
 
 from taurus.external.qt import Qt
-import cPickle as pickle
+import pickle as pickle
 import os
 import tempfile
 from taurus.qt.qtcore.configuration import BaseConfigurableClass
@@ -77,9 +80,9 @@
 
         :param iniFileName: (str)
         '''
-        self.originalFile = unicode(iniFileName)
+        self.originalFile = str(iniFileName)
         self._file = tempfile.NamedTemporaryFile()
-        self._temporaryFile = unicode(self._file.name)
+        self._temporaryFile = str(self._file.name)
 
         shutil.copyfile(self.originalFile, self._temporaryFile)
 
--- ./lib/taurus/qt/qtgui/panel/taurusconfigurationpanel.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusconfigurationpanel.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides a set of basic taurus widgets based on QLineEdit"""
 
+from builtins import str
 __all__ = ["TaurusConfigurationPanel", "TangoConfigLineEdit",
            "TaurusConfigLineEdit"]
 
--- ./lib/taurus/qt/qtgui/panel/taurusdemo.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusdemo.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 from __future__ import print_function
+from builtins import str
 import sys
 import operator
 
@@ -55,12 +56,12 @@
                 continue
             internal_widget_module = sys.modules[internal_widget_module_name]
             if hasattr(internal_widget_module, "demo"):
-                if operator.isCallable(internal_widget_module.demo):
+                if hasattr(internal_widget_module.demo, '__call__'):
                     demos[internal_widget_module_name] = internal_widget_module.demo
 
         groups = set()
 
-        for demo_name in demos.keys():
+        for demo_name in list(demos.keys()):
             parts = demo_name.split(".")
             group = parts[-2]
             groups.add(group)
--- ./lib/taurus/qt/qtgui/panel/taurusdevicepanel.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusdevicepanel.py	(refactored)
@@ -27,6 +27,8 @@
 TaurusDevicePanel.py:
 """
 
+from builtins import str
+from past.builtins import basestring
 __all__ = ["TaurusDevicePanel", "TaurusDevPanel"]
 
 __docformat__ = 'restructuredtext'
@@ -72,10 +74,10 @@
 
 
 def get_regexp_dict(dct, key, default=None):  # TODO: Tango-centric
-    for k, v in dct.items():  # Trying regular expression match
+    for k, v in list(dct.items()):  # Trying regular expression match
         if matchCl(k, key):
             return v
-    for k, v in dct.items():  # If failed, trying if key is contained
+    for k, v in list(dct.items()):  # If failed, trying if key is contained
         if k.lower() in key.lower():
             return v
     if default is not None:
@@ -323,7 +325,7 @@
             font.setPointSize(15)
             self._label.setFont(font)
             if pixmap is None and self.getIconMap():
-                for k, v in self.getIconMap().items():
+                for k, v in list(self.getIconMap().items()):
                     if searchCl(k, model):
                         pixmap = v
             if pixmap is not None:
@@ -348,7 +350,7 @@
                 filters = get_regexp_dict(
                     TaurusDevicePanel._attribute_filter, model, ['.*'])
                 if hasattr(filters, 'keys'):
-                    filters = filters.items()  # Dictionary!
+                    filters = list(filters.items())  # Dictionary!
                 if filters and isinstance(filters[0], (list, tuple)):  # Mapping
                     self._attrs = []
                     for tab, attrs in filters:
@@ -466,7 +468,7 @@
                 form.setViewFilters([lambda c: str(c.cmd_name).lower() not in (
                     'state', 'status') and any(searchCl(s[0], str(c.cmd_name)) for s in params)])
                 form.setDefaultParameters(dict((k, v) for k, v in (
-                    params if not hasattr(params, 'items') else params.items()) if v))
+                    params if not hasattr(params, 'items') else list(params.items())) if v))
             for wid in form._cmdWidgets:
                 if not hasattr(wid, 'getCommand') or not hasattr(wid, 'setDangerMessage'):
                     continue
--- ./lib/taurus/qt/qtgui/panel/taurusform.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusform.py	(refactored)
@@ -27,6 +27,10 @@
 from __future__ import print_function
 from __future__ import absolute_import
 
+from builtins import zip
+from builtins import filter
+from builtins import str
+from past.builtins import basestring
 __all__ = ["TaurusAttrForm", "TaurusCommandsForm", "TaurusForm"]
 
 __docformat__ = 'restructuredtext'
@@ -207,7 +211,7 @@
         if self.__modelChooserDlg is None:
             self.__modelChooserDlg = Qt.QDialog(self)
             self.__modelChooserDlg.setWindowTitle(
-                "%s - Model Chooser" % unicode(self.windowTitle()))
+                "%s - Model Chooser" % str(self.windowTitle()))
             self.__modelChooserDlg.modelChooser = TaurusModelChooser()
             layout = Qt.QVBoxLayout()
             layout.addWidget(self.__modelChooserDlg.modelChooser)
@@ -653,7 +657,7 @@
             return
 
         for f in self.getViewFilters():
-            commands = filter(f, commands)
+            commands = list(filter(f, commands))
 
         self._clearFrame()
 
@@ -739,7 +743,7 @@
 
         '''
         self._defaultParameters = dict((k.lower(), v)
-                                       for k, v in params.items())
+                                       for k, v in list(params.items()))
         self._updateCommandWidgets()
 
     def setViewFilters(self, filterlist):
@@ -838,7 +842,7 @@
             return
         attrlist = sorted(dev.attribute_list_query(), key=self._sortKey)
         for f in self.getViewFilters():
-            attrlist = filter(f, attrlist)
+            attrlist = list(filter(f, attrlist))
         attrnames = []
         devname = self.getModelName()
         for a in attrlist:
--- ./lib/taurus/qt/qtgui/panel/taurusinputpanel.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusinputpanel.py	(refactored)
@@ -26,6 +26,9 @@
 """This module provides an Input panel (usually used inside a TaurusDialog)"""
 from __future__ import print_function
 
+from builtins import map
+from builtins import str
+from builtins import object
 __all__ = ["TaurusInputPanel"]
 
 __docformat__ = 'restructuredtext'
@@ -121,7 +124,7 @@
         self.setText(input_data['prompt'])
 
         data_type = input_data.get('data_type', 'String')
-        is_seq = not isinstance(data_type, (str, unicode)) and \
+        is_seq = not isinstance(data_type, (str, str)) and \
             isinstance(data_type, collections.Sequence)
         if is_seq:
             panel, getter = self.create_selection_panel(input_data)
@@ -161,7 +164,7 @@
         self._ui.inputWidget = combobox = Qt.QComboBox()
         items = input_data['data_type']
         for item in items:
-            is_seq = not isinstance(item, (str, unicode)) and \
+            is_seq = not isinstance(item, (str, str)) and \
                 isinstance(item, collections.Sequence)
             if is_seq:
                 text, userData = item
@@ -183,7 +186,7 @@
         self._ui.inputWidget = buttongroup = Qt.QButtonGroup()
         buttongroup.setExclusive(True)
         for item in items:
-            is_seq = not isinstance(item, (str, unicode)) and \
+            is_seq = not isinstance(item, (str, str)) and \
                 isinstance(item, collections.Sequence)
             if is_seq:
                 text, userData = item
@@ -210,7 +213,7 @@
         default_value = input_data.get('default_value')
         if default_value is None:
             default_value = ()
-        dft_is_seq = not isinstance(default_value, (str, unicode)) and \
+        dft_is_seq = not isinstance(default_value, (str, str)) and \
             isinstance(default_value, collections.Sequence)
         if not dft_is_seq:
             default_value = default_value,
@@ -219,7 +222,7 @@
         listwidget.setSelectionMode(Qt.QAbstractItemView.MultiSelection)
 
         for item in items:
-            is_seq = not isinstance(item, (str, unicode)) and \
+            is_seq = not isinstance(item, (str, str)) and \
                 isinstance(item, collections.Sequence)
             if is_seq:
                 text, userData = item
--- ./lib/taurus/qt/qtgui/panel/taurusmessagepanel.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusmessagepanel.py	(refactored)
@@ -25,6 +25,10 @@
 
 """This module provides a panel to display taurus messages"""
 
+from future import standard_library
+standard_library.install_aliases()
+from builtins import str
+from builtins import object
 __all__ = ["TaurusMessagePanel", "TaurusMessageErrorHandler",
            "TangoMessageErrorHandler", "MacroServerMessageErrorHandler"]
 
@@ -278,7 +282,7 @@
     def _initReportCombo(self):
         report_handlers = get_report_handlers()
         combo = self.reportComboBox()
-        for name, report_handler in report_handlers.items():
+        for name, report_handler in list(report_handlers.items()):
             name = Qt.QVariant(name)
             combo.addItem(report_handler.Label, name)
 
@@ -504,7 +508,7 @@
         :return: a message box error handler
         :rtype: TaurusMessageBoxErrorHandler class object"""
 
-        for exc, h_klass in klass.ErrorHandlers.items():
+        for exc, h_klass in list(klass.ErrorHandlers.items()):
             if issubclass(err_type, exc):
                 return h_klass
         return TaurusMessageErrorHandler
@@ -589,8 +593,8 @@
     except PyTango.DevFailed as df1:
         try:
             import traceback
-            import StringIO
-            origin = StringIO.StringIO()
+            import io
+            origin = io.StringIO()
             traceback.print_stack(file=origin)
             origin.seek(0)
             origin = origin.read()
--- ./lib/taurus/qt/qtgui/panel/taurusmodelchooser.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusmodelchooser.py	(refactored)
@@ -29,6 +29,7 @@
 from __future__ import print_function
 from __future__ import absolute_import
 
+from builtins import str
 __all__ = ["TaurusModelSelectorTree", "TaurusModelChooser"]
 
 import sys
--- ./lib/taurus/qt/qtgui/panel/taurusmodellist.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusmodellist.py	(refactored)
@@ -26,6 +26,10 @@
 """
 itemsmodel Model and view for new CurveItem configuration
 """
+from builtins import str
+from builtins import range
+from past.builtins import basestring
+from builtins import object
 __all__ = ['TaurusModelModel', 'TaurusModelItem', 'TaurusModelList']
 #raise UnimplementedError('Under Construction!')
 
@@ -172,7 +176,7 @@
         if index.isValid() and (0 <= index.row() < self.rowCount()):
             row = index.row()
             item = self.items[row]
-            value = Qt.from_qvariant(value, unicode)
+            value = Qt.from_qvariant(value, str)
             if role == Qt.Qt.EditRole:
                 item.src = value
             elif role == Qt.Qt.DisplayRole:
@@ -188,7 +192,7 @@
         if parentindex is None:
             parentindex = Qt.QModelIndex()
         if items is None:
-            slice = [TaurusModelItem() for i in xrange(rows)]
+            slice = [TaurusModelItem() for i in range(rows)]
         else:
             slice = list(items)
             # note that the rows parameter is ignored if items is passed
@@ -424,7 +428,7 @@
 
         .. seealso:: :meth:`getModelItems`
         '''
-        return [unicode(s.src) for s in self.getModelItems()]
+        return [str(s.src) for s in self.getModelItems()]
 
     @classmethod
     def getQtDesignerPluginInfo(cls):
--- ./lib/taurus/qt/qtgui/panel/taurusvalue.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/taurusvalue.py	(refactored)
@@ -27,6 +27,7 @@
 taurusvalue.py:
 """
 
+from builtins import str
 __all__ = ["TaurusValue", "TaurusValuesFrame", "DefaultTaurusValueCheckBox",
            "DefaultUnitsWidget", "TaurusPlotButton", "TaurusArrayEditorButton",
            "TaurusValuesTableButton", "TaurusValuesTableButton_W",
--- ./lib/taurus/qt/qtgui/panel/report/albareport.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/report/albareport.py	(refactored)
@@ -26,6 +26,7 @@
 """This module provides a panel to display taurus messages"""
 from __future__ import absolute_import
 
+from builtins import str
 __all__ = ["TicketReportHandler"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtgui/panel/report/basicreport.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/report/basicreport.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides a panel to display taurus messages"""
 
+from builtins import str
 __all__ = ["ClipboardReportHandler", "SMTPReportHandler"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtgui/panel/test/test_taurusvalue.py	(original)
+++ ./lib/taurus/qt/qtgui/panel/test/test_taurusvalue.py	(refactored)
@@ -25,6 +25,7 @@
 
 """Test for taurus.qt.qtgui.panel.taurusvalue"""
 
+from builtins import str
 import unittest
 from taurus.test import insertTest
 from taurus.qt.qtgui.test import BaseWidgetTestCase
--- ./lib/taurus/qt/qtgui/plot/arrayedit.py	(original)
+++ ./lib/taurus/qt/qtgui/plot/arrayedit.py	(refactored)
@@ -27,8 +27,13 @@
 arrayedit.py: Widget for editing a spectrum/array via control points
 """
 from __future__ import absolute_import
-
-
+from __future__ import division
+
+
+from builtins import zip
+from builtins import str
+from builtins import range
+from past.utils import old_div
 import numpy
 from taurus.external.qt import Qt, Qwt5
 from taurus.qt.qtgui.util.ui import UILoadable
@@ -266,7 +271,7 @@
             new_xp = numpy.zeros(table.rowCount())
             new_corrp = numpy.zeros(table.rowCount())
             try:
-                for i in xrange(table.rowCount()):
+                for i in range(table.rowCount()):
                     new_xp[i] = float(table.item(i, 0).text())
                     new_corrp[i] = float(table.item(i, 1).text())
                 self.setCorrection(new_xp, new_corrp)
@@ -407,7 +412,7 @@
             Qt.QMessageBox.warning(
                 self, 'Scaling Error', 'The master at this control point is zero-valued. This point cannot be used as reference for scaling')
             return
-        v = sender.corrSB.value() / (self.yp[index])
+        v = old_div(sender.corrSB.value(), (self.yp[index]))
         for i in range(0, index):
             self._controllers[i].corrSB.setValue(v * self.yp[i])
 
@@ -420,7 +425,7 @@
             Qt.QMessageBox.warning(
                 self, 'Scaling Error', 'The master at this control point is zero-valued. This point cannot be used as reference for scaling')
             return
-        v = sender.corrSB.value() / (self.yp[index])
+        v = old_div(sender.corrSB.value(), (self.yp[index]))
         for i in range(index + 1, self.xp.size):
             self._controllers[i].corrSB.setValue(v * self.yp[i])
 
--- ./lib/taurus/qt/qtgui/plot/curveStatsDlg.py	(original)
+++ ./lib/taurus/qt/qtgui/plot/curveStatsDlg.py	(refactored)
@@ -28,7 +28,11 @@
     A Qt dialog for choosing plot appearance (symbols and lines)
     for a QwtPlot-derived widget (like Taurusplot)
 """
-
+from __future__ import division
+
+from builtins import zip
+from builtins import range
+from past.utils import old_div
 from taurus.external.qt import Qt, Qwt5
 from datetime import datetime
 from taurus.qt.qtgui.util.ui import UILoadable
@@ -68,7 +72,7 @@
 
         cbs = (self.ui.npointsStatCB, self.ui.minStatCB, self.ui.maxStatCB,
                self.ui.meanStatCB, self.ui.stdStatCB, self.ui.rmsStatCB)
-        self._checkboxToColMap = dict(zip(cbs, xrange(len(self.statColumns))))
+        self._checkboxToColMap = dict(list(zip(cbs, range(len(self.statColumns)))))
 
         self.minPicker = Qwt5.QwtPlotPicker(Qwt5.QwtPlot.xBottom,
                                             Qwt5.QwtPlot.yLeft,
@@ -133,10 +137,10 @@
 
     def _timestamptToQDateTime(self, ts):
         dt = datetime.fromtimestamp(ts)
-        return Qt.QDateTime(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.microsecond / 1000)
+        return Qt.QDateTime(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, old_div(dt.microsecond, 1000))
 
     def _QDateTimeToTimestamp(self, qdt):
-        return qdt.toTime_t() + qdt.time().msec() / 1000.
+        return qdt.toTime_t() + old_div(qdt.time().msec(), 1000.)
 
     def onSelectMin(self):
         '''slot called when the user clicks on the selectMin button'''
@@ -233,7 +237,7 @@
         '''returns a list of row numbers corresponding to the selected rows of the table'''
         selected = []
         for rg in self.ui.statsTW.selectedRanges():
-            for row in xrange(rg.topRow(), rg.topRow() + rg.rowCount()):
+            for row in range(rg.topRow(), rg.topRow() + rg.rowCount()):
                 selected.append(row)
         return selected
 
@@ -249,21 +253,21 @@
         xmin, xmax = None, None
         if self.ui.minCB.isChecked():
             if plot.getXIsTime():
-                xmin = self.ui.minDTE.dateTime().toTime_t() + self.ui.minDTE.time().msec() / \
-                    1000.
+                xmin = self.ui.minDTE.dateTime().toTime_t() + old_div(self.ui.minDTE.time().msec(), \
+                    1000.)
             else:
                 xmin = self.ui.minSB.value()
         if self.ui.maxCB.isChecked():
             if plot.getXIsTime():
-                xmax = self.ui.maxDTE.dateTime().toTime_t() + self.ui.maxDTE.time().msec() / \
-                    1000.
+                xmax = self.ui.maxDTE.dateTime().toTime_t() + old_div(self.ui.maxDTE.time().msec(), \
+                    1000.)
             else:
                 xmax = self.ui.maxSB.value()
         limits = xmin, xmax
 
         selectedRows = self.getSelectedRows()
         if len(selectedRows) == 0:
-            selectedRows = range(len(self.curveNames))
+            selectedRows = list(range(len(self.curveNames)))
         selectedCurves = [self.curveNames[i] for i in selectedRows]
         statsdict = plot.getCurveStats(
             limits=limits, curveNames=selectedCurves)
--- ./lib/taurus/qt/qtgui/plot/curveprops.py	(original)
+++ ./lib/taurus/qt/qtgui/plot/curveprops.py	(refactored)
@@ -27,6 +27,9 @@
 curveprops: Model and view for curve properties
 """
 from __future__ import absolute_import
+from builtins import str
+from builtins import range
+from builtins import object
 __all__ = ['CurveConf', 'CurvesTableModel',
            'ExtendedSelectionModel', 'CurvePropertiesView']
 #raise NotImplementedError('Under Construction!')
@@ -50,7 +53,7 @@
 # set some named constants
 # columns:
 NUMCOLS = 4
-X, Y, TITLE, VIS = range(NUMCOLS)
+X, Y, TITLE, VIS = list(range(NUMCOLS))
 SRC_ROLE = Qt.Qt.UserRole + 1
 PROPS_ROLE = Qt.Qt.UserRole + 2
 
@@ -74,7 +77,7 @@
 
     def processSrc(self, src):
         '''returns src,display,icon,ok'''
-        src = unicode(src)
+        src = str(src)
         # empty
         if src == '':
             return '', '', Qt.QIcon(), True
@@ -243,7 +246,7 @@
                     row, 0), self.index(row, self.ncolumns - 1))
             else:
                 column = index.column()
-                value = Qt.from_qvariant(value, unicode)
+                value = Qt.from_qvariant(value, str)
                 if column == X:
                     curve.x.setSrc(value)
                 elif column == Y:
@@ -357,8 +360,8 @@
         self.loadUi()
 
         self.ui.sStyleCB.insertItems(0, sorted(NamedSymbolStyles.values()))
-        self.ui.lStyleCB.insertItems(0, NamedLineStyles.values())
-        self.ui.cStyleCB.insertItems(0, NamedCurveStyles.values())
+        self.ui.lStyleCB.insertItems(0, list(NamedLineStyles.values()))
+        self.ui.cStyleCB.insertItems(0, list(NamedCurveStyles.values()))
         self.ui.sColorCB.addItem("")
         self.ui.lColorCB.addItem("")
         for color in NamedColors:
--- ./lib/taurus/qt/qtgui/plot/curvesAppearanceChooserDlg.py	(original)
+++ ./lib/taurus/qt/qtgui/plot/curvesAppearanceChooserDlg.py	(refactored)
@@ -30,6 +30,8 @@
 """
 from __future__ import print_function
 
+from builtins import str
+from builtins import object
 import copy
 
 from taurus.external.qt import Qt, Qwt5
@@ -46,7 +48,7 @@
                    Qt.Qt.DashDotDotLine: ".._..",
                    }
 ReverseNamedLineStyles = {}
-for k, v in NamedLineStyles.iteritems():
+for k, v in NamedLineStyles.items():
     ReverseNamedLineStyles[v] = k
 
 NamedCurveStyles = {None: "",
@@ -57,7 +59,7 @@
                     Qwt5.QwtPlotCurve.Dots: "Dots"
                     }
 ReverseNamedCurveStyles = {}
-for k, v in NamedCurveStyles.iteritems():
+for k, v in NamedCurveStyles.items():
     ReverseNamedCurveStyles[v] = k
 
 NamedSymbolStyles = {
@@ -81,7 +83,7 @@
 }
 
 ReverseNamedSymbolStyles = {}
-for k, v in NamedSymbolStyles.iteritems():
+for k, v in NamedSymbolStyles.items():
     ReverseNamedSymbolStyles[v] = k
 
 NamedColors = ["Black", "Red", "Blue", "Magenta",
@@ -113,8 +115,8 @@
         self.loadUi()
         self.autoApply = autoApply
         self.sStyleCB.insertItems(0, sorted(NamedSymbolStyles.values()))
-        self.lStyleCB.insertItems(0, NamedLineStyles.values())
-        self.cStyleCB.insertItems(0, NamedCurveStyles.values())
+        self.lStyleCB.insertItems(0, list(NamedLineStyles.values()))
+        self.cStyleCB.insertItems(0, list(NamedCurveStyles.values()))
         self.sColorCB.addItem("")
         self.lColorCB.addItem("")
         if not showButtons:
@@ -164,7 +166,7 @@
         self._curvePropDictOrig = copy.deepcopy(curvePropDict)
         self.curvesLW.clear()
         self.__itemsDict = CaselessDict()
-        for name, prop in self.curvePropDict.iteritems():
+        for name, prop in self.curvePropDict.items():
             # create and insert the item
             item = Qt.QListWidgetItem(Qt.QString(prop.title), self.curvesLW)
             self.__itemsDict[name] = item
@@ -192,7 +194,7 @@
         '''
         if newTitlesDict is None:
             return
-        for name, title in newTitlesDict.iteritems():
+        for name, title in newTitlesDict.items():
             self.curvePropDict[name].title = title
             self.__itemsDict[name].setText(title)
 
--- ./lib/taurus/qt/qtgui/plot/qwtdialog.py	(original)
+++ ./lib/taurus/qt/qtgui/plot/qwtdialog.py	(refactored)
@@ -28,7 +28,11 @@
 """
 from __future__ import print_function
 from __future__ import absolute_import
-
+from __future__ import division
+
+from builtins import str
+from builtins import range
+from past.utils import old_div
 __all__ = ["TaurusPlotConfigDialog"]
 
 import time
@@ -251,11 +255,11 @@
         elif dt < 120:
             return "%g s" % round(dt, 0)
         elif dt < 7200:
-            return "%g m" % round(dt / 60, 0)
+            return "%g m" % round(old_div(dt, 60), 0)
         elif dt < 172800:
-            return "%g h" % round(dt / 3600, 0)
-        else:
-            return "%g d" % round(dt / 86400, 0)
+            return "%g h" % round(old_div(dt, 3600), 0)
+        else:
+            return "%g d" % round(old_div(dt, 86400), 0)
 
     def str2deltatime(self, strtime):
         '''Translates a time string to seconds
@@ -267,7 +271,7 @@
                      24, 'w': 3600 * 24 * 7, 'y': 3600 * 24 * 365}
         if strtime.lower() == "now":
             return time.time()
-        if strtime[-1] in timeunits.keys():
+        if strtime[-1] in list(timeunits.keys()):
             try:
                 return float(strtime[:-1]) * timeunits[strtime[-1]]
             except Exception as e:
--- ./lib/taurus/qt/qtgui/plot/scales.py	(original)
+++ ./lib/taurus/qt/qtgui/plot/scales.py	(refactored)
@@ -27,6 +27,10 @@
 scales.py: Custom scales used by taurus.qt.qtgui.plot module
 """
 from __future__ import print_function
+from __future__ import division
+from builtins import str
+from builtins import range
+from past.utils import old_div
 __all__ = ["DateTimeScaleEngine", "DeltaTimeScaleEngine", "FixedLabelsScaleEngine",
            "FancyScaleDraw", "TaurusTimeScaleDraw", "DeltaTimeScaleDraw",
            "FixedLabelsScaleDraw"]
@@ -218,7 +222,7 @@
 
         elif dx > 2:  # 2s
             format = "%H:%M:%S"
-            majticks = range(int(x1) + 1, int(x2))
+            majticks = list(range(int(x1) + 1, int(x2)))
 
         else:  # less than 2s (show microseconds)
             scaleDiv = Qwt5.QwtLinearScaleEngine.divideScale(
@@ -229,7 +233,7 @@
         # make sure to comply with maxMajTicks
         L = len(majticks)
         if L > maxMajSteps:
-            majticks = majticks[::int(numpy.ceil(float(L) / maxMajSteps))]
+            majticks = majticks[::int(numpy.ceil(old_div(float(L), maxMajSteps)))]
 
         scaleDiv = Qwt5.QwtScaleDiv(interval, minticks, medticks, majticks)
         self.scaleDraw().setDatetimeLabelFormat(format)
@@ -362,7 +366,7 @@
             s = 86400  # 1 day
         # calculate a step size that respects the base step (s) and also
         # enforces the maxMajSteps
-        stepSize = s * int(numpy.ceil(float(d_range // s) / maxMajSteps))
+        stepSize = s * int(numpy.ceil(old_div(float(d_range // s), maxMajSteps)))
         return Qwt5.QwtLinearScaleEngine.divideScale(self, x1, x2, maxMajSteps, maxMinSteps, stepSize)
 
     @staticmethod
--- ./lib/taurus/qt/qtgui/plot/taurusarrayedit.py	(original)
+++ ./lib/taurus/qt/qtgui/plot/taurusarrayedit.py	(refactored)
@@ -25,6 +25,7 @@
 
 
 from __future__ import absolute_import
+from builtins import str
 from taurus.external.qt import Qt
 import taurus
 import numpy
--- ./lib/taurus/qt/qtgui/plot/taurusplot.py	(original)
+++ ./lib/taurus/qt/qtgui/plot/taurusplot.py	(refactored)
@@ -28,6 +28,16 @@
 """
 from __future__ import print_function
 from __future__ import absolute_import
+from __future__ import division
+from future import standard_library
+standard_library.install_aliases()
+from builtins import zip
+from builtins import next
+from builtins import str
+from builtins import range
+from past.builtins import basestring
+from past.utils import old_div
+from builtins import object
 __all__ = ["TaurusCurve", "TaurusCurveMarker",
            "TaurusXValues", "TaurusPlot", "isodatestr2float"]
 
@@ -144,9 +154,9 @@
         '''
         xmap = self.plot().canvasMap(self.xAxis())
         ymap = self.plot().canvasMap(self.yAxis())
-        xmiddlepoint = xmap.p1() + xmap.pDist() / 2  # p1,p2 are left,right here
+        xmiddlepoint = xmap.p1() + old_div(xmap.pDist(), 2)  # p1,p2 are left,right here
         # p1,p2 are bottom,top here (and pixel coords start from top!)
-        ymiddlepoint = ymap.p2() + ymap.pDist() / 2
+        ymiddlepoint = ymap.p2() + old_div(ymap.pDist(), 2)
         xPaintPos = xmap.transform(self.xValue())
         yPaintPos = ymap.transform(self.yValue())
 
@@ -912,8 +922,8 @@
         if imax is None:
             imax = data.size()
 
-        x = numpy.array([data.x(i) for i in xrange(imin, imax)])
-        y = numpy.array([data.y(i) for i in xrange(imin, imax)])
+        x = numpy.array([data.x(i) for i in range(imin, imax)])
+        y = numpy.array([data.y(i) for i in range(imin, imax)])
 
         if limits is not None:
             xmin, xmax = limits
@@ -1278,7 +1288,7 @@
 
     def setFormat(self, format):
         """Reimplemented from TaurusBaseComponent"""
-        targetCurveNames = self.curves.iterkeys()
+        targetCurveNames = iter(self.curves.keys())
         for name in targetCurveNames:
             curve = self.curves.get(name, None)
             w = getattr(curve, 'owner', curve)
@@ -1345,7 +1355,7 @@
             if curve is None:
                 title = None
             else:
-                title = unicode(curve.title().text())
+                title = str(curve.title().text())
         finally:
             self.curves_lock.release()
         return title
@@ -1360,7 +1370,7 @@
         '''
         self.curves_lock.acquire()
         try:
-            ret = copy.deepcopy(self.curves.keys())
+            ret = copy.deepcopy(list(self.curves.keys()))
         finally:
             self.curves_lock.release()
         return ret
@@ -1395,7 +1405,7 @@
         try:
             if ordered is None:
                 orderedObjs = sorted(
-                    self.curves.values(), key=lambda curve: curve.titleText(compiled=True))
+                    list(self.curves.values()), key=lambda curve: curve.titleText(compiled=True))
             else:
                 #current = self.curves.keys()
                 # if len(ordered) != len(current) or set(map(str.lower,current)) - set(map(str.lower, ordered)):
@@ -1430,7 +1440,7 @@
         for z in (self._zoomer1, self._zoomer2):
             z.setEnabled(z.yAxis() == axis)
         self._zoomer = self.getZoomers(axis)[0]
-        self.debug('Now Zooming on %s' % unicode(self.getAxisName(axis)))
+        self.debug('Now Zooming on %s' % str(self.getAxisName(axis)))
         return self._zoomer.yAxis()
 
     def getAxisName(self, axis):
@@ -1441,7 +1451,7 @@
 
         :return: (unicode)
         '''
-        name = unicode(self.axisTitle(axis).text())
+        name = str(self.axisTitle(axis).text())
         if name == '':
             name = self._axesnames[axis]
         return name
@@ -1451,7 +1461,7 @@
 
         :param paused: (bool) if True, the plot will be paused
         '''
-        for c in self.curves.itervalues():
+        for c in self.curves.values():
             c.setPaused(paused)
         self._isPaused = paused
 
@@ -1524,7 +1534,7 @@
                                If None given, it will be autocalculated
 
         '''
-        positions, labels = zip(*pos_and_labels)  # "unzipping"
+        positions, labels = list(zip(*pos_and_labels))  # "unzipping"
         positions = list(positions)
 
         self.setAxisScaleEngine(axis, FixedLabelsScaleEngine(positions))
@@ -1662,7 +1672,7 @@
         self.curves_lock.acquire()
         try:
             self._showMaxPeaks = show
-            for curveName in self.curves.iterkeys():
+            for curveName in self.curves.keys():
                 curve = self.curves.get(str(curveName))
                 if show:
                     curve.showMaxPeak(True)
@@ -1683,7 +1693,7 @@
         self.curves_lock.acquire()
         try:
             self._showMinPeaks = show
-            for curveName in self.curves.iterkeys():
+            for curveName in self.curves.keys():
                 curve = self.curves.get(str(curveName))
                 if show:
                     curve.showMinPeak(True)
@@ -1749,7 +1759,7 @@
         try:
             # get the key in the self.curves directory
             curveName = None
-            for curveName, c in self.curves.iteritems():
+            for curveName, c in self.curves.items():
                 if c is curve:
                     break
             axis = curve.yAxis()
@@ -1930,7 +1940,7 @@
         """
         self.curves_lock.acquire()
         try:
-            names = [name for name in self.curves.keys() if self.curves[
+            names = [name for name in list(self.curves.keys()) if self.curves[
                 name].isRawData]
         finally:
             self.curves_lock.release()
@@ -1951,8 +1961,8 @@
         try:
             if curvename in self.curves:
                 data = self.curves[curvename].data()
-                x = [data.x(i) for i in xrange(data.size())]
-                y = [data.y(i) for i in xrange(data.size())]
+                x = [data.x(i) for i in range(data.size())]
+                y = [data.y(i) for i in range(data.size())]
             else:
                 self.error("Curve '%s' not found" % curvename)
                 raise KeyError()
@@ -1988,7 +1998,7 @@
                 xnames.append(xname)
                 ynames.append(yname)
 
-            del_curves = [name for name in self.curves.keys()
+            del_curves = [name for name in list(self.curves.keys())
                           if name not in ynames]
 
             # if all curves were removed, reset the color palette
@@ -2101,7 +2111,7 @@
         '''See :meth:`TaurusBaseComponent.parentModelChanged`'''
         self.curves_lock.acquire()
         try:
-            for curve in self.curves.values():
+            for curve in list(self.curves.values()):
                 curve.setModelCheck(curve.getModel(), False)
         finally:
             self.curves_lock.release()
@@ -2260,7 +2270,7 @@
         self.curves_lock.acquire()
         try:
             propdict = {}
-            for name, curve in self.curves.iteritems():
+            for name, curve in self.curves.items():
                 propdict[name] = copy.deepcopy(curve.getAppearanceProperties())
         finally:
             self.curves_lock.release()
@@ -2278,7 +2288,7 @@
         """
         self.curves_lock.acquire()
         try:
-            for name, prop in propDict.iteritems():
+            for name, prop in propDict.items():
                 c = self.curves[name]
                 c.setAppearanceProperties(copy.deepcopy(prop))
                 visible = getattr(prop, 'visible', True)
@@ -2327,7 +2337,7 @@
         miscdict = {'defaultCurvesTitle': self.getDefaultCurvesTitle(),
                     'canvasBackground': self.canvasBackground(),
                     'orderedCurveNames': self.getCurveNamesSorted(),
-                    'plotTitle': unicode(self.title().text()),
+                    'plotTitle': str(self.title().text()),
                     'formatter': self.getFormat()}
         if self.isWindow():
             miscdict["Geometry"] = self.saveGeometry()
@@ -2397,7 +2407,7 @@
         self.curves_lock.acquire()
         try:
             if curvenames is None:
-                curvenames = self.curves.keys()
+                curvenames = list(self.curves.keys())
             curvenames = self._lowerIfInsensitive(curvenames)
             for name in curvenames:
                 curve = self.curves.get(name)
@@ -2429,11 +2439,11 @@
         if not self.checkConfigVersion(configdict):
             return
         # attach the curves
-        for rd in configdict["RawData"].values():
+        for rd in list(configdict["RawData"].values()):
             self.attachRawData(rd)
         # for backwards compatibility, if the ordered list of models is not
         # stored, it uses the unsorted dict values
-        models = configdict.get("model", configdict["TangoCurves"].values())
+        models = configdict.get("model", list(configdict["TangoCurves"].values()))
         self.addModels(models)
         # set curve properties
         self.setCurveAppearanceProperties(configdict["CurveProp"])
@@ -2486,7 +2496,7 @@
 
         :return: (str) file name used
         """
-        import cPickle as pickle
+        import pickle as pickle
         if ofile is None:
             ofile = str(Qt.QFileDialog.getSaveFileName(self, 'Save Taurusplot Configuration',
                                                        'TaurusplotConfig.pck', 'TaurusPlot Curve Properties File (*.pck)'))
@@ -2506,7 +2516,7 @@
 
         :return: (str) file name used
         """
-        import cPickle as pickle
+        import pickle as pickle
         if ifile is None:
             ifile = str(Qt.QFileDialog.getOpenFileName(
                 self, 'Load Taurusplot Configuration', '', 'TaurusPlot Curve Properties File (*.pck)'))
@@ -2523,7 +2533,7 @@
         See :meth:`TaurusBaseComponent.setEventFilters`
         '''
         if curvenames is None:
-            curvenames = self.curves.keys()
+            curvenames = list(self.curves.keys())
         self.curves_lock.acquire()
         try:
             for name in curvenames:
@@ -2551,7 +2561,7 @@
             originalXRange = self.getXAxisRange()
             self.curves_lock.acquire()
             try:
-                for c in self.curves.values():
+                for c in list(self.curves.values()):
                     if c.minXValue() < minX:
                         minX = c.minXValue()
                     if c.maxXValue() > maxX:
@@ -2670,7 +2680,7 @@
         '''call safeSetData again on all curves to force a refiltering in case the scale changed its type'''
         self.curves_lock.acquire()
         try:
-            for c in self.curves.itervalues():
+            for c in self.curves.values():
                 c.safeSetData()
         finally:
             self.curves_lock.release()
@@ -2801,7 +2811,7 @@
             else:
                 rawdata["x"] = M[:, xcol]
 
-            for col in xrange(M.shape[1]):
+            for col in range(M.shape[1]):
                 if col == xcol:
                     continue  # ignore the xcol (it has already been set)
                 rawdata["y"] = M[:, col]
@@ -2926,7 +2936,7 @@
         try:
             # get a list of *unique* axes with visible curves attached
             axes = list(
-                set([curve.yAxis() for curve in self.curves.itervalues() if curve.isVisible()]))
+                set([curve.yAxis() for curve in self.curves.values() if curve.isVisible()]))
 
             n = len(axes)
             if n == 0:
@@ -2985,7 +2995,7 @@
         self.curves_lock.acquire()
         try:
             if targetCurveNames is None:
-                targetCurveNames = self.curves.iterkeys()
+                targetCurveNames = iter(self.curves.keys())
             for name in targetCurveNames:
                 curve = self.curves.get(name, None)
                 if curve is None:
@@ -2993,7 +3003,7 @@
                 if not curve.isVisible():
                     continue
                 data = curve.data()
-                for i in xrange(data.size()):
+                for i in range(data.size()):
                     point = Qt.QPoint(self.transform(curve.xAxis(), data.x(
                         i)), self.transform(curve.yAxis(), data.y(i)))
                     if scopeRect.contains(point):
@@ -3186,7 +3196,7 @@
             for name in curveNames:
                 curve = self.curves.get(name, None)
                 stats[name] = curve.getStats(limits=limits)
-                stats[name]['title'] = unicode(curve.title().text())
+                stats[name]['title'] = str(curve.title().text())
         finally:
             self.curves_lock.release()
         return stats
@@ -3359,7 +3369,7 @@
 
         self.curves_lock.acquire()
         try:
-            for curve in self.curves.values():
+            for curve in list(self.curves.values()):
                 curve.setUseParentModel(yesno)
         finally:
             self.curves_lock.release()
@@ -3459,7 +3469,7 @@
         try:
             if curveNamesList is None:
                 curveNamesList = [
-                    n for n, c in self.curves.iteritems() if not c.isRawData]
+                    n for n, c in self.curves.items() if not c.isRawData]
             newTitlesDict = CaselessDict()
             for curveName in curveNamesList:
                 curve = self.curves.get(curveName)
@@ -3626,7 +3636,7 @@
         self._optimizationEnabled = enable
         # make sure that already-created curves are also optimized
         try:
-            for curveName in self.curves.iterkeys():
+            for curveName in self.curves.keys():
                 curve = self.curves.get(str(curveName))
                 curve.setPaintAttribute(curve.PaintFiltered, enable)
                 curve.setPaintAttribute(curve.ClipPolygons, enable)
@@ -3728,7 +3738,7 @@
         w.setModel(models)
         
     if options.export_file is not None:
-        curves = dict.fromkeys(w.trendSets.keys(), 0)
+        curves = dict.fromkeys(list(w.trendSets.keys()), 0)
 
         def exportIfAllCurves(curve, trend=w, counters=curves):
             curve = str(curve)
@@ -3743,7 +3753,7 @@
         if not curves:
             w.close()
         else:
-            for ts in w.trendSets.values():
+            for ts in list(w.trendSets.values()):
                 ts.dataChanged.connect(exportIfAllCurves)
         sys.exit(app.exec_())  # exit without showing the widget
 
--- ./lib/taurus/qt/qtgui/plot/taurustrend.py	(original)
+++ ./lib/taurus/qt/qtgui/plot/taurustrend.py	(refactored)
@@ -27,6 +27,11 @@
 taurustrend.py: Generic trend widget for Taurus
 """
 from __future__ import print_function
+from __future__ import division
+from builtins import zip
+from builtins import str
+from builtins import range
+from past.utils import old_div
 __all__ = ["ScanTrendsSet", "TaurusTrend", "TaurusTrendsSet"]
 
 from datetime import datetime
@@ -113,7 +118,7 @@
             self._orderedCurveNames = []
         else:
             self._curves = curves
-            self._orderedCurveNames = curves.keys()
+            self._orderedCurveNames = list(curves.keys())
         self._titleText = None
         self.setModel(name)
 
@@ -184,7 +189,7 @@
         ntrends = len(self._curves)
         if '<trend_index>' in basetitle:
             ret = [basetitle.replace('<trend_index>', "%i" % i)
-                   for i in xrange(ntrends)]
+                   for i in range(ntrends)]
         else:
             ret = [basetitle] * ntrends
         return ret
@@ -472,7 +477,7 @@
             # them to the TrendSet
             name = self.getModelName()
             rawdata = {'x': numpy.zeros(0), 'y': numpy.zeros(0)}
-            for i in xrange(ntrends):
+            for i in range(ntrends):
                 subname = "%s[%i]" % (name, i)
                 self.parent().attachRawData(rawdata, id=subname)
                 self.addCurve(subname, self.parent().curves[subname])
@@ -830,7 +835,7 @@
         # if autoclear is False we have to work directly with each curve (and
         # cannot buffer)
         else:
-            for n, v in recordData.items():
+            for n, v in list(recordData.items()):
                 c = self._curves.get(n, None)
                 if c is None:
                     continue
@@ -1124,7 +1129,7 @@
         not remove the models, it simply removes all stored data)'''
         self.curves_lock.acquire()
         try:
-            for ts in self.trendSets.itervalues():
+            for ts in self.trendSets.values():
                 ts.clearTrends(replot=False)
         finally:
             self.curves_lock.release()
@@ -1158,7 +1163,7 @@
         try:
             # For it to work properly, 'names' must be a CaselessList, just as
             # self.trendSets is a CaselessDict
-            del_sets = [name for name in self.trendSets.keys()
+            del_sets = [name for name in list(self.trendSets.keys())
                         if name not in names]
 
             # if all trends were removed, reset the color palette
@@ -1276,7 +1281,7 @@
                     index = 0
                 else:
                     return tset.compiledTitle
-            title = unicode(tset[index].title().text())
+            title = str(tset[index].title().text())
         finally:
             self.curves_lock.release()
         return title
@@ -1325,7 +1330,7 @@
                     newTitlesDict = CaselessDict()
                     for curveName in curveNamesList:
                         curvetitle = titletext
-                        for ts in self.trendSets.itervalues():
+                        for ts in self.trendSets.values():
                             if curveName in ts:
                                 curvetitle = ts.compileBaseTitle(curvetitle)
                                 curvetitle = curvetitle.replace(
@@ -1426,7 +1431,7 @@
                 #      calling setInterval only when really needed.
                 self._replotTimer.setInterval(plot_refresh)
                 self.debug('New replot period is %1.2f seconds',
-                           (plot_refresh / 1000.))
+                           (old_div(plot_refresh, 1000.)))
 
         else:
             self.warning(
@@ -1437,7 +1442,7 @@
 
         .. seealso:: :meth:`TaurusBaseComponent.setPaused`
         '''
-        for ts in self.trendSets.itervalues():
+        for ts in self.trendSets.values():
             ts.setPaused(paused)
         self._isPaused = paused
 
@@ -1475,7 +1480,7 @@
         miscdict["MaxBufferSize"] = self.getMaxDataBufferSize()
         self.curves_lock.acquire()
         try:
-            for tsname, ts in self.trendSets.iteritems():
+            for tsname, ts in self.trendSets.items():
                 if tsname in tsnames:
                     # store a dict containing just model names (key and value
                     # are the same)
@@ -1506,11 +1511,11 @@
         if maxBufferSize is not None:
             self.setMaxDataBufferSize(maxBufferSize)
         # attach the curves
-        for rd in configdict["RawData"].values():
+        for rd in list(configdict["RawData"].values()):
             self.attachRawData(rd)
         # for backwards compatibility, if the ordered list of models is not
         # stored, it uses the unsorted dict values
-        models = configdict.get("model", configdict["TrendSets"].values())
+        models = configdict.get("model", list(configdict["TrendSets"].values()))
         self.addModels(models)
         for m in models:
             tset = self.trendSets[m]
@@ -1686,7 +1691,7 @@
 
         self.curves_lock.acquire()
         try:
-            for n, ts in self.trendSets.iteritems():
+            for n, ts in self.trendSets.items():
                 try:
                     ts.setMaxDataBufferSize(maxSize)
                 except ValueError:
@@ -1923,7 +1928,7 @@
         w.setModel(models)
     # export option
     if options.export_file is not None:
-        curves = dict.fromkeys(w.trendSets.keys(), 0)
+        curves = dict.fromkeys(list(w.trendSets.keys()), 0)
 
         def exportIfAllCurves(curve, trend=w, counters=curves):
             curve = str(curve)
@@ -1938,7 +1943,7 @@
         if not curves:
             w.close()
         else:
-            for ts in w.trendSets.values():
+            for ts in list(w.trendSets.values()):
                 ts.dataChanged.connect(exportIfAllCurves)
         sys.exit(app.exec_())  # exit without showing the widget
 
--- ./lib/taurus/qt/qtgui/table/qdictionary.py	(original)
+++ ./lib/taurus/qt/qtgui/table/qdictionary.py	(refactored)
@@ -26,6 +26,9 @@
 """This module provides basic python dictionary/list editor widgets"""
 from __future__ import print_function
 
+from builtins import str
+from builtins import range
+from past.builtins import basestring
 __all__ = ["QDictionaryEditor", "QListEditor"]
 
 __docformat__ = 'restructuredtext'
@@ -87,8 +90,8 @@
 
     def expand(d, level):  # ,nrows=nrows,ncols=ncols):
         # self.debug('\texpand(%s(%s),%s)'%(type(d),d,level))
-        items = d.items() if isinstance(d, SortedDict) else sorted(
-            d.items() if hasattr(d, 'items') else d)
+        items = list(d.items()) if isinstance(d, SortedDict) else sorted(
+            list(d.items()) if hasattr(d, 'items') else d)
         for k, v in items:
             zero = data['nrows']
             data[(data['nrows'], level)] = k
@@ -106,7 +109,7 @@
     [table.append([]) for r in range(data.pop('nrows'))]
     [table[r].append(None) for c in range(data.pop('ncols'))
      for r in range(len(table))]
-    for coord, value in data.items():
+    for coord, value in list(data.items()):
         table[coord[0]][coord[1]] = value
     return table
 
--- ./lib/taurus/qt/qtgui/table/qlogtable.py	(original)
+++ ./lib/taurus/qt/qtgui/table/qlogtable.py	(refactored)
@@ -27,6 +27,10 @@
 python :mod:`logging` module"""
 from __future__ import absolute_import
 
+from past.builtins import cmp
+from builtins import map
+from builtins import str
+from builtins import range
 __all__ = ["QLoggingTableModel", "QLoggingTable", "QLoggingWidget",
            "QRemoteLoggingTableModel"]
 
@@ -50,7 +54,7 @@
 
 from .qtable import QBaseTableWidget
 
-LEVEL, TIME, MSG, NAME, ORIGIN = range(5)
+LEVEL, TIME, MSG, NAME, ORIGIN = list(range(5))
 HORIZ_HEADER = 'Level', 'Time', 'Message', 'By', 'Origin'
 
 __LEVEL_BRUSH = {
@@ -77,7 +81,7 @@
         elevel = taurus.Error
     elif level <= taurus.Critical:
         elevel = taurus.Critical
-    f, g = map(Qt.QBrush, __LEVEL_BRUSH[elevel])
+    f, g = list(map(Qt.QBrush, __LEVEL_BRUSH[elevel]))
     return f, g
 
 
@@ -120,7 +124,7 @@
     host, procName, procID, threadName, threadID = _get_record_origin(rec)
     pathname, filename, modulename, funcname, lineno = _get_record_trace(rec)
     timestamp = str(datetime.datetime.fromtimestamp(rec.created))
-    bgcolor, fgcolor = map(Qt.QBrush.color, getBrushForLevel(rec.levelno))
+    bgcolor, fgcolor = list(map(Qt.QBrush.color, getBrushForLevel(rec.levelno)))
     bgcolor = "#%02x%02x%02x" % (
         bgcolor.red(), bgcolor.green(), bgcolor.blue())
     fgcolor = "#%02x%02x%02x" % (
@@ -346,7 +350,7 @@
         """Overwrite of slot rows inserted to do proper resize and scroll to
         bottom if desired"""
         Qt.QTableView.rowsInserted(self, index, start, end)
-        for i in xrange(start, end + 1):
+        for i in range(start, end + 1):
             self.resizeRowToContents(i)
         if start == 0:
             self.resizeColumnsToContents()
@@ -563,7 +567,7 @@
     import time
     import random
 
-    for i in xrange(10):
+    for i in range(10):
         taurus.info("Hello world %04d" % i)
 
     loggers = ["Object%02d" % (i + 1) for i in range(10)]
--- ./lib/taurus/qt/qtgui/table/taurusdevicepropertytable.py	(original)
+++ ./lib/taurus/qt/qtgui/table/taurusdevicepropertytable.py	(refactored)
@@ -30,6 +30,8 @@
 
 # todo: tango-centric
 
+from builtins import str
+from builtins import range
 __all__ = ["TaurusPropTable"]
 
 from taurus.external.qt import Qt, QtCore, QtGui
@@ -230,7 +232,7 @@
         text, ok = QtGui.QInputDialog.getText(
             self, 'New Property', 'Property name:')
         if ok:
-            text1 = unicode(text)
+            text1 = str(text)
             new_prop_name = str(text1)
             new_prop_value = '0'
             dict1 = {new_prop_name: [new_prop_value]}
@@ -269,7 +271,7 @@
             new_text, ok = QtGui.QInputDialog.getText(
                 self, 'Rename', 'Write new name of property:')
             if ok:
-                new_text = unicode(new_text)
+                new_text = str(new_text)
                 new_text = str(new_text)
                 list = [prop_name]
                 dict = {new_text: [prop_value]}
@@ -289,7 +291,7 @@
                 self.setNewPropertyValue(new_text)
 
     def setNewPropertyValue(self, new_text):
-        new_text = unicode(new_text)
+        new_text = str(new_text)
         new_text = str(new_text)
         values = {self.prop_name2: new_text.replace('\r', '').split('\n')}
         self.db.put_device_property(self.dev_name, values)
--- ./lib/taurus/qt/qtgui/table/taurusgrid.py	(original)
+++ ./lib/taurus/qt/qtgui/table/taurusgrid.py	(refactored)
@@ -34,6 +34,12 @@
 # This module needs a total cleanup. Both re. code conventions and algorithms.
 #   --cpascual 20140827
 
+from future import standard_library
+standard_library.install_aliases()
+from builtins import zip
+from builtins import next
+from builtins import str
+from builtins import range
 __all__ = ["TaurusGrid"]
 
 __docformat__ = 'restructuredtext'
@@ -41,7 +47,7 @@
 import re
 import operator
 import traceback
-import Queue
+import queue
 from functools import partial
 
 from taurus.external.qt import Qt, QtGui, QtCore
@@ -275,7 +281,7 @@
         self.hideLabels = False
 
         self.defineStyle()
-        self.modelsQueue = Queue.Queue()
+        self.modelsQueue = queue.Queue()
         self.__modelsThread = None
         if not designMode:
             self.modelsThread
@@ -660,12 +666,12 @@
             self.row_labels = sorted(
                 list(set(m.split('/')[0].upper() for m in models if
                          m.count('/') >= 2)))
-            self.row_labels = zip(self.row_labels, self.row_labels)
+            self.row_labels = list(zip(self.row_labels, self.row_labels))
         if not self.column_labels:  # Families used by default
             self.column_labels = sorted(
                 list(set(m.split('/')[1].upper() for m in models if
                          m.count('/') >= 2)))
-            self.column_labels = zip(self.column_labels, self.column_labels)
+            self.column_labels = list(zip(self.column_labels, self.column_labels))
 
             # for m in models:
             # if m.count('/')<2:
--- ./lib/taurus/qt/qtgui/table/taurusvaluestable.py	(original)
+++ ./lib/taurus/qt/qtgui/table/taurusvaluestable.py	(refactored)
@@ -23,6 +23,7 @@
 ##
 #############################################################################
 
+from builtins import str
 __all__ = ["TaurusValuesTable"]
 
 __docformat__ = 'restructuredtext'
@@ -58,7 +59,7 @@
 
 class TaurusValuesIOTableModel(Qt.QAbstractTableModel):
     typeCastingMap = {'f': float, 'b': bool,
-                      'u': int, 'i': int, 'S': str, 'U': unicode}
+                      'u': int, 'i': int, 'S': str, 'U': str}
     # Need to have an array
 
     dataChanged = Qt.pyqtSignal('QModelIndex', 'QModelIndex')
@@ -265,11 +266,11 @@
         kind = table.dtype.kind
         if kind in 'SU':
             table = table.tolist()  # we want to allow the strings to be larger than the original ones
-            for (r, c), v in self._modifiedDict.items():
+            for (r, c), v in list(self._modifiedDict.items()):
                 table[r][c] = Qt.from_qvariant(v, str)
             table = numpy.array(table, dtype=str)
         else:
-            for k, v in self._modifiedDict.items():
+            for k, v in list(self._modifiedDict.items()):
                 if kind in ['f', 'i', 'u']:
                     units = self._parent.getCurrentUnits()
                     q = _value2Quantity(v, units)
--- ./lib/taurus/qt/qtgui/taurusgui/PermanentCustomPanelsDlg.py	(original)
+++ ./lib/taurus/qt/qtgui/taurusgui/PermanentCustomPanelsDlg.py	(refactored)
@@ -28,6 +28,7 @@
 PermanentCustomPanelDlg.py:
 """
 
+from builtins import object
 from taurus.external.qt import Qt
 
 
--- ./lib/taurus/qt/qtgui/taurusgui/appsettingswizard.py	(original)
+++ ./lib/taurus/qt/qtgui/taurusgui/appsettingswizard.py	(refactored)
@@ -34,6 +34,8 @@
 """
 from __future__ import print_function
 
+from builtins import str
+from builtins import range
 __all__ = ["AppSettingsWizard", "ExternalAppEditor"]
 
 import os
@@ -230,14 +232,14 @@
         self._projectDirBT.clicked.connect(self.onSelectDir)
 
     def onSelectDir(self):
-        dirname = unicode(Qt.QFileDialog.getExistingDirectory(
+        dirname = str(Qt.QFileDialog.getExistingDirectory(
             self, 'Choose the project directory', self._projectDirLE.text()))
         if not dirname:
             return
         self._projectDirLE.setText(dirname)
 
     def validatePage(self):
-        dirname = unicode(self._projectDirLE.text())
+        dirname = str(self._projectDirLE.text())
 
         if not os.path.exists(dirname):
             try:
@@ -280,7 +282,7 @@
         return True
 
     def _getProjectDir(self):
-        return unicode(self._projectDirLE.text())
+        return str(self._projectDirLE.text())
 
 
 class GeneralSettings(BasePage):
@@ -579,7 +581,7 @@
         fileNames = Qt.QFileDialog.getOpenFileNames(self, self.tr(
             "Open File"), pdir, self.tr("JDW (*.jdw );; All files (*)"))
         for fileName in fileNames:
-            fileName = unicode(fileName)
+            fileName = str(fileName)
             if fileName not in self._synoptics:
                 self._synoptics.append(fileName)
         self._refreshSynopticList()
@@ -1328,8 +1330,8 @@
                       datetime.datetime.now().isoformat())
         # copy files
         for i in range(self._substTable.rowCount()):
-            src = unicode(self._substTable.item(i, 0).text())
-            dst = os.path.join(install_dir, unicode(
+            src = str(self._substTable.item(i, 0).text())
+            dst = os.path.join(install_dir, str(
                 self._substTable.item(i, 1).text()))
             if os.path.normpath(src) != os.path.normpath(dst):
                 shutil.copy(src, dst)
@@ -1338,7 +1340,7 @@
         xmlcfgfilename = os.path.join(install_dir,
                                       self.wizard().getXmlConfigFileName())
         f = open(xmlcfgfilename, 'w')
-        f.write(unicode(self._xml.toPlainText()))
+        f.write(str(self._xml.toPlainText()))
         f.close()
         logfile.write('XML Config file created: "%s"\n' % xmlcfgfilename)
         # write python config file
@@ -1391,8 +1393,8 @@
         warnings = self.wizard().getProjectWarnings()
         if warnings:
             msg += '\n\nHowever, some fine-tuning may be needed. Please check the details:\n'
-            for short, long in warnings:
-                details += '- %s: %s\n\n' % (short, long)
+            for short, int in warnings:
+                details += '- %s: %s\n\n' % (short, int)
         logfile.write(msg + details)
         logfile.close()
         dlg = Qt.QMessageBox(Qt.QMessageBox.Information,
@@ -1482,7 +1484,7 @@
         root = etree.fromstring(xml)
 
         # print self.Pages
-        for pageNumber in range(len(self.Pages.keys())):
+        for pageNumber in range(len(list(self.Pages.keys()))):
             self.page(pageNumber).fromXml(root)
 
     def getXml(self):
@@ -1625,7 +1627,7 @@
                         long = ('The synoptic file "%s" references a file that '
                                 'has been copied to the project dir in order to make the project portable. '
                                 'Please edit "%s" and replace "%s" by "%s"') % (dst, dst, ref, refdst)
-                        self._projectWarnings.append((short, long))
+                        self._projectWarnings.append((short, int))
 
         # macroserver page
         if self.SARDANA_INSTALLED and self.__getitem__("macroServerName"):
--- ./lib/taurus/qt/qtgui/taurusgui/macrolistener.py	(original)
+++ ./lib/taurus/qt/qtgui/taurusgui/macrolistener.py	(refactored)
@@ -37,6 +37,7 @@
 
  # TODO: move to sardana.taurus
 
+from builtins import object
 __all__ = ['MacroBroker', 'DynamicPlotManager']
 __docformat__ = 'restructuredtext'
 
@@ -145,7 +146,7 @@
         plots1d = {}
         images = {}
 
-        for chname, chdata in channels.items():
+        for chname, chdata in list(channels.items()):
             ptype = chdata['plot_type']
             if ptype == PlotType.No:
                 continue
@@ -195,7 +196,7 @@
         '''
         from taurus.qt.qtgui.plot import TaurusTrend
         newpanels = []
-        for axes, plotables in trends1d.items():
+        for axes, plotables in list(trends1d.items()):
             if not axes:
                 continue
             if axes not in self._trends1d:
@@ -250,7 +251,7 @@
             raise
             return
 
-        for axes, plotables in trends2d.items():
+        for axes, plotables in list(trends2d.items()):
             for chname in plotables:
                 pname = u'Trend2D - %s' % chname
                 if pname in self._trends2d:
@@ -306,7 +307,7 @@
                       given (default), all the panels are removed.
         '''
         if names is None:
-            names = self._trends1d.values() + self._trends2d.values()
+            names = list(self._trends1d.values()) + list(self._trends2d.values())
             # TODO: do the same for other temporary panels
         for pname in names:
             self.removePanel(pname)
@@ -552,7 +553,7 @@
         door.command_inout('abort')
         # send stop/abort to all pools
         pools = door.macro_server.getElementsOfType('Pool')
-        for pool in pools.values():
+        for pool in list(pools.values()):
             self.info('Sending %s command to %s' % (cmd, pool.getFullName()))
             try:
                 pool.getObj().command_inout(cmd)
--- ./lib/taurus/qt/qtgui/taurusgui/paneldescriptionwizard.py	(original)
+++ ./lib/taurus/qt/qtgui/taurusgui/paneldescriptionwizard.py	(refactored)
@@ -24,6 +24,9 @@
 ###########################################################################
 
 from __future__ import print_function
+from builtins import str
+from builtins import zip
+from builtins import range
 __all__ = ["PanelDescriptionWizard"]
 """
 paneldescriptionwizard.py:
@@ -222,7 +225,7 @@
         Qt.QWizardPage.__init__(self, parent)
         TaurusBaseWidget.__init__(self, 'WidgetPage')
         if extraWidgets:
-            customWidgets, customWidgetScreenshots = zip(*extraWidgets)
+            customWidgets, customWidgetScreenshots = list(zip(*extraWidgets))
             pixmaps = {}
             for k, s in extraWidgets:
                 if s is None:
@@ -462,7 +465,7 @@
 
 class CommTableModel(Qt.QAbstractTableModel):
     NUMCOLS = 3
-    UID, R, W = range(NUMCOLS)
+    UID, R, W = list(range(NUMCOLS))
 
     dataChanged = Qt.pyqtSignal(int, int)
 
@@ -555,7 +558,7 @@
 
 class CommItemDelegate(Qt.QStyledItemDelegate):
     NUMCOLS = 3
-    UID, R, W = range(NUMCOLS)
+    UID, R, W = list(range(NUMCOLS))
 
     def __init__(self, parent=None, widget=None, sdm=None):
         super(CommItemDelegate, self).__init__(parent)
--- ./lib/taurus/qt/qtgui/taurusgui/taurusgui.py	(original)
+++ ./lib/taurus/qt/qtgui/taurusgui/taurusgui.py	(refactored)
@@ -25,6 +25,8 @@
 
 """This package provides the TaurusGui class"""
 
+from builtins import str
+from past.builtins import basestring
 __all__ = ["DockWidgetPanel", "TaurusGui"]
 
 __docformat__ = 'restructuredtext'
@@ -91,7 +93,7 @@
         self.onInstrumentChanged(self.ui.instrumentCB.currentText())
 
     def onInstrumentChanged(self, instrumentname):
-        instrumentname = unicode(instrumentname)
+        instrumentname = str(instrumentname)
         panelname = self.associations.get(instrumentname)
         if panelname is None:
             self.ui.panelCB.setCurrentIndex(0)
@@ -104,10 +106,10 @@
         role = self.ui.buttonBox.buttonRole(button)
         if role in (Qt.QDialogButtonBox.AcceptRole, Qt.QDialogButtonBox.ApplyRole):
             if self.ui.panelCB.currentIndex() > 0:
-                panelname = unicode(self.ui.panelCB.currentText())
+                panelname = str(self.ui.panelCB.currentText())
             else:
                 panelname = None
-            instrumentname = unicode(self.ui.instrumentCB.currentText())
+            instrumentname = str(self.ui.instrumentCB.currentText())
             self.associations[instrumentname] = panelname
             self.parent().setInstrumentAssociation(instrumentname, panelname)
 
@@ -128,7 +130,7 @@
         self.setWidget(widget)
         # self._widget = self.widget()  #keep a pointer that may change if the
         # widget changes
-        name = unicode(name)
+        name = str(name)
         self.setWindowTitle(name)
         self.setObjectName(name)
         self._custom = False
@@ -342,7 +344,7 @@
         except:
             pass
         TaurusMainWindow.closeEvent(self, event)
-        for n, panel in self.__panels.items():
+        for n, panel in list(self.__panels.items()):
             panel.closeEvent(event)
             panel.widget().closeEvent(event)
             if not event.isAccepted():
@@ -361,7 +363,7 @@
         permanent = (panelsmenu == self.__permPanelsMenu)
         panelsmenu.clear()
         panelnames = sorted(
-            [n for n, p in self.__panels.items() if (p.isPermanent() == permanent)])
+            [n for n, p in list(self.__panels.items()) if (p.isPermanent() == permanent)])
         for name in panelnames:
             panelsmenu.addAction(self.__panels[name].toggleViewAction())
 
@@ -500,7 +502,7 @@
                      removed
                      If None given, the user will be prompted
         '''
-        apps = self.__external_app.keys() + self.__permanent_ext_apps
+        apps = list(self.__external_app.keys()) + self.__permanent_ext_apps
         if name is None:
             items = sorted(apps)
             msg1 = "Remove External application"
@@ -510,13 +512,13 @@
                                                False)
             if not ok:
                 return
-        name = unicode(name)
+        name = str(name)
         if name not in apps:
             msg = ('Cannot remove the external application "%s"'
                    ' (not found)' % name)
             self.debug(msg)
             return
-        if name in self.__external_app.keys():
+        if name in list(self.__external_app.keys()):
             self.__external_app.pop(name)
         else:
             self.__permanent_ext_apps.remove(name)
@@ -570,12 +572,12 @@
         '''
         if name is None:
             items = sorted(
-                [n for n, p in self.__panels.iteritems() if p.isCustom()])
+                [n for n, p in self.__panels.items() if p.isCustom()])
             name, ok = Qt.QInputDialog.getItem(self, "Remove Panel",
                                                "Panel to be removed (only custom panels can be removed).\n Important: you may want to save the perspective afterwards,\n and maybe remove the panel from other perspectives as well", items, 0, False)
             if not ok:
                 return
-        name = unicode(name)
+        name = str(name)
         if name not in self.__panels:
             self.debug('Cannot remove panel "%s" (not found)' % name)
             return
@@ -626,7 +628,7 @@
                 'Deprecation warning: please note that the "area" argument is deprecated. See TaurusGui.createPanel doc')
             floating = not(floating)
 
-        name = unicode(name)
+        name = str(name)
         if name in self.__panels:
             self.info('Panel with name "%s" already exists. Reusing.' % name)
             return self.__panels[name]
@@ -636,7 +638,7 @@
         # we will only place panels in this area
         self.addDockWidget(Qt.Qt.TopDockWidgetArea, panel)
         if len(self.__panels) != 0:
-            self.tabifyDockWidget(self.__panels.values()[-1], panel)
+            self.tabifyDockWidget(list(self.__panels.values())[-1], panel)
 
         panel.setFloating(floating)
 
@@ -674,14 +676,14 @@
 
         :return: (DockWidgetPanel)
         '''
-        return self.__panels[unicode(name)]
+        return self.__panels[str(name)]
 
     def getPanelNames(self):
         '''returns the names of existing panels
 
         :return: (list<str>)
         '''
-        return copy.deepcopy(self.__panels.keys())
+        return copy.deepcopy(list(self.__panels.keys()))
 
     def _setPermanentExternalApps(self, permExternalApps):
         '''creates empty panels for restoring custom panels.
@@ -717,7 +719,7 @@
 
         :return: (list<str>)
         '''
-        return [n for n, p in self.__panels.iteritems() if (p.isCustom() and p.isPermanent())]
+        return [n for n, p in self.__panels.items() if (p.isCustom() and p.isPermanent())]
 
     def updatePermanentCustomPanels(self, showAlways=True):
         '''
@@ -729,7 +731,7 @@
         # check if there are some newly created panels that may be made
         # permanent
         perm = self._getPermanentCustomPanels()
-        temp = [n for n, p in self.__panels.iteritems() if (
+        temp = [n for n, p in self.__panels.items() if (
             p.isCustom() and not p.isPermanent())]
         if len(temp) > 0 or showAlways:
             dlg = QDoubleListDlg(winTitle='Stored panels',
@@ -765,7 +767,7 @@
                                  mainLabel=msg,
                                  label1='Temporary (to be discarded)',
                                  label2='Permanent (to be stored)',
-                                 list1=self.__external_app.keys(),
+                                 list1=list(self.__external_app.keys()),
                                  list2=self.__permanent_ext_apps)
             result = dlg.exec_()
             if result == Qt.QDialog.Accepted:
@@ -888,7 +890,7 @@
             if result == Qt.QMessageBox.Abort:
                 sys.exit()
             return []
-        for i in instruments.values():
+        for i in list(instruments.values()):
             i_name = i.full_name
             #i_name, i_unknown, i_type, i_pools = i.split()
             i_view = PanelDescription(
@@ -896,12 +898,12 @@
             instrument_dict[i_name] = i_view
 
         from operator import attrgetter
-        pool_elements = sorted(ms.getElementsWithInterface(
-            'Moveable').values(), key=attrgetter('name'))
-        pool_elements += sorted(ms.getElementsWithInterface(
-            'ExpChannel').values(), key=attrgetter('name'))
-        pool_elements += sorted(ms.getElementsWithInterface(
-            'IORegister').values(), key=attrgetter('name'))
+        pool_elements = sorted(list(ms.getElementsWithInterface(
+            'Moveable').values()), key=attrgetter('name'))
+        pool_elements += sorted(list(ms.getElementsWithInterface(
+            'ExpChannel').values()), key=attrgetter('name'))
+        pool_elements += sorted(list(ms.getElementsWithInterface(
+            'IORegister').values()), key=attrgetter('name'))
         for elem in pool_elements:
             instrument = elem.instrument
             if instrument:
@@ -915,7 +917,7 @@
                 # -----------------------------------------------------------
                 instrument_dict[i_name].model.append(e_name)
         # filter out empty panels
-        ret = [instrument for instrument in instrument_dict.values()
+        ret = [instrument for instrument in list(instrument_dict.values())
                if len(instrument.model) > 0]
         return ret
 
@@ -1332,7 +1334,7 @@
             dwfeat = Qt.QDockWidget.AllDockWidgetFeatures
         else:
             dwfeat = Qt.QDockWidget.NoDockWidgetFeatures
-        for panel in self.__panels.values():
+        for panel in list(self.__panels.values()):
             panel.toggleViewAction().setEnabled(modifiable)
             panel.setFeatures(dwfeat)
         for action in (self.newPanelAction, self.showAllPanelsAction,
@@ -1355,12 +1357,12 @@
 
     def hideAllPanels(self):
         '''hides all current panels'''
-        for panel in self.__panels.itervalues():
+        for panel in self.__panels.values():
             panel.hide()
 
     def showAllPanels(self):
         '''shows all current panels'''
-        for panel in self.__panels.itervalues():
+        for panel in self.__panels.values():
             panel.show()
 
     def onShowAssociationDialog(self):
@@ -1391,7 +1393,7 @@
                           panel or None to remove the association
                           for this instrument.
         '''
-        instrumentname = unicode(instrumentname)
+        instrumentname = str(instrumentname)
         # remove a previous association if it exists
         oldpanelname = self.__instrumentToPanelMap.get(instrumentname, None)
         self.__panelToInstrumentMap.pop(oldpanelname, None)
@@ -1426,12 +1428,12 @@
         else:
             self.__instrumentToPanelMap.update(copy.deepcopy(associationsdict))
         self.__panelToInstrumentMap = {}
-        for k, v in self.__instrumentToPanelMap.iteritems():
+        for k, v in self.__instrumentToPanelMap.items():
             self.__panelToInstrumentMap[v] = k
 
     def _onPanelVisibilityChanged(self, visible):
         if visible:
-            panelname = unicode(self.sender().objectName())
+            panelname = str(self.sender().objectName())
             instrumentname = self.__panelToInstrumentMap.get(panelname)
             if instrumentname is not None:
                 self.SelectedInstrument.emit(instrumentname)
@@ -1442,7 +1444,7 @@
 
         :param instrumentname: (str) The name that identifies the instrument.
         '''
-        instrumentname = unicode(instrumentname)
+        instrumentname = str(instrumentname)
         panelname = self.getInstrumentAssociation(instrumentname)
         self.setFocusToPanel(panelname)
 
@@ -1452,7 +1454,7 @@
         :param panelname: (str) The name that identifies the panel.
                                This name must be unique within the panels in the GUI.
         '''
-        panelname = unicode(panelname)
+        panelname = str(panelname)
         try:
             panel = self.__panels[panelname]
             panel.show()
@@ -1490,9 +1492,9 @@
         raise DeprecationWarning(
             'findPanelsInArea is no longer supported (now all panels reside in the same DockWidget Area)')
         if area == 'FLOATING':
-            return [p for p in self.__panels.values() if p.isFloating()]
+            return [p for p in list(self.__panels.values()) if p.isFloating()]
         else:
-            return [p for p in self.__panels.values() if self.dockWidgetArea(p) == area]
+            return [p for p in list(self.__panels.values()) if self.dockWidgetArea(p) == area]
 
     @classmethod
     def getQtDesignerPluginInfo(cls):
@@ -1530,7 +1532,7 @@
         dlg = QDoubleListDlg(winTitle='Export Panels to XML',
                              mainLabel='Select which of the custom panels you want to export as xml configuration',
                              label1='Not Exported', label2='Exported',
-                             list1=[n for n, p in self.__panels.iteritems() if p.isCustom()], list2=[])
+                             list1=[n for n, p in self.__panels.items() if p.isCustom()], list2=[])
         result = dlg.exec_()
         if result != Qt.QDialog.Accepted:
             return
--- ./lib/taurus/qt/qtgui/taurusgui/utils.py	(original)
+++ ./lib/taurus/qt/qtgui/taurusgui/utils.py	(refactored)
@@ -26,6 +26,9 @@
 """This configuration contains base modules and classes that may be used
 by specific TaurusGui-based GUIs"""
 
+from builtins import str
+from past.builtins import basestring
+from builtins import object
 __docformat__ = 'restructuredtext'
 
 import os
@@ -38,7 +41,7 @@
 # this is here only for backwards compatibility. It should not be used at all
 
 
-class Qt_Qt:
+class Qt_Qt(object):
     LeftDockWidgetArea = 1
     RightDockWidgetArea = 2
     BottomDockWidgetArea = 3
@@ -223,9 +226,9 @@
             w.setModel(self.model)
         # connect (if an sdm is given)
         if sdm is not None:
-            for dataUID, signalname in self.sharedDataWrite.iteritems():
+            for dataUID, signalname in self.sharedDataWrite.items():
                 sdm.connectWriter(dataUID, w, signalname)
-            for dataUID, slotname in self.sharedDataRead.iteritems():
+            for dataUID, slotname in self.sharedDataRead.items():
                 sdm.connectReader(dataUID, getattr(w, slotname))
         # set the name
         w.name = self.name
@@ -250,12 +253,12 @@
         floating.text = str(self._floating)
 
         sharedDataWrite = etree.SubElement(root, "sharedDataWrite")
-        for k, v in self._sharedDataWrite.iteritems():
+        for k, v in self._sharedDataWrite.items():
             item = etree.SubElement(
                 sharedDataWrite, "item", datauid=k, signalName=v)
 
         sharedDataRead = etree.SubElement(root, "sharedDataRead")
-        for k, v in self._sharedDataRead.iteritems():
+        for k, v in self._sharedDataRead.items():
             item = etree.SubElement(
                 sharedDataRead, "item", datauid=k, slotName=v)
 
--- ./lib/taurus/qt/qtgui/test/base.py	(original)
+++ ./lib/taurus/qt/qtgui/test/base.py	(refactored)
@@ -25,6 +25,9 @@
 
 """Utilities for creating generic tests for Taurus widgets"""
 
+from builtins import zip
+from builtins import range
+from builtins import object
 import time
 import taurus.core
 import unittest
@@ -84,7 +87,7 @@
         self.assertTrue(deps <= maximum, msg)
 
     def processEvents(self, repetitions=1, sleep=0):
-         for i in xrange(repetitions):
+         for i in range(repetitions):
             time.sleep(sleep)
             self._app.processEvents()
 
--- ./lib/taurus/qt/qtgui/tree/qtree.py	(original)
+++ ./lib/taurus/qt/qtgui/tree/qtree.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides base tree widget"""
 
+from builtins import range
 __all__ = ["QBaseTreeWidget"]
 
 __docformat__ = 'restructuredtext'
--- ./lib/taurus/qt/qtgui/tree/taurusdevicetree.py	(original)
+++ ./lib/taurus/qt/qtgui/tree/taurusdevicetree.py	(refactored)
@@ -34,6 +34,11 @@
 # Taurusdbtree
 
 # ,"SearchEdit"] #"TaurusTreeNode"]
+from builtins import next
+from builtins import str
+from builtins import range
+from past.builtins import basestring
+from builtins import object
 __all__ = ["TaurusDevTree", "TaurusSearchTree", "TaurusDevTreeOptions"]
 
 import time
@@ -194,11 +199,11 @@
             node = self.getNode()
         try:
             name, url = self.getNodeText(node), ''
-            for k, v in self.getIconMap().items():
+            for k, v in list(self.getIconMap().items()):
                 if re.match(k.lower(), name.lower()):
                     url = v
             if not url:
-                for k, v in self.getIconMap().items():
+                for k, v in list(self.getIconMap().items()):
                     if k.lower() in name.lower():
                         url = v
             # if name.count('/')==2:
@@ -640,10 +645,10 @@
                 dct = self.getTangoDict(filters)
             else:  # if isMap(filters):
                 self.setWindowTitle('TaurusDevTree:%s' %
-                                    ','.join(filters.keys()))
+                                    ','.join(list(filters.keys())))
 
                 def expand_dict(d):
-                    return [x for v in d.values() for x in (expand_dict(v) if hasattr(v, 'values') else (v,))]
+                    return [x for v in list(d.values()) for x in (expand_dict(v) if hasattr(v, 'values') else (v,))]
                 targets = [t.upper() for t in get_matching_devices(
                     ['*%s*' % f if '*' not in f else f for f in expand_dict(filters)])]
 
@@ -651,7 +656,7 @@
                     return dict.fromkeys(t for t in targets if matchCl(f, t))
 
                 def expand_filter(f):
-                    return dict((k, expand_filter(v) if hasattr(v, 'values') else get_devs(v)) for k, v in f.items() if v)
+                    return dict((k, expand_filter(v) if hasattr(v, 'values') else get_devs(v)) for k, v in list(f.items()) if v)
                 dct = expand_filter(filters)
             # self.Loader.next([self.setTree,dct,True])
             self.setTree(dct, clear=True)
@@ -800,7 +805,7 @@
                 if alias:
                     self.trace('Got aliases for %s: %s' % (aname, alias))
                     [setattr(natt, 'AttributeAlias', v)
-                     for k, v in alias.items() if k in aname.lower()]
+                     for k, v in list(alias.items()) if k in aname.lower()]
                 else:
                     natt.AttributeAlias = aname.split()[0].strip()
         node.setExpanded(True)
@@ -825,7 +830,7 @@
         return self.item_index[key]
 
     def getNodeList(self):
-        return self.item_index.keys()
+        return list(self.item_index.keys())
 
     def getMatchingNodes(self, regexp, limit=0, all=False, exclude=None):
         """ It returns all nodes matching the given expression. """
@@ -838,7 +843,7 @@
             if node is not None:
                 return [node]
         regexp = re.compile(extend_regexp(regexp))
-        for k, node in self.item_index.iteritems():
+        for k, node in self.item_index.items():
             nname = self.getNodeText(node, full=True).lower()
             if (regexp.match(k) or regexp.match(nname)) and \
                     (not exclude or not any(re.match(x.lower(), y) for x in exclude for y in (k.lower(), nname))):
@@ -869,7 +874,7 @@
     def unpackChildren(self):
         """ removes all nodes from the tree and returns them in a list, used for resorting """
         allChildren = []
-        nodes = self.getAllNodes().values()
+        nodes = list(self.getAllNodes().values())
 
         for node in nodes:
             allChildren.extend(node.takeChildren())
@@ -1021,7 +1026,7 @@
 
         sorter = lambda k, ks=[re.compile(c) for c in order]: str(
             next((i for i, r in enumerate(ks) if r.match(k.lower())))) + str(k)
-        for c, it in sorted(allChildren.items(), key=lambda k: sorter(k[0])):
+        for c, it in sorted(list(allChildren.items()), key=lambda k: sorter(k[0])):
             self.debug('tree.sortCustom(%s): %s inserted at %d' %
                        (order, it.text(0), self.topLevelItemCount()))
             self.insertTopLevelItem(self.topLevelItemCount(), it)
@@ -1062,12 +1067,12 @@
         if not isinstance(dct, dict):
             dct = dict.fromkeys(dct, '')
         nodes = self.getAllNodes()
-        for name, node in nodes.iteritems():
+        for name, node in nodes.items():
             name = str(name).split()[0]
             if node.isHidden():
                 continue
             if regexps:
-                matches = [v for k, v in dct.items() if re.match(
+                matches = [v for k, v in list(dct.items()) if re.match(
                     k.lower(), name.lower())]
                 if matches:
                     update_node(node, name, {name: matches[0]})
@@ -1286,7 +1291,7 @@
 
         if hasattr(node, 'ContextMenu'):
             last_was_separator = True
-            for t in (type(node.ContextMenu) is dict and node.ContextMenu.items() or node.ContextMenu):
+            for t in (type(node.ContextMenu) is dict and list(node.ContextMenu.items()) or node.ContextMenu):
                 try:
                     k, action = t
                     if k:
@@ -1307,7 +1312,7 @@
             expert = menu.addMenu('Expert')
             # expert.addSeparator()
             last_was_separator = True
-            for t in (type(node.ContextMenu) is dict and node.ExpertMenu.items() or node.ExpertMenu):
+            for t in (type(node.ContextMenu) is dict and list(node.ExpertMenu.items()) or node.ExpertMenu):
                 try:
                     k, action = t
                     if k:
@@ -1660,7 +1665,7 @@
         self.layout().addWidget(self.tree)
         self.registerConfigDelegate(self.tree)
         # Slot forwarding ...
-        for k in TaurusDevTree.__dict__.keys():
+        for k in list(TaurusDevTree.__dict__.keys()):
             # if k in ['__init__','defineStyle']: continue
             if k not in self.__slots__:
                 continue
--- ./lib/taurus/qt/qtgui/util/taurusaction.py	(original)
+++ ./lib/taurus/qt/qtgui/util/taurusaction.py	(refactored)
@@ -26,6 +26,8 @@
 """This module is designed to provide a library of taurus Qt actions"""
 from __future__ import absolute_import
 
+from builtins import str
+from past.builtins import basestring
 __all__ = ["ExternalAppAction",
            "TaurusMenu",
            "TaurusAction",
@@ -131,10 +133,10 @@
             else:
                 return False
         except OSError:
-            err = "Error launching %s" % unicode(self.text())
+            err = "Error launching %s" % str(self.text())
             msg = "Cannot launch application:\n" + \
                   " ".join(self.__cmdargs) + \
-                  "\nHint: Check that %s is installed and in the path" % unicode(
+                  "\nHint: Check that %s is installed and in the path" % str(
                       self.text())
             if self.interactive:
                 Qt.QMessageBox.warning(self.parentWidget(), err, msg)
--- ./lib/taurus/qt/qtgui/util/taurusactionfactory.py	(original)
+++ ./lib/taurus/qt/qtgui/util/taurusactionfactory.py	(refactored)
@@ -130,7 +130,7 @@
             action.toggled.connect(toggled)
             action.setCheckable(True)
         if icon is not None:
-            if isinstance(icon, (str, unicode)):
+            if isinstance(icon, (str, str)):
                 icon = Qt.QIcon.fromTheme(icon)
             action.setIcon(icon)
         if shortcut is not None:
--- ./lib/taurus/qt/qtgui/util/tauruswidgetfactory.py	(original)
+++ ./lib/taurus/qt/qtgui/util/tauruswidgetfactory.py	(refactored)
@@ -194,19 +194,19 @@
         return self._taurus_widgets
 
     def getWidgetClassNames(self):
-        return self._qt_widgets.keys()
+        return list(self._qt_widgets.keys())
 
     def getWidgetClasses(self):
-        return [klass for mod_name, klass in self._qt_widgets.values()]
+        return [klass for mod_name, klass in list(self._qt_widgets.values())]
 
     def getWidgetClass(self, name):
         return self._qt_widgets[name][1]
 
     def getTaurusWidgetClassNames(self):
-        return self._taurus_widgets.keys()
+        return list(self._taurus_widgets.keys())
 
     def getTaurusWidgetClasses(self):
-        return [klass for mod_name, klass in self._taurus_widgets.values()]
+        return [klass for mod_name, klass in list(self._taurus_widgets.values())]
 
     def getTaurusWidgetClass(self, name):
         return self._taurus_widgets.get(name)[1]
--- ./lib/taurus/qt/qtgui/util/tauruswidgettree.py	(original)
+++ ./lib/taurus/qt/qtgui/util/tauruswidgettree.py	(refactored)
@@ -26,6 +26,7 @@
 """
 """
 
+from builtins import str
 __all__ = ["QObjectRepresentation", "get_qobject_tree", "get_qobject_tree_str",
            "TreeQObjectModel", "TreeQObjectWidget"]
 
--- ./lib/taurus/qt/qtgui/util/ui.py	(original)
+++ ./lib/taurus/qt/qtgui/util/ui.py	(refactored)
@@ -25,6 +25,7 @@
 
 """utilities to load ui files for widgets"""
 
+from builtins import object
 __all__ = ["loadUi",
            "UILoadable",
            ]
--- ./lib/taurus/test/base.py	(original)
+++ ./lib/taurus/test/base.py	(refactored)
@@ -100,7 +100,7 @@
 
     if test_method_doc is None:
         argsrep = ', '.join(['%s=%s' % (k, repr(v))
-                             for k, v in helper_kwargs.items()])
+                             for k, v in list(helper_kwargs.items())])
         if tested_name:
             test_method_doc = 'Testing %s with %s(%s)' % (tested_name,
                                                           helper_name, argsrep)
--- ./lib/taurus/test/fuzzytest.py	(original)
+++ ./lib/taurus/test/fuzzytest.py	(refactored)
@@ -25,8 +25,10 @@
 
 '''Utility functions to deal with non-ideal (fuzzy) tests'''
 from __future__ import print_function
+from __future__ import division
 
 
+from past.utils import old_div
 def loopTest(testname, maxtries=100, maxfails=10):
     '''Run a test `maxtries` times or until it fails `maxfails` times and
     report the number of tries and failures.
@@ -107,11 +109,11 @@
     else:
         tries, fails = loopSubprocess(test, maxtries=maxtries,
                                       maxfails=maxfails, **kwargs)
-    r = float(fails) / tries
-    dr = numpy.sqrt(fails) / tries
+    r = old_div(float(fails), tries)
+    dr = old_div(numpy.sqrt(fails), tries)
     print('Failure rate = %g +/- %g  (%i/%i)' % (r, dr, fails, tries))
     # calculating n using p-value=1% and failure rate with -1 sigma
-    n = numpy.ceil(numpy.log(.01) / numpy.log(1 - (r - dr)))
+    n = numpy.ceil(old_div(numpy.log(.01), numpy.log(1 - (r - dr))))
     print(('Number of consecutive times that the test should be passed ' +
            'to have a confidence>99%% that the bug is fixed: %g') % n)
     return r, dr, n
--- ./lib/taurus/test/moduleexplorer.py	(original)
+++ ./lib/taurus/test/moduleexplorer.py	(refactored)
@@ -27,6 +27,7 @@
 '''Utility code for returning info about a module'''
 from __future__ import print_function
 
+from builtins import object
 import sys
 import os
 import inspect
@@ -175,7 +176,7 @@
                 ret = [(mname, el) for el in info[key]]
         except KeyError:
             return []
-        for sminfo in info['submodules'].itervalues():
+        for sminfo in info['submodules'].values():
             ret += ModuleExplorer.getAll(sminfo, key)
         return ret
 
--- ./lib/taurus/test/test_import.py	(original)
+++ ./lib/taurus/test/test_import.py	(refactored)
@@ -26,6 +26,7 @@
 """Taurus import tests"""
 from __future__ import absolute_import
 
+from builtins import zip
 import unittest
 
 
