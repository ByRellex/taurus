--- doc/auto_rst4api.py	(original)
+++ doc/auto_rst4api.py	(refactored)
@@ -26,6 +26,7 @@
 
 ''' Creates a tree of dirs and restructured text stub files for documenting
 the API of a python module with sphinx'''
+from __future__ import print_function
 
 import sys
 import os
@@ -93,10 +94,10 @@
                     fullname = os.path.join(dirpath, f)
                     try:
                         if self._isautogeneratedfile(fullname):
-                            print "Removing %s" % fullname
+                            print("Removing %s" % fullname)
                             os.remove(fullname)
-                    except Exception, e:
-                        print 'Error accessing %s:%s' % (fullname, repr(e))
+                    except Exception as e:
+                        print('Error accessing %s:%s' % (fullname, repr(e)))
 
     def createClassIndex(self, info, ofname):
         '''
@@ -114,17 +115,17 @@
         classes = ['.'.join((m, c))
                    for m, c in classes]  # make a full classname
         if self.verbose:
-            print 'creating "%s" ...' % ofname,
+            print('creating "%s" ...' % ofname, end=' ')
         if not os.path.exists(ofname) or (self.overwrite_old and self._isautogeneratedfile(ofname)):
             text = self.classindextemplate.render(info=info, classes=classes)
             f = open(ofname, "w")
             f.write('\n'.join((self.AUTOGEN_SIGNATURE, self.AUTOGEN_MESSAGE, text)))
             f.close()
             if self.verbose:
-                print ' ok.'
+                print(' ok.')
         else:
             if self.verbose:
-                print ' skipping (file already exists)'
+                print(' skipping (file already exists)')
 
     def createStubs(self, info, docparentpath):
         '''creates rst stub files for modules and classes according to the
@@ -139,26 +140,26 @@
         # create the module doc dir if it didn't exist
         absdocpath = os.path.join(docparentpath, info['basemodulename'])
         if not os.path.exists(absdocpath):
-            os.makedirs(absdocpath, mode=0755)
+            os.makedirs(absdocpath, mode=0o755)
         # create module index stub in doc parent dir
         ofname = os.path.join(docparentpath, "%s.rst" % info['basemodulename'])
         if self.verbose:
-            print 'creating "%s" ...' % ofname,
+            print('creating "%s" ...' % ofname, end=' ')
         if not os.path.exists(ofname) or (self.overwrite_old and self._isautogeneratedfile(ofname)):
             text = self.moduletemplate.render(info=info)
             f = open(ofname, "w")
             f.write('\n'.join((self.AUTOGEN_SIGNATURE, self.AUTOGEN_MESSAGE, text)))
             f.close()
             if self.verbose:
-                print ' ok.'
+                print(' ok.')
         else:
             if self.verbose:
-                print ' skipping (file already exists)'
+                print(' skipping (file already exists)')
         # create class stubs
         for name in info['localclassnames']:
             ofname = os.path.join(absdocpath, "_%s.rst" % name)
             if self.verbose:
-                print 'creating "%s" ...' % ofname,
+                print('creating "%s" ...' % ofname, end=' ')
             if not os.path.exists(ofname) or (self.overwrite_old and self._isautogeneratedfile(ofname)):
                 text = self.classtemplate.render(info=info, classname=name)
                 f = open(ofname, "w")
@@ -166,10 +167,10 @@
                     '\n'.join((self.AUTOGEN_SIGNATURE, self.AUTOGEN_MESSAGE, text)))
                 f.close()
                 if self.verbose:
-                    print ' ok.'
+                    print(' ok.')
             else:
                 if self.verbose:
-                    print ' skipping (file already exists)'
+                    print(' skipping (file already exists)')
         # recurse for submodules
         for sminfo in info['submodules'].itervalues():
             self.createStubs(sminfo, absdocpath)
@@ -191,7 +192,7 @@
         :return: (list<str>) list of warning messages
         '''
         if self.verbose:
-            print "\nDocumenting %s..." % modulename
+            print("\nDocumenting %s..." % modulename)
         if exclude_patterns is None:
             exclude_patterns = self.exclude_patterns
         moduleinfo, w = ModuleExplorer.explore(modulename,
@@ -209,16 +210,16 @@
 def main():
     import sys
     if len(sys.argv) != 3:
-        print 'Usage:\n\t%s modulename docpreffix\n\n' % sys.argv[0]
+        print('Usage:\n\t%s modulename docpreffix\n\n' % sys.argv[0])
         sys.exit(1)
     modulename, docparentpath = sys.argv[1:]
     creator = Auto_rst4API_Creator(verbose=True)
     r = creator.documentModule(
         modulename, docparentpath, exclude_patterns=['.*\.test'])
-    print '\n\n' + '*' * 50
-    print "Auto Creation of API docs for %s Finished with %i warnings:" % (modulename, len(r))
-    print '\n'.join(r)
-    print '*' * 50 + '\n'
+    print('\n\n' + '*' * 50)
+    print("Auto Creation of API docs for %s Finished with %i warnings:" % (modulename, len(r)))
+    print('\n'.join(r))
+    print('*' * 50 + '\n')
 
 if __name__ == "__main__":
     main()
--- doc/buildmock.py	(original)
+++ doc/buildmock.py	(refactored)
@@ -36,6 +36,7 @@
 the API of a python module with sphinx'''
 
 from __future__ import with_statement
+from __future__ import print_function
 
 import os
 import sys
@@ -268,11 +269,11 @@
             continue
         # check if the module is indeed importable
         try:
-            print name
+            print(name)
             _import(name)
             full_module_names.append(name)
         except:
-            print '!'
+            print('!')
             pass
     return full_module_names
 
@@ -338,7 +339,7 @@
     if zfile:
         _zipdir(outdir, zfile)  # compress the dir into the zip file
         shutil.rmtree(outdir)  # delete the dir
-    print '\nMocks written in %s' % output
+    print('\nMocks written in %s' % output)
 
 
 if __name__ == "__main__":
--- doc/source/conf.py	(original)
+++ doc/source/conf.py	(refactored)
@@ -23,6 +23,7 @@
 # along with Taurus.  If not, see <http://www.gnu.org/licenses/>.
 ##
 ##############################################################################
+from __future__ import print_function
 import sys
 import os
 
--- doc/source/devel/examples/parentmodel_issue_demo.py	(original)
+++ doc/source/devel/examples/parentmodel_issue_demo.py	(refactored)
@@ -8,6 +8,7 @@
 call recheckTaurusParent for all designer created widgets that use TaurusParentModel.
 You can do it right after calling the setupUi method.
 '''
+from __future__ import print_function
 
 from taurus.external.qt import Qt
 from taurus.qt.qtgui.container import TaurusWidget
@@ -60,8 +61,8 @@
 # c.recheckTaurusParent()
 
 p.setModel('sys/tg_test/1/state')
-print 'p model:', p.getModelName()
-print 'c model:', c.getModelName()
+print('p model:', p.getModelName())
+print('c model:', c.getModelName())
 
 
 p.show()
--- doc/source/devel/examples/pyqwt_issue_test.py	(original)
+++ doc/source/devel/examples/pyqwt_issue_test.py	(refactored)
@@ -15,6 +15,7 @@
 https://bugs.launchpad.net/ubuntu/+source/pyqwt5/+bug/672509
 http://www.esrf.eu/mail_archives/tango/archive/msg04025.html
 '''
+from __future__ import print_function
 
 from PyQt4 import Qt, Qwt5
 
@@ -39,14 +40,14 @@
     def __init__(self, parent=None):
         Qwt5.QwtPlot.__init__(self, parent)
         self.setAxisScaleDraw(Qwt5.QwtPlot.xBottom, MyScaleDrawSafe())
-        print "Replotting with MyScaleDrawSafe:..."
+        print("Replotting with MyScaleDrawSafe:...")
         self.replot()
-        print "ok"
+        print("ok")
         self.setAxisScaleDraw(Qwt5.QwtPlot.xBottom, MyScaleDrawDanger())
-        print "Replotting with MyScaleDrawDanger (if it crashes now you are affected by the bug) :..."
+        print("Replotting with MyScaleDrawDanger (if it crashes now you are affected by the bug) :...")
         self.replot()
-        print "SAFE!!!"
-        print "if this is printed, the sip/PyQwt bug does not affect you"
+        print("SAFE!!!")
+        print("if this is printed, the sip/PyQwt bug does not affect you")
 
 app = Qt.QApplication([])
 p = MyPlot()
--- doc/source/devel/examples/TaurusTest.py	(original)
+++ doc/source/devel/examples/TaurusTest.py	(refactored)
@@ -1,3 +1,4 @@
+from __future__ import print_function
 import PyTango
 import sys
 import math
@@ -10,10 +11,10 @@
         TaurusTest.init_device(self)
 
     def delete_device(self):
-        print "[Device delete_device method] for device", self.get_name()
+        print("[Device delete_device method] for device", self.get_name())
 
     def init_device(self):
-        print "In ", self.get_name(), "::init_device()"
+        print("In ", self.get_name(), "::init_device()")
         self.set_state(PyTango.DevState.ON)
         self.get_device_properties(self.get_device_class())
         self._position = 50.0
@@ -24,10 +25,10 @@
         self._curve = [math.sin(x) for x in self._abscissas]
 
     def always_executed_hook(self):
-        print "In ", self.get_name(), "::always_excuted_hook()"
+        print("In ", self.get_name(), "::always_excuted_hook()")
 
     def read_attr_hardware(self, data):
-        print "In ", self.get_name(), "::read_attr_hardware()"
+        print("In ", self.get_name(), "::read_attr_hardware()")
 
     def read_Position(self, attr):
         attr.set_value(self._position)
@@ -68,7 +69,7 @@
         self._curve = attr.get_write_value()
 
     def create_device_cb(self, device_name):
-        print "About to create device", device_name
+        print("About to create device", device_name)
 
     def CreateTaurusTestDevice(self, device_name):
         klass = self.get_device_class()
@@ -173,7 +174,7 @@
     def __init__(self, name):
         PyTango.DeviceClass.__init__(self, name)
         self.set_type(name)
-        print "In TaurusTestClass  constructor"
+        print("In TaurusTestClass  constructor")
 
 
 if __name__ == '__main__':
@@ -185,7 +186,7 @@
         U.server_init()
         U.server_run()
 
-    except PyTango.DevFailed, e:
-        print '-------> Received a DevFailed exception:', e
-    except Exception, e:
-        print '-------> An unforeseen exception occured....', e
+    except PyTango.DevFailed as e:
+        print('-------> Received a DevFailed exception:', e)
+    except Exception as e:
+        print('-------> An unforeseen exception occured....', e)
--- doc/source/sphinxext/taurusextension.py	(original)
+++ doc/source/sphinxext/taurusextension.py	(refactored)
@@ -24,6 +24,7 @@
 ##############################################################################
 
 """helper methods for taurus sphinx documentation"""
+from __future__ import print_function
 
 __expr = ('or',)
 
@@ -65,9 +66,9 @@
                 new_lines.append('%s:type %s: %s' %
                                  (prefix, param_name, klass))
         new_lines.append('%s:param %s: %s' % (prefix, param_name, desc))
-    except Exception, e:
-        print "Taurus sphinx extension: Not able to process param: '%s'" % line
-        print "      Reason:", str(e)
+    except Exception as e:
+        print("Taurus sphinx extension: Not able to process param: '%s'" % line)
+        print("      Reason:", str(e))
         new_lines.append(line)
     return new_lines
 
@@ -85,9 +86,9 @@
                 desc = desc[pos + 1:]
                 new_lines.append('%s:rtype: %s' % (prefix, klass))
         new_lines.append('%s:return: %s' % (prefix, desc))
-    except Exception, e:
-        print "TaurusExtension: Not able to process 'return': '%s'" % line
-        print "      Reason:", str(e)
+    except Exception as e:
+        print("TaurusExtension: Not able to process 'return': '%s'" % line)
+        print("      Reason:", str(e))
         new_lines.append(line)
     return new_lines
 
@@ -105,9 +106,9 @@
                 klass = "(" + process_type(elem_type, obj_type='exc') + ")"
                 desc = desc[pos + 1:]
         new_lines.append('%s:raise: %s %s' % (prefix, klass, desc))
-    except Exception, e:
-        print "TaurusExtension: Not able to process 'raise': '%s'" % line
-        print "      Reason:", str(e)
+    except Exception as e:
+        print("TaurusExtension: Not able to process 'raise': '%s'" % line)
+        print("      Reason:", str(e))
         new_lines.append(line)
     return new_lines
 
--- lib/taurus/console/list.py	(original)
+++ lib/taurus/console/list.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """ """
+from __future__ import absolute_import
 
 __all__ = ["List"]
 
@@ -32,7 +33,7 @@
 import textwrap
 import operator
 
-from enums import Alignment
+from .enums import Alignment
 
 
 class List(list):
--- lib/taurus/console/table.py	(original)
+++ lib/taurus/console/table.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """ """
+from functools import reduce
 
 __all__ = ["Table"]
 
@@ -64,7 +65,7 @@
         if row_head_str is not None and len(row_head_str) != self.nr_row:
             msg = 'RowHeadStr nr (%d) and RowNr (%d) mistmatch' % \
                   (len(row_head_str), self.nr_row)
-            raise ValueError, msg
+            raise ValueError(msg)
         if row_head_width is None:
             if row_head_str is not None:
                 row_head_width = max_len_fn(row_head_str)
@@ -77,7 +78,7 @@
         if col_head_str is not None and len(col_head_str) != self.nr_col:
             msg = 'ColHeadStr nr (%d) and ColNr (%d) mistmatch' % \
                   len(col_head_str), self.nr_col
-            raise ValueError, msg
+            raise ValueError(msg)
         if col_head_width is None:
             if col_head_str is not None:
                 col_head_width = reduce(max, map(max_len_fn, col_head_str))
--- lib/taurus/core/epics/epicsattribute.py	(original)
+++ lib/taurus/core/epics/epicsattribute.py	(refactored)
@@ -25,6 +25,8 @@
 '''
 Epics module. See __init__.py for more detailed documentation
 '''
+from __future__ import print_function
+from __future__ import absolute_import
 __all__ = ['EpicsAttribute']
 
 
@@ -233,12 +235,12 @@
 # ------------------------------------------------------------------------------
 
     def factory(self):
-        from epicsfactory import EpicsFactory
+        from .epicsfactory import EpicsFactory
         return EpicsFactory()
 
     @classmethod
     def getNameValidator(cls):
-        from epicsvalidator import EpicsAttributeNameValidator
+        from .epicsvalidator import EpicsAttributeNameValidator
         return EpicsAttributeNameValidator()
 
 
@@ -251,6 +253,6 @@
     b.write(4.)
     s.read()
 
-    print "!$!", s.read(cache=False)
-    print "a,b,s", a.read().rvalue, b.read().rvalue, s.read().rvalue
-    print "DF=", a.getDataFormat(), DataFormat.whatis(a.getDataFormat())
+    print("!$!", s.read(cache=False))
+    print("a,b,s", a.read().rvalue, b.read().rvalue, s.read().rvalue)
+    print("DF=", a.getDataFormat(), DataFormat.whatis(a.getDataFormat()))
--- lib/taurus/core/epics/epicsfactory.py	(original)
+++ lib/taurus/core/epics/epicsfactory.py	(refactored)
@@ -25,6 +25,7 @@
 '''
 Epics module. See __init__.py for more detailed documentation
 '''
+from __future__ import absolute_import
 __all__ = ['EpicsFactory']
 
 
@@ -44,9 +45,9 @@
 from taurus.core.taurusbasetypes import TaurusElementType
 from taurus.core.taurusfactory import TaurusFactory
 
-from epicsattribute import EpicsAttribute
-from epicsdevice import EpicsDevice
-from epicsauthority import EpicsAuthority
+from .epicsattribute import EpicsAttribute
+from .epicsdevice import EpicsDevice
+from .epicsauthority import EpicsAuthority
 
 
 class EpicsFactory(Singleton, TaurusFactory, Logger):
@@ -145,17 +146,17 @@
 
     def getAuthorityNameValidator(self):
         """Return EpicsAuthorityNameValidator"""
-        import epicsvalidator
+        from . import epicsvalidator
         return epicsvalidator.EpicsAuthorityNameValidator()
 
     def getDeviceNameValidator(self):
         """Return EpicsDeviceNameValidator"""
-        import epicsvalidator
+        from . import epicsvalidator
         return epicsvalidator.EpicsDeviceNameValidator()
 
     def getAttributeNameValidator(self):
         """Return EpicsAttributeNameValidator"""
-        import epicsvalidator
+        from . import epicsvalidator
         return epicsvalidator.EpicsAttributeNameValidator()
 
 if __name__ == "__main__":
--- lib/taurus/core/epics/__init__.py	(original)
+++ lib/taurus/core/epics/__init__.py	(refactored)
@@ -66,5 +66,6 @@
 are just convenience dummy objects in the epics scheme at this point.
 Epics records may eventually be mapped as Devices.
 """
+from __future__ import absolute_import
 
-from epicsfactory import *
+from .epicsfactory import *
--- lib/taurus/core/epics/test/test_epicsattribute.py	(original)
+++ lib/taurus/core/epics/test/test_epicsattribute.py	(refactored)
@@ -56,7 +56,7 @@
                                 error=None,
                                 )
             )
-@unittest.skipIf(sys.modules.has_key('epics') is False,
+@unittest.skipIf(('epics' in sys.modules) is False,
                  "epics module is not available")
 class AttributeTestCase(unittest.TestCase):
     """TestCase for the taurus.Attribute helper"""
--- lib/taurus/core/epics/test/test_epicsvalidator.py	(original)
+++ lib/taurus/core/epics/test/test_epicsvalidator.py	(refactored)
@@ -47,7 +47,7 @@
 @invalid(name='ca:/')
 @invalid(name='ca:///')
 @invalid(name='ca://a')
-@unittest.skipIf(sys.modules.has_key('epics') is False,
+@unittest.skipIf(('epics' in sys.modules) is False,
                  "epics module is not available")
 class EpicsAuthValidatorTestCase(AbstractNameValidatorTestCase,
                                  unittest.TestCase):
@@ -66,7 +66,7 @@
 @invalid(name='ca:foo')  #  device requires absolute path
 @invalid(name='ca:/foo')  # devname must be empty (for now)
 @invalid(name='ca:@foo')
-@unittest.skipIf(sys.modules.has_key('epics') is False,
+@unittest.skipIf(('epics' in sys.modules) is False,
                  "epics module is not available")
 class EpicsDevValidatorTestCase(AbstractNameValidatorTestCase,
                                 unittest.TestCase):
@@ -129,7 +129,7 @@
 @valid(name='ca:1#units', groups={'fragment': 'units'})
 @valid(name='ca:a')
 @names(name='ca:XXX:sum', out=('ca:XXX:sum', 'XXX:sum', 'XXX:sum'))
-@unittest.skipIf(sys.modules.has_key('epics') is False,
+@unittest.skipIf(('epics' in sys.modules) is False,
                  "epics module is not available")
 class EpicsAttrValidatorTestCase(AbstractNameValidatorTestCase,
                                  unittest.TestCase):
--- lib/taurus/core/evaluation/evalattribute.py	(original)
+++ lib/taurus/core/evaluation/evalattribute.py	(refactored)
@@ -200,7 +200,7 @@
             for n in names[1:-1]:
                 obj = getattr(obj, n)
             obj = getattr(obj.__class__, names[-1])
-        except Exception, e:
+        except Exception as e:
             # self.info("%r", e)
             return
         ######################################################################
@@ -359,7 +359,7 @@
#TODO: da qua
             self._value.rvalue = rvalue
             self._value.time = TaurusTimeVal.now()
             self._value.quality = AttrQuality.ATTR_VALID
-        except Exception, e:
+        except Exception as e:
             self._value.quality = AttrQuality.ATTR_INVALID
             msg = " the function '%s' could not be evaluated. Reason: %s" \
                 % (self._transformation, repr(e))
--- lib/taurus/core/evaluation/evalfactory.py	(original)
+++ lib/taurus/core/evaluation/evalfactory.py	(refactored)
@@ -25,15 +25,16 @@
 '''
 evaluation module. See __init__.py for more detailed documentation
 '''
+from __future__ import absolute_import
 __all__ = ['EvaluationFactory']
 
 
 import weakref
 
 from taurus.core.taurusbasetypes import TaurusElementType
-from evalattribute import EvaluationAttribute
-from evalauthority import EvaluationAuthority
-from evaldevice import EvaluationDevice
+from .evalattribute import EvaluationAttribute
+from .evalauthority import EvaluationAuthority
+from .evaldevice import EvaluationDevice
 from taurus.core.taurusexception import TaurusException, DoubleRegistration
 from taurus.core.util.log import Logger
 from taurus.core.util.singleton import Singleton
@@ -195,7 +196,7 @@
             if a is None:  # if the full name is not there, create one
                 dev = self.getDevice(validator.getDeviceName(attr_name))
                 kwargs['storeCallback'] = self._storeAttr
-                if not kwargs.has_key('pollingPeriod'):
+                if 'pollingPeriod' not in kwargs:
                     kwargs['pollingPeriod'] = self.getDefaultPollingPeriod()
                 a = EvaluationAttribute(fullname, parent=dev, **kwargs)
         return a
@@ -242,15 +243,15 @@
 
     def getAuthorityNameValidator(self):
         """Return EvaluationAuthorityNameValidator"""
-        import evalvalidator
+        from . import evalvalidator
         return evalvalidator.EvaluationAuthorityNameValidator()
 
     def getDeviceNameValidator(self):
         """Return EvaluationDeviceNameValidator"""
-        import evalvalidator
+        from . import evalvalidator
         return evalvalidator.EvaluationDeviceNameValidator()
 
     def getAttributeNameValidator(self):
         """Return EvaluationAttributeNameValidator"""
-        import evalvalidator
+        from . import evalvalidator
         return evalvalidator.EvaluationAttributeNameValidator()
--- lib/taurus/core/evaluation/evalvalidator.py	(original)
+++ lib/taurus/core/evaluation/evalvalidator.py	(refactored)
@@ -22,6 +22,7 @@
 ##
 #############################################################################
 
+from __future__ import absolute_import
 __all__ = ['EvaluationDeviceNameValidator',
            'EvaluationAttributeNameValidator']
 
@@ -180,7 +181,7 @@
 
     def getNames(self, fullname, factory=None):
         '''reimplemented from :class:`TaurusDeviceNameValidator`'''
-        from evalfactory import EvaluationFactory
+        from .evalfactory import EvaluationFactory
         # TODO: add mechanism to select strict mode instead of hardcoding here
         groups = self.getUriGroups(fullname)
         if groups is None:
@@ -424,7 +425,7 @@
 
     def getNames(self, fullname, factory=None, fragment=False):
         '''reimplemented from :class:`TaurusDeviceNameValidator`'''
-        from evalfactory import EvaluationFactory
+        from .evalfactory import EvaluationFactory
         groups = self.getUriGroups(fullname)
         if groups is None:
             return None
@@ -497,7 +498,7 @@
     def getDeviceName(self, name):
         #@TODO: Maybe this belongs to the factory, not the validator
         '''Obtain the fullname of the device from the attribute name'''
-        from evalfactory import EvaluationFactory
+        from .evalfactory import EvaluationFactory
         groups = self.getUriGroups(name)
         if groups is None:
             return None
@@ -512,7 +513,7 @@
     def getDBName(self, s):
         #@TODO: Maybe this belongs to the factory, not the validator
         '''returns the full data base name for the given attribute name'''
-        from evalfactory import EvaluationFactory
+        from .evalfactory import EvaluationFactory
         m = self.name_re.match(s)
         if m is None:
             return None
--- lib/taurus/core/evaluation/__init__.py	(original)
+++ lib/taurus/core/evaluation/__init__.py	(refactored)
@@ -176,8 +176,9 @@
           This syntax is now deprecated and should not be used. Taurus will
           issue warnings if detected.
 """
+from __future__ import absolute_import
 
-from evalfactory import EvaluationFactory
-from evalattribute import EvaluationAttribute
-from evalauthority import EvaluationAuthority
-from evaldevice import EvaluationDevice
+from .evalfactory import EvaluationFactory
+from .evalattribute import EvaluationAttribute
+from .evalauthority import EvaluationAuthority
+from .evaldevice import EvaluationDevice
--- lib/taurus/core/evaluation/test/res/dev_example.py	(original)
+++ lib/taurus/core/evaluation/test/res/dev_example.py	(refactored)
@@ -25,6 +25,7 @@
 '''
 Examples on using the evaluation scheme for exposing arbitrary non-tango quantities as taurus attributes
 '''
+from __future__ import print_function
 
 __all__ = ['FreeSpaceDevice']
 
@@ -70,7 +71,7 @@
     # calculates free space in Gb
     a = taurus.Attribute(
         'eval:@taurus.core.evaluation.test.res.dev_example.FreeSpaceDevice/getFreeSpace("/").to("GiB")')
-    print "Free space: {:s}".format(a.read().rvalue), a.read().rvalue.units
+    print("Free space: {:s}".format(a.read().rvalue), a.read().rvalue.units)
 
 
 def test2():
--- lib/taurus/core/evaluation/test/res/ipap_example.py	(original)
+++ lib/taurus/core/evaluation/test/res/ipap_example.py	(refactored)
@@ -26,6 +26,7 @@
 Examples on using the evaluation scheme for exposing icepap driver values
 as taurus attributes
 """
+from __future__ import print_function
 
 
 ATTR_IPAP_POS = ( 'eval:@ipap=pyIcePAP.EthIcePAP("icepap06", port=5000)' +
@@ -35,7 +36,7 @@
 def _test1():
     import taurus.core
     a = taurus.Attribute(ATTR_IPAP_POS)
-    print "axis pos:", a.read().rvalue
+    print("axis pos:", a.read().rvalue)
 
 
 def _test2():
--- lib/taurus/core/evaluation/test/res/mymod.py	(original)
+++ lib/taurus/core/evaluation/test/res/mymod.py	(refactored)
@@ -26,6 +26,7 @@
 """
 This module is used for the tests of custom evaluation devices.
 """
+from __future__ import print_function
 
 import os
 from taurus.external.pint import Quantity
@@ -82,16 +83,16 @@
     def test1():
         n = 'eval:@c=taurus.core.evaluation.test.res.mymod.MyClass(987)/c.foo'
         a = taurus.Attribute(n)
-        print "READ 1:   ", a.read()
+        print("READ 1:   ", a.read())
         # print a.range
-        print "WRITE+READ", a.write(Quantity(999, "m"))
-        print "READ 2:   ", a.read(cache=False)
+        print("WRITE+READ", a.write(Quantity(999, "m")))
+        print("READ 2:   ", a.read(cache=False))
 
     def test2(models):
         for m in models:
-            print m
+            print(m)
             a = taurus.Attribute(m)
-            print "   -->", a.writable, a.read().rvalue
+            print("   -->", a.writable, a.read().rvalue)
 
     models = [
       # instance models
--- lib/taurus/core/init_bkcomp.py	(original)
+++ lib/taurus/core/init_bkcomp.py	(refactored)
@@ -24,10 +24,11 @@
 #############################################################################
 
 """The core module"""
+from __future__ import absolute_import
 
 __docformat__ = "restructuredtext"
 
-import release as Release
+from . import release as Release
 # from .enums import * #note: all the enums from enums.py were moved to
 # taurusbasetypes.py
 from .taurusbasetypes import *
--- lib/taurus/core/__init__.py	(original)
+++ lib/taurus/core/__init__.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """The core module"""
+from __future__ import absolute_import
 
 __docformat__ = "restructuredtext"
 
@@ -33,6 +34,6 @@
     taurus.tauruscustomsettings, 'LIGHTWEIGHT_IMPORTS', False)
 
 if LIGHTWEIGHT_IMPORTS:
-    from init_lightweight import *
+    from .init_lightweight import *
 else:
-    from init_bkcomp import *
+    from .init_bkcomp import *
--- lib/taurus/core/resource/__init__.py	(original)
+++ lib/taurus/core/resource/__init__.py	(refactored)
@@ -99,5 +99,6 @@
 is not even defined).
 
 """
+from __future__ import absolute_import
 
-from resfactory import *
+from .resfactory import *
--- lib/taurus/core/resource/resfactory.py	(original)
+++ lib/taurus/core/resource/resfactory.py	(refactored)
@@ -26,6 +26,7 @@
 """
 resfactory.py:
 """
+from __future__ import absolute_import
 
 import os
 import imp
@@ -86,7 +87,7 @@
             raise ValueError('priority must be >=1')
         if operator.isMappingType(obj):
             name = name or 'DICT%02d' % priority
-        elif type(obj) in types.StringTypes or obj is None:
+        elif type(obj) in (str,) or obj is None:
             name, mod = self.__reloadResource(obj)
             obj = {}
             for k, v in mod.__dict__.items():
@@ -136,7 +137,7 @@
             m = imp.load_module(module_name, file_, pathname, desc)
             if file_:
                 file_.close()
-        except Exception, e:
+        except Exception as e:
             if file_:
                 file_.close()
             raise e
@@ -246,15 +247,15 @@
 
     def getAuthorityNameValidator(self):
         """Return ResourceAuthorityNameValidator"""
-        import resvalidator
+        from . import resvalidator
         return resvalidator.ResourceAuthorityNameValidator()
 
     def getDeviceNameValidator(self):
         """Return ResourceDeviceNameValidator"""
-        import resvalidator
+        from . import resvalidator
         return resvalidator.ResourceDeviceNameValidator()
 
     def getAttributeNameValidator(self):
         """Return ResourceAttributeNameValidator"""
-        import resvalidator
+        from . import resvalidator
         return resvalidator.ResourceAttributeNameValidator()
--- lib/taurus/core/resource/test/test_resfactory.py	(original)
+++ lib/taurus/core/resource/test/test_resfactory.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """Test for taurus.core.resource.test.test_resfactory..."""
+from __future__ import print_function
 __all__ = ["ResourceFactoryTestCase"]
 
 import os.path as osp
@@ -68,7 +69,7 @@
 
 file_name1 = osp.join(osp.dirname(osp.abspath(__file__)),
                       'res', 'attr_resources_file.py')
-print file_name1
+print(file_name1)
 
 # TODO: the same key can be defined in different dictionaries (with different
 # priority) but getValue method can not access to the less priority values in
--- lib/taurus/core/tango/img/__init__.py	(original)
+++ lib/taurus/core/tango/img/__init__.py	(refactored)
@@ -25,10 +25,11 @@
 
 """The img package. It contains specific part of tango devices dedicated to
 images (CCDs, detectors, etc)"""
+from __future__ import absolute_import
 
 __docformat__ = 'restructuredtext'
 
-from img import *
+from .img import *
 
 
 def registerExtensions():
--- lib/taurus/core/tango/__init__.py	(original)
+++ lib/taurus/core/tango/__init__.py	(refactored)
@@ -102,12 +102,13 @@
           This syntax is now deprecated and should not be used. Taurus will
           issue warnings if detected.
 """
+from __future__ import absolute_import
 
 __docformat__ = "restructuredtext"
 
-from enums import *
-from tangodatabase import *
-from tangodevice import *
-from tangofactory import *
-from tangoattribute import *
-from tangoconfiguration import *
+from .enums import *
+from .tangodatabase import *
+from .tangodevice import *
+from .tangofactory import *
+from .tangoattribute import *
+from .tangoconfiguration import *
--- lib/taurus/core/tango/starter.py	(original)
+++ lib/taurus/core/tango/starter.py	(refactored)
@@ -29,6 +29,7 @@
 It is not a replacement of the Tango Starter Device Server since this is much
 more limited in scope.
 """
+from __future__ import print_function
 
 __docformat__ = 'restructuredtext'
 
@@ -236,9 +237,9 @@
     s.addNewDevice(devname, klass='Timeout')
     s.startDs()
     try:
-        print 'Is running:', s.isRunning()
-        print "ping:", PyTango.DeviceProxy(devname).ping()
-    except Exception, e:
-        print e
+        print('Is running:', s.isRunning())
+        print("ping:", PyTango.DeviceProxy(devname).ping())
+    except Exception as e:
+        print(e)
     s.stopDs()
     s.cleanDb(force=False)
--- lib/taurus/core/tango/tangoattribute.py	(original)
+++ lib/taurus/core/tango/tangoattribute.py	(refactored)
@@ -425,7 +425,7 @@
                     # handle old PyTango
                     dev.write_attribute(name, value)
                     result = dev.read_attribute(name)
-                except PyTango.DevFailed, df:
+                except PyTango.DevFailed as df:
                     for err in df:
                         # Handle old device servers
                         if err.reason == 'API_UnsupportedFeature':
@@ -439,12 +439,12 @@
             else:
                 dev.write_attribute(name, value)
                 return None
-        except PyTango.DevFailed, df:
+        except PyTango.DevFailed as df:
             err = df[0]
             self.error("[Tango] write failed (%s): %s" %
                        (err.reason, err.desc))
             raise df
-        except Exception, e:
+        except Exception as e:
             self.error("[Tango] write failed: %s" % str(e))
             raise e
 
@@ -473,12 +473,12 @@
                        ):
                         return
                     self.__attr_value = value
-            except PyTango.DevFailed, df:
+            except PyTango.DevFailed as df:
                 self.__subscription_event.set()
                 self.debug("Error polling: %s" % df[0].desc)
                 self.traceback()
                 self.fireEvent(TaurusEventType.Error, self.__attr_err)
-            except Exception, e:
+            except Exception as e:
                 self.__subscription_event.set()
                 self.debug("Error polling: %s" % str(e))
                 self.fireEvent(TaurusEventType.Error, self.__attr_err)
@@ -686,7 +686,7 @@
             try:
                 self.__dev_hw_obj.unsubscribe_event(self.__chg_evt_id)
                 self.__chg_evt_id = None
-            except PyTango.DevFailed, df:
+            except PyTango.DevFailed as df:
                 if len(df.args) and df[0].reason == 'API_EventNotFound':
                     # probably tango shutdown has been initiated before and
                     # it unsubscribed from events itself
@@ -751,7 +751,7 @@
             try:
                 self.__dev_hw_obj.unsubscribe_event(self.__cfg_evt_id)
                 self.__cfg_evt_id = None
-            except PyTango.DevFailed, e:
+            except PyTango.DevFailed as e:
                 self.debug("Error trying to unsubscribe configuration events")
                 self.trace(str(e))
                 
--- lib/taurus/core/tango/tangodatabase.py	(original)
+++ lib/taurus/core/tango/tangodatabase.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module contains all taurus tango authority"""
+from __future__ import print_function
 
 __all__ = ["TangoInfo", "TangoAttrInfo", "TangoDevInfo", "TangoServInfo",
            "TangoDevClassInfo", "TangoDatabaseCache", "TangoDatabase",
@@ -288,8 +289,8 @@
                     if not alive:
                         break
                 self._alive = alive
-            except Exception, e:
-                print "except", e
+            except Exception as e:
+                print("except", e)
                 self._alive = False
             self._alivePending = False
         return self._alive
@@ -514,9 +515,9 @@
             for dev in other:
                 try:
                     self.addDevice(dev)
-                except Exception, e:
-                    print e
-        except Exception, e:
+                except Exception as e:
+                    print(e)
+        except Exception as e:
             raise Exception(
                 "Must give dict<obj, TangoDevInfo> or sequence<TangoDevInfo>")
 
@@ -560,9 +561,9 @@
             for serv in other:
                 try:
                     self.addServer(serv)
-                except Exception, e:
-                    print e
-        except Exception, e:
+                except Exception as e:
+                    print(e)
+        except Exception as e:
             raise Exception(
                 "Must give dict<obj, TangoServInfo> or sequence<TangoServInfo>")
 
@@ -666,7 +667,7 @@
             try:
                 host, port = TangoAuthority.get_default_tango_host().rsplit(':', 1)
                 pars = host, port
-            except Exception, e:
+            except Exception as e:
                 from taurus import warning
                 warning("Error getting default Tango host")
         else:
--- lib/taurus/core/tango/tangodevice.py	(original)
+++ lib/taurus/core/tango/tangodevice.py	(refactored)
@@ -201,7 +201,7 @@
     def _createHWObject(self):
         try:
             return DeviceProxy(self.getFullName())
-        except DevFailed, e:
+        except DevFailed as e:
             self.warning('Could not create HW object: %s' % (e[0].desc))
             self.traceback()
 
--- lib/taurus/core/tango/tangofactory.py	(original)
+++ lib/taurus/core/tango/tangofactory.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides the `TangoFactory` object"""
+from __future__ import absolute_import
 
 __all__ = ["TangoFactory"]
 
@@ -220,7 +221,7 @@
 
            :param attr_name: (str) attribute name
         """
-        if self.tango_attr_klasses.has_key(attr_name):
+        if attr_name in self.tango_attr_klasses:
             del self.tango_attr_klasses[attr_name]
 
     def registerDeviceClass(self, dev_klass_name, dev_klass):
@@ -239,7 +240,7 @@
 
            :param dev_klass_name: (str) tango device class name
         """
-        if self.tango_dev_klasses.has_key(dev_klass_name):
+        if dev_klass_name in self.tango_dev_klasses:
             del self.tango_dev_klasses[dev_klass_name]
 
     def getDatabase(self, name=None):
@@ -398,7 +399,7 @@
                         attr_klass = self._getAttributeClass(
                             attr_name=attr_name)
                         kwargs['storeCallback'] = self._storeAttribute
-                        if not kwargs.has_key('pollingPeriod'):
+                        if 'pollingPeriod' not in kwargs:
                             kwargs[
                                 'pollingPeriod'] = self.getDefaultPollingPeriod()
                         attr = attr_klass(full_attr_name, dev, **kwargs)
@@ -514,10 +515,10 @@
             raise KeyError("Device %s not found" % dev_or_dev_name)
         dev.cleanUp()
         full_name = dev.getFullName()
-        if self.tango_devs.has_key(full_name):
+        if full_name in self.tango_devs:
             del self.tango_devs[full_name]
         simp_name = dev.getSimpleName()
-        if self.tango_alias_devs.has_key(simp_name):
+        if simp_name in self.tango_alias_devs:
             del self.tango_alias_devs[simp_name]
 
     def removeExistingAttribute(self, attr_or_attr_name):
@@ -533,7 +534,7 @@
             raise KeyError("Attribute %s not found" % attr_or_attr_name)
         attr.cleanUp()
         full_name = attr.getFullName()
-        if self.tango_attrs.has_key(full_name):
+        if full_name in self.tango_attrs:
             del self.tango_attrs[full_name]
 
     def isPollingEnabled(self):
@@ -567,17 +568,17 @@
 
     def getAuthorityNameValidator(self):
         """Return TangoAuthorityNameValidator"""
-        import tangovalidator
+        from . import tangovalidator
         return tangovalidator.TangoAuthorityNameValidator()
 
     def getDeviceNameValidator(self):
         """Return TangoDeviceNameValidator"""
-        import tangovalidator
+        from . import tangovalidator
         return tangovalidator.TangoDeviceNameValidator()
 
     def getAttributeNameValidator(self):
         """Return TangoAttributeNameValidator"""
-        import tangovalidator
+        from . import tangovalidator
         return tangovalidator.TangoAttributeNameValidator()
 
     def setOperationMode(self, mode):
--- lib/taurus/core/tango/test/__init__.py	(original)
+++ lib/taurus/core/tango/test/__init__.py	(refactored)
@@ -23,4 +23,5 @@
 ##
 #############################################################################
 
-from tgtestds import TangoSchemeTestLauncher
+from __future__ import absolute_import
+from .tgtestds import TangoSchemeTestLauncher
--- lib/taurus/core/tango/util/__init__.py	(original)
+++ lib/taurus/core/tango/util/__init__.py	(refactored)
@@ -24,7 +24,8 @@
 #############################################################################
 
 """The sardana package. It contains specific part of sardana"""
+from __future__ import absolute_import
 
 __docformat__ = 'restructuredtext'
 
-from formatter import tangoFormatter
+from .formatter import tangoFormatter
--- lib/taurus/core/taurusauthority.py	(original)
+++ lib/taurus/core/taurusauthority.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module contains the base class for a taurus database"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusAuthority"]
 
@@ -87,7 +88,7 @@
 
     def getDevice(self, devname):
         """Returns the device object given its name"""
-        import taurusdevice
+        from . import taurusdevice
         return self.factory().getObject(taurusdevice.TaurusDevice, devname)
 
     @property
--- lib/taurus/core/taurusfactory.py	(original)
+++ lib/taurus/core/taurusfactory.py	(refactored)
@@ -55,6 +55,7 @@
   <https://tools.ietf.org/html/rfc3986#section-3.3>)
 
 """
+from __future__ import absolute_import
 
 __all__ = ["TaurusFactory"]
 
@@ -62,12 +63,12 @@
 
 import atexit
 from weakref import WeakValueDictionary
-from taurusbasetypes import TaurusElementType
-from taurusauthority import TaurusAuthority
-from taurusdevice import TaurusDevice
-from taurusattribute import TaurusAttribute
-from taurusconfiguration import TaurusConfiguration, TaurusConfigurationProxy
-from taurusexception import TaurusException
+from .taurusbasetypes import TaurusElementType
+from .taurusauthority import TaurusAuthority
+from .taurusdevice import TaurusDevice
+from .taurusattribute import TaurusAttribute
+from .taurusconfiguration import TaurusConfiguration, TaurusConfigurationProxy
+from .taurusexception import TaurusException
 from taurus.core.tauruspollingtimer import TaurusPollingTimer
 
 
@@ -93,7 +94,7 @@
         self._devs = WeakValueDictionary()
         self._auths = WeakValueDictionary()
 
-        import taurusmanager
+        from . import taurusmanager
         manager = taurusmanager.TaurusManager()
         self._serialization_mode = manager.getSerializationMode()
 
--- lib/taurus/core/taurushelper.py	(original)
+++ lib/taurus/core/taurushelper.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """a list of helper methods"""
+from __future__ import print_function
 
 __all__ = ['check_dependencies', 'log_dependencies', 'getSchemeFromName',
            'getValidTypesForName', 'isValidName', 'makeSchemeExplicit',
@@ -74,36 +75,36 @@
                 }
     import pkg_resources
     d = pkg_resources.get_distribution('taurus')
-    print "Dependencies for %s:" % d
+    print("Dependencies for %s:" % d)
     # minimum requirements (without extras)
     for r in d.requires():
         try:
             pkg_resources.require(str(r))
-            print '\t[*]',
+            print('\t[*]', end=' ')
         except Exception:
-            print '\t[ ]',
-        print '%s' % r
+            print('\t[ ]', end=' ')
+        print('%s' % r)
     # requirements for the extras
-    print '\nExtras:'
+    print('\nExtras:')
     for extra in sorted(d.extras):
-        print "Dependencies for taurus[%s]:" % extra
+        print("Dependencies for taurus[%s]:" % extra)
         # requirements from PyPI
         for r in d.requires(extras=[extra]):
             try:
                 r = str(r).split(';')[0]  # remove marker if present (see #612)
                 pkg_resources.require(r)
-                print '\t[*]',
+                print('\t[*]', end=' ')
             except Exception:
-                print '\t[ ]',
-            print '%s' % r
+                print('\t[ ]', end=' ')
+            print('%s' % r)
         # requirements outside PyPI
         for r, check in non_pypi.get(extra, ()):
             try:
                 check()
-                print '\t[*]',
+                print('\t[*]', end=' ')
             except Exception:
-                print '\t[ ]',
-            print '%s (not in PyPI)' % r
+                print('\t[ ]', end=' ')
+            print('%s (not in PyPI)' % r)
 
 
 def log_dependencies():
@@ -296,7 +297,7 @@
     if attr_name is None:
         return Factory(scheme=getSchemeFromName(dev_or_attr_name)).getAttribute(dev_or_attr_name)
     else:
-        if type(dev_or_attr_name) in types.StringTypes:
+        if type(dev_or_attr_name) in (str,):
             dev = Device(dev_or_attr_name)
         else:
             dev = dev_or_attr_name
--- lib/taurus/core/tauruslistener.py	(original)
+++ lib/taurus/core/tauruslistener.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module contains the taurus base listeners classes"""
+from __future__ import print_function
 
 __all__ = ["TaurusListener", "TaurusExceptionListener"]
 
@@ -70,4 +71,4 @@
         self._printException(exception)
 
     def _printException(self, exception):
-        print self.__class__.__name__, "received", exception.__class__.__name__, str(exception)
+        print(self.__class__.__name__, "received", exception.__class__.__name__, str(exception))
--- lib/taurus/core/taurusmanager.py	(original)
+++ lib/taurus/core/taurusmanager.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module contains the taurus base manager class"""
+from __future__ import print_function
 
 __all__ = ["TaurusManager"]
 
@@ -291,7 +292,7 @@
         for plugin_class in plugin_classes:
             schemes = list(plugin_class.schemes)
             for scheme in schemes:
-                if plugins.has_key(scheme):
+                if scheme in plugins:
                     k = plugins[scheme]
                     self.warning("Conflicting plugins: %s and %s both implement "
                                  "scheme %s. Will keep using %s" % (k.__name__,
@@ -336,7 +337,7 @@
         for full_module_name in full_module_names:
             try:
                 m = __import__(full_module_name, fromlist=['*'], level=0)
-            except Exception, imp1:
+            except Exception as imp1:
                 # just in case we are in python 2.4
                 try:
                     m = __import__(full_module_name,
@@ -397,4 +398,4 @@
 
 if __name__ == '__main__':
     manager = TaurusManager()
-    print manager.getPlugins()
+    print(manager.getPlugins())
--- lib/taurus/core/tauruspollingtimer.py	(original)
+++ lib/taurus/core/tauruspollingtimer.py	(refactored)
@@ -75,7 +75,7 @@
         self.lock.acquire()
         try:
             attr_dict = self.dev_dict.get(dev)
-            return attr_dict and attr_dict.has_key(attr_name)
+            return attr_dict and attr_name in attr_dict
         finally:
             self.lock.release()
 
--- lib/taurus/core/taurusvalidator.py	(original)
+++ lib/taurus/core/taurusvalidator.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module contains the base taurus name validator classes"""
+from __future__ import print_function
 
 
 __all__ = ["TaurusAuthorityNameValidator", "TaurusDeviceNameValidator",
@@ -313,5 +314,5 @@
 
     v = FooAttributeNameValidator()
     name = 'foo://bar#label'
-    print v.isValid(name)
-    print v.getUriGroups(name)
+    print(v.isValid(name))
+    print(v.getUriGroups(name))
--- lib/taurus/core/util/argparse/taurusargparse.py	(original)
+++ lib/taurus/core/util/argparse/taurusargparse.py	(refactored)
@@ -198,7 +198,7 @@
             rfoo.utils.rconsole.spawn_server(port=options.remote_console_port)
             taurus.info("rconsole started. You can connect to it by typing: rconsole -p %d",
                         options.remote_console_port)
-        except Exception, e:
+        except Exception as e:
             taurus.warning("Cannot spawn debugger. Reason: %s", str(e))
 
     # initialize default formatter
--- lib/taurus/core/util/codecs.py	(original)
+++ lib/taurus/core/util/codecs.py	(refactored)
@@ -62,6 +62,7 @@
     >>> codec = CodecFactory().getCodec(v.format)
     >>> f, d = codec.decode((v.format, v.value))
 """
+from __future__ import absolute_import
 
 __all__ = ["Codec", "NullCodec", "ZIPCodec", "BZ2Codec", "JSONCodec",
            "FunctionCodec", "PlotCodec", "CodecPipeline", "CodecFactory"]
@@ -74,9 +75,9 @@
 import struct
 import numpy
 
-from singleton import Singleton
-from log import Logger
-from containers import CaselessDict
+from .singleton import Singleton
+from .log import Logger
+from .containers import CaselessDict
 
 
 class Codec(Logger):
@@ -879,7 +880,7 @@
         self._codec_klasses[format] = klass
 
         # del old codec if exists
-        if self._codecs.has_key(format):
+        if format in self._codecs:
             del self._codecs[format]
 
     def unregisterCodec(self, format):
@@ -889,10 +890,10 @@
         :param format: (str) the codec id
 
         :raises: KeyError"""
-        if self._codec_klasses.has_key(format):
+        if format in self._codec_klasses:
             del self._codec_klasses[format]
 
-        if self._codecs.has_key(format):
+        if format in self._codecs:
             del self._codecs[format]
 
     def getCodec(self, format):
--- lib/taurus/core/util/colors.py	(original)
+++ lib/taurus/core/util/colors.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module contains color codes for state and quality"""
+from __future__ import print_function
 
 __all__ = ["DEVICE_STATE_DATA", "ATTRIBUTE_QUALITY_DATA", "ColorPalette",
            "DEVICE_STATE_PALETTE", "ATTRIBUTE_QUALITY_PALETTE"]
@@ -94,7 +95,7 @@
         self._int_decoder_dict = int_decoder_dict
 
     def _decoder(self, elem):
-        if type(elem) == types.IntType or type(elem) == types.LongType:
+        if type(elem) == int or type(elem) == int:
             elem = self._int_decoder_dict.get(elem)
         return str(elem)
 
@@ -133,7 +134,7 @@
             return self._rgb_data[name][0]
 
     def has(self, name):
-        return self._rgb_data.has_key(name)
+        return name in self._rgb_data
 
     def size(self):
         return len(self._rgb_data)
@@ -215,7 +216,7 @@
         bg_color = pal.name(stoq)
         rgb = "(%3.3d, %3.3d, %3.3d)" % pal.rgb(stoq)
         hx = pal.hex(stoq)
-        print "%7s %5s on %13s %15s #%s" % (stoq, fg_color, bg_color, rgb, hx)
+        print("%7s %5s on %13s %15s #%s" % (stoq, fg_color, bg_color, rgb, hx))
 
 
 if __name__ == "__main__":
@@ -223,8 +224,8 @@
     print_color_palette(ATTRIBUTE_QUALITY_PALETTE)
     from taurus.core import TaurusDevState
     import PyTango
-    print
-    print DEVICE_STATE_PALETTE.rgb(TaurusDevState.Ready)
-    print DEVICE_STATE_PALETTE.rgb('TaurusDevState.Ready')
-    print DEVICE_STATE_PALETTE.rgb(PyTango.DevState.ON)
-    print DEVICE_STATE_PALETTE.rgb(0)
+    print()
+    print(DEVICE_STATE_PALETTE.rgb(TaurusDevState.Ready))
+    print(DEVICE_STATE_PALETTE.rgb('TaurusDevState.Ready'))
+    print(DEVICE_STATE_PALETTE.rgb(PyTango.DevState.ON))
+    print(DEVICE_STATE_PALETTE.rgb(0))
--- lib/taurus/core/util/constant.py	(original)
+++ lib/taurus/core/util/constant.py	(refactored)
@@ -60,8 +60,8 @@
     def __setattr__(self, name, value):
         v = self.__dict__.get(name, value)
         if type(v) is not type(value):
-            raise self._ConstTypeError, "Can't rebind %s to %s" % (
-                type(v), type(value))
+            raise self._ConstTypeError("Can't rebind %s to %s" % (
+                type(v), type(value)))
         self.__dict__[name] = value
 
     def __del__(self):
--- lib/taurus/core/util/containers.py	(original)
+++ lib/taurus/core/util/containers.py	(refactored)
@@ -27,6 +27,7 @@
 This module contains a set of useful containers that are not part of the standard
 python distribution.
 """
+from __future__ import print_function
 
 __all__ = ["CaselessList", "CaselessDict", "CaselessWeakValueDict", "LoopList",
            "CircBuf", "LIFO", "TimedQueue", "self_locked", "ThreadDict",
@@ -682,12 +683,12 @@
         self.lock.acquire()
         try:
             if self.trace:
-                print "locked: %s" % self.lock
+                print("locked: %s" % self.lock)
             result = func(self, *args, **kwargs)
         finally:
             self.lock.release()
             if self.trace:
-                print "released: %s" % self.lock
+                print("released: %s" % self.lock)
         return result
     return lock_fun
 
@@ -721,7 +722,7 @@
         self.parent = type(self).mro()[1]
 
     def tracer(self, text):
-        print text
+        print(text)
 
     def start(self):
         import threading
@@ -1052,7 +1053,7 @@
         lines = []
         if isinstance(d, dict):
             for k, v in d.items():
-                print 'with key "%s"' % k
+                print('with key "%s"' % k)
                 lines.append([''] * l + [str(k)])
                 lines += add_to_level(l + 1, v)
         elif type(d) in [list, set]:  # End of recursion
@@ -1065,7 +1066,7 @@
             lines.append([''] * l + [str(d)])
         return lines
     ls = ['\t'.join(line) for line in add_to_level(0, dct)]
-    print 'lines are : \n', ls
+    print('lines are : \n', ls)
     return '\n'.join(ls)
 
 
--- lib/taurus/core/util/decorator/typecheck.py	(original)
+++ lib/taurus/core/util/decorator/typecheck.py	(refactored)
@@ -62,6 +62,7 @@
     TypeError: 'fib' method accepts (int), but was given (float)
 
 """
+from __future__ import print_function
 
 __all__ = ["accepts", "returns"]
 
@@ -97,17 +98,17 @@
                 if argtypes != types:
                     msg = info(f.__name__, types, argtypes, 0)
                     if debug == 1:
-                        print >> sys.stderr, 'TypeWarning: ', msg
+                        print('TypeWarning: ', msg, file=sys.stderr)
                     elif debug == 2:
-                        raise TypeError, msg
+                        raise TypeError(msg)
                 return f(*args)
             newf.__name__ = f.__name__
             return newf
         return decorator
-    except KeyError, key:
-        raise KeyError, key + "is not a valid keyword argument"
-    except TypeError, msg:
-        raise TypeError, msg
+    except KeyError as key:
+        raise KeyError(key + "is not a valid keyword argument")
+    except TypeError as msg:
+        raise TypeError(msg)
 
 
 def returns(ret_type, **kw):
@@ -138,17 +139,17 @@
                 if res_type != ret_type:
                     msg = info(f.__name__, (ret_type,), (res_type,), 1)
                     if debug == 1:
-                        print >> sys.stderr, 'TypeWarning: ', msg
+                        print('TypeWarning: ', msg, file=sys.stderr)
                     elif debug == 2:
-                        raise TypeError, msg
+                        raise TypeError(msg)
                 return result
             newf.__name__ = f.__name__
             return newf
         return decorator
-    except KeyError, key:
-        raise KeyError, key + "is not a valid keyword argument"
-    except TypeError, msg:
-        raise TypeError, msg
+    except KeyError as key:
+        raise KeyError(key + "is not a valid keyword argument")
+    except TypeError as msg:
+        raise TypeError(msg)
 
 
 def info(fname, expected, actual, flag):
--- lib/taurus/core/util/enumeration.py	(original)
+++ lib/taurus/core/util/enumeration.py	(refactored)
@@ -149,7 +149,7 @@
             return self.lookup[i]
 
     def __getattr__(self, attr):
-        if not self.has_key(attr):
+        if attr not in self:
             raise AttributeError
         return self.lookup[attr]
 
--- lib/taurus/core/util/event.py	(original)
+++ lib/taurus/core/util/event.py	(refactored)
@@ -26,6 +26,8 @@
 """
 event.py:
 """
+from __future__ import print_function
+from __future__ import absolute_import
 
 __all__ = ["BoundMethodWeakref", "CallableRef", "EventGenerator",
            "ConfigEventGenerator", "ListEventGenerator", "EventListener",
@@ -95,7 +97,7 @@
     :return: a weak reference for the given callable
     :rtype: BoundMethodWeakref or weakref.ref"""
     if hasattr(object, 'im_self'):
-        if object.im_self is not None:
+        if object.__self__ is not None:
             return BoundMethodWeakref(object, del_cb)
     return weakref.ref(object, del_cb)
 
@@ -151,7 +153,7 @@
         return read
 
 
-from object import Object
+from .object import Object
 
 
 class EventGenerator(Object):
@@ -202,7 +204,7 @@
         :type data: boolean
         """
         if not self.events_active:
-            raise RuntimeError, ('%s does not have '
+            raise RuntimeError('%s does not have '
                                  'events/polling active' % self.event_name)
 
         cb_ref = CallableRef(cb, self.unsubscribeDeletedEvent)
@@ -210,7 +212,7 @@
         try:
             self.lock()
             if (cb_ref, data) in self.cb_list:
-                raise RuntimeError, ('Callback %s(%s) already reg. on %s' %
+                raise RuntimeError('Callback %s(%s) already reg. on %s' %
                                      (cb, data, self.event_name))
             self.cb_list.append((cb_ref, data))
             if with_first_event:
@@ -314,7 +316,7 @@
         :return: the value of the event that unblocked the wait
         :rtype: object"""
         if not self.events_active:
-            raise RuntimeError, ('%s does not have '
+            raise RuntimeError('%s does not have '
                                  'events/polling active' % self.event_name)
         try:
             self.lock()
@@ -539,8 +541,8 @@
                 name = th.name
             else:
                 name = "<unknown>"
-            print "WARNING: Thread %s trying to unlock condition previously " \
-                  "locked by thread %s" % (curr_th.name, name)
+            print("WARNING: Thread %s trying to unlock condition previously " \
+                  "locked by thread %s" % (curr_th.name, name))
 
     def clearEventSet(self):
         "Clears the internal event buffer"
@@ -652,7 +654,7 @@
                             return
                 self._cond.wait(timeout)
                 retries -= 1
-        except Exception, e:
+        except Exception as e:
             sys.stderr.write(
                 "AttributeEventWait: Caught exception while waitting: %s\n" % str(e))
             raise e
@@ -693,8 +695,8 @@
             lock = getattr(self._cond, "_Condition__lock")
             th = getattr(lock, "_RLock__owner")
             curr_th = threading.current_thread()
-            print "WARNING: Thread %s trying to unlock condition previously " \
-                  "locked by thread %s" % (curr_th.name, th.name)
+            print("WARNING: Thread %s trying to unlock condition previously " \
+                  "locked by thread %s" % (curr_th.name, th.name))
 
     def eventReceived(self, s, t, v):
         if t not in (taurus.core.taurusbasetypes.TaurusEventType.Change, taurus.core.taurusbasetypes.TaurusEventType.Periodic):
@@ -716,7 +718,7 @@
             while True:
                 self._cond.wait(timeout)
                 yield self._data
-        except Exception, e:
-            print "INFO: Caught exception while waiting", str(e)
-        finally:
-            self.unlock()
+        except Exception as e:
+            print("INFO: Caught exception while waiting", str(e))
+        finally:
+            self.unlock()
--- lib/taurus/core/util/fandango_search.py	(original)
+++ lib/taurus/core/util/fandango_search.py	(refactored)
@@ -125,7 +125,7 @@
     db = taurus.Authority()
     try:
         return db.get_device_alias(alias)
-    except Exception, e:
+    except Exception as e:
         if 'no device found' in str(e).lower():
             return None
         return None  # raise e
@@ -137,7 +137,7 @@
         # .get_database_device().DbGetDeviceAlias(dev)
         result = db.get_alias(dev)
         return result
-    except Exception, e:
+    except Exception as e:
         if 'no alias found' in str(e).lower():
             return None
         return None  # raise e
--- lib/taurus/core/util/init_bkcomp.py	(original)
+++ lib/taurus/core/util/init_bkcomp.py	(refactored)
@@ -33,6 +33,7 @@
     #. if python >= 2.6 use standard json from python distribution
     #. otherwise use private implementation distributed with taurus
 """
+from __future__ import absolute_import
 
 __docformat__ = "restructuredtext"
 
@@ -61,7 +62,7 @@
 from .threadpool import *
 from .user import *
 
-import eventfilters
+from . import eventfilters
 
 try:
     from lxml import etree
--- lib/taurus/core/util/__init__.py	(original)
+++ lib/taurus/core/util/__init__.py	(refactored)
@@ -33,6 +33,7 @@
     #. if python >= 2.6 use standard json from python distribution
     #. otherwise use private implementation distributed with taurus
 """
+from __future__ import absolute_import
 
 __docformat__ = "restructuredtext"
 
@@ -42,6 +43,6 @@
     taurus.tauruscustomsettings, 'LIGHTWEIGHT_IMPORTS', False)
 
 if LIGHTWEIGHT_IMPORTS:
-    from init_lightweight import *
+    from .init_lightweight import *
 else:
-    from init_bkcomp import *
+    from .init_bkcomp import *
--- lib/taurus/core/util/log.py	(original)
+++ lib/taurus/core/util/log.py	(refactored)
@@ -25,6 +25,8 @@
 
 """This module contains a set of useful logging elements based on python's
 :mod:`logging` system."""
+from __future__ import print_function
+from __future__ import absolute_import
 
 __all__ = ["LogIt", "TraceIt", "DebugIt", "InfoIt", "WarnIt", "ErrorIt",
            "CriticalIt", "MemoryLogHandler", "LogExceptHook", "Logger",
@@ -45,9 +47,9 @@
 import threading
 import functools
 
-from object import Object
-from wrap import wraps
-from excepthook import BaseExceptHook
+from .object import Object
+from .wrap import wraps
+from .excepthook import BaseExceptHook
 
 # ------------------------------------------------------------------------------
 # TODO: substitute this ugly hack (below) by a more general mechanism
@@ -168,7 +170,7 @@
                 return f(*args, **kwargs)
 
             has_log = hasattr(f_self, "log")
-            fname = f.func_name
+            fname = f.__name__
             log_obj = f_self
             if not has_log:
                 log_obj = logging.getLogger()
@@ -188,7 +190,7 @@
             out_msg = "<-"
             try:
                 ret = f(*args, **kwargs)
-            except Exception, e:
+            except Exception as e:
                 exc_info = sys.exc_info()
                 out_msg += " (with %s) %s" % (e.__class__.__name__, fname)
                 log_obj.log(self._level, out_msg, exc_info=exc_info)
@@ -325,27 +327,27 @@
     def __call__(self, f):
         @wraps(f)
         def wrapper(*args, **kwargs):
-            fname = f.func_name
+            fname = f.__name__
             in_msg = "-> %s" % fname
             if self._showargs:
                 if len(args) > 1:
                     in_msg += str(args[1:])
                 if len(kwargs):
                     in_msg += str(kwargs)
-            print
-            print in_msg
+            print()
+            print(in_msg)
             out_msg = "<-"
             try:
                 ret = f(*args, **kwargs)
-            except Exception, e:
+            except Exception as e:
                 out_msg += " (with %s) %s" % (e.__class__.__name__, fname)
-                print out_msg
+                print(out_msg)
                 raise
             out_msg += " %s" % fname
             if not ret is None and self._showret:
                 out_msg += " = %s" % str(ret)
-            print out_msg
-            print
+            print(out_msg)
+            print()
             return ret
         return wrapper
 
@@ -1070,4 +1072,4 @@
         - zab
         """
 
-    print foo.__doc__
+    print(foo.__doc__)
--- lib/taurus/core/util/parse_args.py	(original)
+++ lib/taurus/core/util/parse_args.py	(refactored)
@@ -23,6 +23,7 @@
 ##
 #############################################################################
 
+from __future__ import print_function
 from ast import literal_eval
 
 
@@ -60,7 +61,7 @@
 
 if __name__ == "__main__":
 
-    print parse_args('1, 2, b=3, c=4')
-    print parse_args(' (1, 2, b=3, c=4 )', strip_pars=True)
+    print(parse_args('1, 2, b=3, c=4'))
+    print(parse_args(' (1, 2, b=3, c=4 )', strip_pars=True))
 
-    print parse_args('1, 2, b=3, c=4, 5')  # <--this should raise a SyntaxError
+    print(parse_args('1, 2, b=3, c=4, 5'))  # <--this should raise a SyntaxError
--- lib/taurus/core/util/propertyfile.py	(original)
+++ lib/taurus/core/util/propertyfile.py	(refactored)
@@ -170,7 +170,7 @@
             # same property
             while line[-1] == '\\':
                 # Read next line
-                nextline = i.next()
+                nextline = next(i)
                 nextline = nextline.strip()
                 lineno += 1
                 # This line will become part of the value
@@ -216,7 +216,7 @@
         self._props[key] = value.strip()
 
         # Check if an entry exists in pristine keys
-        if self._keymap.has_key(key):
+        if key in self._keymap:
             oldkey = self._keymap.get(key)
             self._origprops[oldkey] = oldvalue.strip()
         else:
@@ -247,15 +247,15 @@
 
         # For the time being only accept file input streams
         if type(stream) is not file:
-            raise TypeError, 'Argument should be a file object!'
+            raise TypeError('Argument should be a file object!')
         # Check for the opened mode
         if stream.mode != 'r':
-            raise ValueError, 'Stream should be opened in read-only mode!'
+            raise ValueError('Stream should be opened in read-only mode!')
 
         try:
             lines = stream.readlines()
             self.__parse(lines)
-        except IOError, e:
+        except IOError as e:
             raise
 
     def getProperty(self, key):
@@ -269,7 +269,7 @@
         if type(key) is str and type(value) is str:
             self.processPair(key, value)
         else:
-            raise TypeError, 'both key and value should be strings!'
+            raise TypeError('both key and value should be strings!')
 
     def propertyNames(self):
         """ Return an iterator over all the keys of the property
@@ -290,7 +290,7 @@
         with the optional 'header' """
 
         if out.mode[0] != 'w':
-            raise ValueError, 'Steam should be opened in write mode!'
+            raise ValueError('Steam should be opened in write mode!')
 
         try:
             out.write(''.join(('#', header, '\n')))
@@ -302,7 +302,7 @@
                 out.write(''.join((prop, '=', self.escape(val), '\n')))
 
             out.close()
-        except IOError, e:
+        except IOError as e:
             raise
 
     def getPropertyDict(self):
--- lib/taurus/core/util/property_parser.py	(original)
+++ lib/taurus/core/util/property_parser.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This is an experimental property parser"""
+from __future__ import print_function
 
 import os
 
@@ -68,7 +69,7 @@
         else:
             t.value = float(t.value)
     except:
-        print "[%d]: Number %s is not valid!" % (t.lineno, t.value)
+        print("[%d]: Number %s is not valid!" % (t.lineno, t.value))
         t.value = 0
     return t
 
@@ -117,12 +118,12 @@
 
 
 def t_error(t):
-    print "[%d]: Illegal character '%s'" % (t.lexer.lineno, t.value[0])
+    print("[%d]: Illegal character '%s'" % (t.lexer.lineno, t.value[0]))
     t.lexer.skip(1)
 
 
 def p_error(p):
-    print "[%d]: Syntax error in input [%s]" % (p.lineno, (str(p)))
+    print("[%d]: Syntax error in input [%s]" % (p.lineno, (str(p))))
 
 #-------------------------------------------------------------------------
 # Yacc Starting symbol
@@ -228,7 +229,7 @@
             res = self.parse_file(
                 f, logger=logger, debug=debug, optimize=optimize)
             f.close()
-        except IOError, e:
+        except IOError as e:
             if f:
                 f.close()
             raise
@@ -241,4 +242,4 @@
     import sys
     pp = PropertyParser()
     res = pp.parse(sys.argv[1])
-    print res
+    print(res)
--- lib/taurus/core/util/prop.py	(original)
+++ lib/taurus/core/util/prop.py	(refactored)
@@ -24,6 +24,8 @@
 #############################################################################
 
 """This module contains a decorator to simplify the use of property."""
+from __future__ import print_function
+from __future__ import absolute_import
 
 __all__ = ["propertx"]
 
@@ -47,7 +49,7 @@
 
 if __name__ == '__main__':
 
-    from log import Logger
+    from .log import Logger
 
     class example(object, Logger):
 
@@ -60,15 +62,15 @@
         def bar():
             # BAR doc
             def get(self):
-                print "\tgetting", self._a
+                print("\tgetting", self._a)
                 return self._a
 
             def set(self, val):
-                print "\tsetting", val
+                print("\tsetting", val)
                 self._a = val
             return get, set
 
     foo = example()
-    print foo.bar
+    print(foo.bar)
     # foo.bar='egg'
     # print foo.bar
--- lib/taurus/core/util/safeeval.py	(original)
+++ lib/taurus/core/util/safeeval.py	(refactored)
@@ -26,6 +26,7 @@
 """
 safeeval.py: Safe eval replacement with whitelist support
 """
+from __future__ import print_function
 
 __all__ = ["SafeEvaluator"]
 
@@ -117,12 +118,12 @@
 
     x = range(6)
     sev = SafeEvaluator()
-    print "trying to evaluate a variable that has not been registered"
+    print("trying to evaluate a variable that has not been registered")
     try:
         # This will fail because 'x' is not registered in sev
-        print sev.safeEval('x+2')
+        print(sev.safeEval('x+2'))
     except:
-        print "failed!!"
+        print("failed!!")
 
     sev.addSafe({'x': x})  # After registering x, we can use it...
     f0 = 'x'
@@ -134,16 +135,16 @@
     f5 = 'open("/etc/passwd")'
 
     for f in [f0, f1, f2, f3, f4, f5]:
-        print 'Evaluating "%s":' % f
+        print('Evaluating "%s":' % f)
         try:
-            print sev.eval(f)
+            print(sev.eval(f))
         except:
-            print 'ERROR: %s cannot be evaluated' % f
+            print('ERROR: %s cannot be evaluated' % f)
 
     vector = numpy.arange(6)
     # Another way of registering a variable is using the init method...
     sev2 = SafeEvaluator({'x': x, 'y': vector}, defaultSafe=False)
-    print 'x*y=', sev2.eval('x*y')
+    print('x*y=', sev2.eval('x*y'))
     y = 0  # note that the registered variable is local to the evaluator!!
     # here, y still has the previously registered value instead of 0
-    print 'x*y=', sev2.eval('x*y')
+    print('x*y=', sev2.eval('x*y'))
--- lib/taurus/core/util/tablepprint.py	(original)
+++ lib/taurus/core/util/tablepprint.py	(refactored)
@@ -24,6 +24,8 @@
 #############################################################################
 
 """Adapted from http://code.activestate.com/recipes/267662/"""
+from __future__ import print_function
+from functools import reduce
 
 __docformat__ = "restructuredtext"
 
@@ -135,19 +137,19 @@
        Aristidis,Papageorgopoulos,28,Senior Reseacher'''
     rows = [row.strip().split(',') for row in data.splitlines()]
 
-    print 'Without wrapping function\n'
+    print('Without wrapping function\n')
     for l in indent([labels] + rows, hasHeader=True):
-        print l
+        print(l)
 
     # test indent with different wrapping functions
     width = 10
     for wrapper in (wrap_always, wrap_onspace, wrap_onspace_strict):
-        print 'Wrapping function: %s(x,width=%d)\n' % (wrapper.__name__, width)
+        print('Wrapping function: %s(x,width=%d)\n' % (wrapper.__name__, width))
         o = indent([labels] + rows, headerChar='=', hasHeader=True, separateRows=False,
                    prefix='|', postfix='|', delim=' ',
                    wrapfunc=lambda x: wrapper(x, width))
         for l in o:
-            print l
+            print(l)
 
     # output:
     #
--- lib/taurus/core/util/threadpool.py	(original)
+++ lib/taurus/core/util/threadpool.py	(refactored)
@@ -24,6 +24,8 @@
 #############################################################################
 
 """adapted from http://code.activestate.com/recipes/576576/"""
+from __future__ import print_function
+from __future__ import absolute_import
 
 __all__ = ["ThreadPool", "Worker"]
 
@@ -34,8 +36,8 @@
 from time import sleep, time
 from traceback import extract_stack, format_list
 
-from prop import propertx
-from log import Logger, DebugIt, TraceIt
+from .prop import propertx
+from .log import Logger, DebugIt, TraceIt
 
 
 class ThreadPool(Logger):
@@ -152,44 +154,44 @@
 
     def easyJob(*arg, **kw):
         n = arg[0]
-        print '\tSleep\t\t', n
+        print('\tSleep\t\t', n)
         sleep(n)
         return 'Slept\t%d' % n
 
     def longJob(*arg, **kw):
-        print "\tStart\t\t\t", arg, kw
+        print("\tStart\t\t\t", arg, kw)
         n = arg[0] * 3
         sleep(n)
         return "Job done in %d" % n
 
     def badJob(*a, **k):
-        print '\n !!! OOOPS !!!\n'
+        print('\n !!! OOOPS !!!\n')
         a = 1 / 0
 
     def show(*arg, **kw):
-        print 'callback : %s' % arg[0]
+        print('callback : %s' % arg[0])
 
     def test_1(**kwargs):
         workers = kwargs.pop('workers', 5)
         jobqueue = kwargs.pop('jobqueue', 10)
         pool = ThreadPool(name='ThreadPool', Psize=workers, Qsize=jobqueue)
-        print "\n\t\t... let's add some jobs ...\n"
+        print("\n\t\t... let's add some jobs ...\n")
         for j in range(5):
             if j == 1:
                 pool.add(badJob)
             for i in range(5, 0, -1):
                 pool.add(longJob, show, i)
                 pool.add(easyJob, show, i)
-        print '''
+        print('''
             \t\t... and now, we're waiting for the %i workers to get the %i jobs done ...
-        ''' % (pool.size, pool.qsize)
+        ''' % (pool.size, pool.qsize))
         sleep(15)
-        print "\n\t\t... ok, that may take a while, let's get some reinforcement ...\n"
+        print("\n\t\t... ok, that may take a while, let's get some reinforcement ...\n")
         sleep(5)
         pool.size = 50
-        print '\n\t\t... Joining ...\n'
+        print('\n\t\t... Joining ...\n')
         pool.join()
-        print '\n\t\t... Ok ...\n'
+        print('\n\t\t... Ok ...\n')
 
     def test_2(**kwargs):
         workers = kwargs.pop('workers', 5)
@@ -198,21 +200,21 @@
         sleep_t = kwargs.pop('sleep_t', 1)
         #from taurus.core.util.threadpool import ThreadPool
         pool = ThreadPool(name='ThreadPool', Psize=workers, Qsize=jobqueue)
-        print "\n\t\t... Check the number of busy workers ...\n"
-        print "Num of busy workers = %s" % (pool.getNumOfBusyWorkers())
-        print "\n\t\t... let's add some jobs ...\n"
+        print("\n\t\t... Check the number of busy workers ...\n")
+        print("Num of busy workers = %s" % (pool.getNumOfBusyWorkers()))
+        print("\n\t\t... let's add some jobs ...\n")
         for i in range(numjobs):
             pool.add(easyJob, None, sleep_t)
-        print '\n\t\t... Monitoring the busy workers ...\n'
+        print('\n\t\t... Monitoring the busy workers ...\n')
         t0 = time()
         while pool.getNumOfBusyWorkers() > 0:
-            print "busy workers = %s" % (pool.getNumOfBusyWorkers())
+            print("busy workers = %s" % (pool.getNumOfBusyWorkers()))
             sleep(0.5)
         t1 = time()
-        print "Run %s jobs of 1 second took %.3f" % (numjobs, t1 - t0)
-        print '\n\t\t... Joining ...\n'
+        print("Run %s jobs of 1 second took %.3f" % (numjobs, t1 - t0))
+        print('\n\t\t... Joining ...\n')
         pool.join()
-        print '\n\t\t... Ok ...\n'
+        print('\n\t\t... Ok ...\n')
 
     def main(argv):
         kwargs = {}
--- lib/taurus/qt/qtcore/communication/communication.py	(original)
+++ lib/taurus/qt/qtcore/communication/communication.py	(refactored)
@@ -26,6 +26,7 @@
 """
 comunications.py:
 """
+from __future__ import print_function
 
 from taurus.external.qt import QtCore
 import weakref
@@ -333,7 +334,7 @@
         '''
         A slot which you can connect as a reader for debugging. It will print info to the stdout
         '''
-        print "SharedDataManager: \n\tSender=: %s\n\tData=%s" % (self.sender(), repr(data))
+        print("SharedDataManager: \n\tSender=: %s\n\tData=%s" % (self.sender(), repr(data)))
 
     def info(self):
         s = ""
--- lib/taurus/qt/qtcore/configuration/configuration.py	(original)
+++ lib/taurus/qt/qtcore/configuration/configuration.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides the set of base classes designed to provide
 configuration features to the classes that inherit from them"""
+from __future__ import print_function
 
 __all__ = ["configurableProperty", "BaseConfigurableClass"]
 
@@ -149,7 +150,7 @@
 
         for k in x['__orderedConfigNames__']:
             if k not in x['__itemConfigurations__']:
-                print 'missing configuration for "%s" in %s' % (k, repr(x))
+                print('missing configuration for "%s" in %s' % (k, repr(x)))
         return True
 
     def createConfig(self, allowUnpickable=False):
@@ -250,7 +251,7 @@
         self.__configurableItems = {}
 
     def registerConfigurableItem(self, item, name=None):
-        print "Deprecation WARNING: %s.registerConfigurableItem() has been deprecated. Use registerConfigDelegate() instead" % repr(self)
+        print("Deprecation WARNING: %s.registerConfigurableItem() has been deprecated. Use registerConfigDelegate() instead" % repr(self))
         self._registerConfigurableItem(item, name=name)
 
     def registerConfigDelegate(self, delegate, name=None):
--- lib/taurus/qt/qtcore/model/__init__.py	(original)
+++ lib/taurus/qt/qtcore/model/__init__.py	(refactored)
@@ -53,8 +53,9 @@
     view.setModel(model)
 
 """
+from __future__ import absolute_import
 
 __docformat__ = 'restructuredtext'
 
-from taurusmodel import *
-from taurusdatabasemodel import *
+from .taurusmodel import *
+from .taurusdatabasemodel import *
--- lib/taurus/qt/qtcore/util/emitter.py	(original)
+++ lib/taurus/qt/qtcore/util/emitter.py	(refactored)
@@ -225,7 +225,7 @@
             size = self.getQueue().qsize()
             if size:
                 self.log.info('onRefresh(%s)' % size)
-                self.next()
+                next(self)
             else:
                 self.log.debug('onRefresh()')
         except:
@@ -266,7 +266,7 @@
                 nqueue.put(i)
         while not nqueue.empty():
             self.queue.put(nqueue.get())
-        self.next()
+        next(self)
 
     def _doSomething(self, params):
         self.log.debug('At TaurusEmitterThread._doSomething(%s)' % str(params))
@@ -317,7 +317,7 @@
         Qt.QApplication.instance().thread().msleep(self.timewait)
         self.log.info('#' * 80)
         self.log.info('At TaurusEmitterThread.run()')
-        self.next()
+        next(self)
 
         if self.refreshTimer:
             self.refreshTimer.start(self.polling)
@@ -394,7 +394,7 @@
                 self.info('addUnsubscribedAttributes([%d])' % len(items))
                 for attr in items:
                     self._addModelObj(attr)
-                self._modelsThread.next()
+                next(self._modelsThread)
                 self.info('Thread queue: [%d]' % (self._modelsQueue.qsize()))
         except:
             self.warning(traceback.format_exc())
@@ -504,7 +504,7 @@
             self.thread.start()
         except:
             pass
-        self.next()
+        next(self)
         self._running = True
         return
 
@@ -535,7 +535,7 @@
                 nqueue.put(i)
         while not nqueue.empty():
             self.queue.put(nqueue.get())
-        self.next()
+        next(self)
 
     def isRunning(self):
         return self._running
--- lib/taurus/qt/qtcore/util/__init__.py	(original)
+++ lib/taurus/qt/qtcore/util/__init__.py	(refactored)
@@ -24,7 +24,8 @@
 #############################################################################
 
 """This package provides a set of utilities (e.g. logging) to taurus qtcore"""
+from __future__ import absolute_import
 
 __docformat__ = 'restructuredtext'
 
-from tauruslog import *
+from .tauruslog import *
--- lib/taurus/qt/qtcore/util/signal.py	(original)
+++ lib/taurus/qt/qtcore/util/signal.py	(refactored)
@@ -1,4 +1,5 @@
 """Provide a Signal class for non-QObject objects"""
+from __future__ import print_function
 
 __all__ = ['baseSignal']
 
--- lib/taurus/qt/qtdesigner/containerplugin.py	(original)
+++ lib/taurus/qt/qtdesigner/containerplugin.py	(refactored)
@@ -36,6 +36,7 @@
     - 'model' - will have a '...' button that will open a customized dialog for
       editing the widget model (same has 'Edit model...' task menu item
 """
+from __future__ import absolute_import
 
 from taurus.core.util.log import Logger
 from taurus.external.qt import Qt
@@ -105,7 +106,7 @@
 
 
 def create_plugin():
-    from taurusplugin.taurusplugin import TaurusWidgetPlugin
+    from .taurusplugin.taurusplugin import TaurusWidgetPlugin
 
     class QGroupWidgetPlugin(TaurusWidgetPlugin):
 
--- lib/taurus/qt/qtdesigner/tauruspluginplugin.py	(original)
+++ lib/taurus/qt/qtdesigner/tauruspluginplugin.py	(refactored)
@@ -26,12 +26,13 @@
 """
 tauruspluginplugin.py:
 """
+from __future__ import absolute_import
 
 from taurus.external.qt import QtDesigner
 
 
 def build_qtdesigner_widget_plugin(klass):
-    import taurusplugin
+    from . import taurusplugin
 
     class Plugin(taurusplugin.TaurusWidgetPlugin):
         WidgetClass = klass
@@ -74,7 +75,7 @@
                 #_log.debug("E2: Canceled %s (widget doesn't have getQtDesignerPluginInfo())" % name)
                 e2_nb += 1
                 cont = True
-            except Exception, e:
+            except Exception as e:
                 #_log.debug("E3: Canceled %s (%s)" % (name, str(e)))
                 e3_nb += 1
                 cont = True
@@ -82,7 +83,7 @@
             if cont:
                 continue
             for k in ('module', ):
-                if not qt_info.has_key(k):
+                if k not in qt_info:
                     #_log.debug("E4: Canceled %s (getQtDesignerPluginInfo doesn't have key %s)" % (name, k))
                     e4_nb += 1
                     cont = True
--- lib/taurus/qt/qtdesigner/taurusplugin/taurusplugin.py	(original)
+++ lib/taurus/qt/qtdesigner/taurusplugin/taurusplugin.py	(refactored)
@@ -36,6 +36,7 @@
     - 'model' - will have a '...' button that will open a customized dialog for
       editing the widget model (same has 'Edit model...' task menu item
 """
+from __future__ import print_function
 
 import inspect
 
@@ -103,11 +104,11 @@
                                                 designMode=True,
                                                 parent=parent)
             w = klass(*args, **kwargs)
-        except Exception, e:
+        except Exception as e:
             name = self._getWidgetClassName()
-            print 100 * "="
-            print "taurus designer plugin error creating %s: %s" % (name, str(e))
-            print 100 * "-"
+            print(100 * "=")
+            print("taurus designer plugin error creating %s: %s" % (name, str(e)))
+            print(100 * "-")
             import traceback
             traceback.print_exc()
             w = None
--- lib/taurus/qt/qtgui/base/taurusbase.py	(original)
+++ lib/taurus/qt/qtgui/base/taurusbase.py	(refactored)
@@ -736,7 +736,7 @@
         if self._format is None:
             try:
                 self._updateFormat(type(v))
-            except Exception, e:
+            except Exception as e:
                 self.warning(('Cannot update format. Reverting to default.' +
                               ' Reason: %r'), e)
                 self.setFormat(defaultFormatter)
@@ -2147,9 +2147,9 @@
             bottom = evt_value.min_value
             top = evt_value.max_value
             bottom = int(
-                bottom) if bottom != TaurusConfiguration.no_min_value else -sys.maxint
+                bottom) if bottom != TaurusConfiguration.no_min_value else -sys.maxsize
             top = int(
-                top) if top != TaurusConfiguration.no_max_value else sys.maxint
+                top) if top != TaurusConfiguration.no_max_value else sys.maxsize
             v.setRange(bottom, top)
             self.debug("Validator range set to %i-%i" % (bottom, top))
         elif isinstance(v, Qt.QDoubleValidator):
--- lib/taurus/qt/qtgui/base/tauruscontroller.py	(original)
+++ lib/taurus/qt/qtgui/base/tauruscontroller.py	(refactored)
@@ -204,7 +204,7 @@
                 for i in idx:
                     value = value[i]
             return widget.displayValue(value)
-        except Exception, e:
+        except Exception as e:
             return widget.getNoneValue()
 
     def displayValue(self, value):
--- lib/taurus/qt/qtgui/button/qbuttonbox.py	(original)
+++ lib/taurus/qt/qtgui/button/qbuttonbox.py	(refactored)
@@ -26,6 +26,7 @@
 """
 qbuttonbox.py:
 """
+from __future__ import print_function
 
 __all__ = ["QButtonBox"]
 
--- lib/taurus/qt/qtgui/button/taurusbutton.py	(original)
+++ lib/taurus/qt/qtgui/button/taurusbutton.py	(refactored)
@@ -25,6 +25,7 @@
 #############################################################################
 
 """This module provides a taurus QPushButton based widgets"""
+from __future__ import print_function
 
 __all__ = ["TaurusLauncherButton", "TaurusCommandButton", "TaurusLockButton"]
 
@@ -179,7 +180,7 @@
         if self._dialog.previousWidgetConfig is not None:
             try:
                 widget.applyConfig(self._dialog.previousWidgetConfig)
-            except Exception, e:
+            except Exception as e:
                 self.warning(
                     'Cannot apply previous configuration to widget. Reason: %s', repr(e))
 
@@ -347,7 +348,7 @@
                 modelobj.set_timeout_millis(int(self._timeout * 1000))
             result = modelobj.command_inout(self._command, self._castParameters(
                 self._parameters, self._command, modelobj))
-        except Exception, e:
+        except Exception as e:
             self.error('Unexpected error when executing command %s of %s: %s' % (
                 self._command, modelobj.getNormalName(), str(e)))
             raise
@@ -381,7 +382,7 @@
 
         try:
             param_type = dev.command_query(command).in_type
-        except Exception, e:
+        except Exception as e:
             self.warning(
                 'Cannot get parameters info for command %s:%s' % (command, str(e)))
             return parameters
@@ -666,7 +667,7 @@
         'Booo scary command!!\n Maybe you should think twice!')
 
     def f(*a):
-        print a
+        print(a)
     form.commandExecuted.connect(f)
     form.show()
     sys.exit(app.exec_())
--- lib/taurus/qt/qtgui/compact/abstractswitcher.py	(original)
+++ lib/taurus/qt/qtgui/compact/abstractswitcher.py	(refactored)
@@ -193,7 +193,7 @@
         for sig in self.enterEditSignals:
             try:
                 getattr(self.readWidget, sig).connect(self.enterEdit)
-            except Exception, e:
+            except Exception as e:
                 self.debug('Cannot connect signal. Reason: %s', e)
         # update size policy
         self._updateSizePolicy()
@@ -220,7 +220,7 @@
         for sig in self.exitEditSignals:
             try:
                 getattr(self.writeWidget, sig).connect(self.exitEdit)
-            except Exception, e:
+            except Exception as e:
                 if isinstance(e, AttributeError) and hasattr(Qt, "SIGNAL"):
                     # Support old-style signal
                     self.connect(self.writeWidget, Qt.SIGNAL(sig),
--- lib/taurus/qt/qtgui/compact/basicswitcher.py	(original)
+++ lib/taurus/qt/qtgui/compact/basicswitcher.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides some basic usable widgets based on TaurusReadWriteSwitcher
 """
+from __future__ import absolute_import
 
 __all__ = ["TaurusLabelEditRW", "TaurusBoolRW"]
 
@@ -33,7 +34,7 @@
 from taurus.external.qt import Qt
 from taurus.qt.qtgui.display import TaurusLabel, TaurusLed
 from taurus.qt.qtgui.input import TaurusValueLineEdit, TaurusValueCheckBox
-from abstractswitcher import TaurusReadWriteSwitcher
+from .abstractswitcher import TaurusReadWriteSwitcher
 
 
 class TaurusLabelEditRW(TaurusReadWriteSwitcher):
--- lib/taurus/qt/qtgui/console/__init__.py	(original)
+++ lib/taurus/qt/qtgui/console/__init__.py	(refactored)
@@ -35,7 +35,7 @@
 
 try:
     from silx.gui.console import IPythonWidget as TaurusConsole
-except Exception, e:
+except Exception as e:
     from taurus.qt.qtgui.display import TaurusFallBackWidget
 
     class TaurusConsole(TaurusFallBackWidget):
--- lib/taurus/qt/qtgui/container/taurusframe.py	(original)
+++ lib/taurus/qt/qtgui/container/taurusframe.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides basic taurus container widgets"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusFrame"]
 
@@ -31,7 +32,7 @@
 
 from taurus.external.qt import Qt
 from taurus.qt.qtgui.base import TaurusBaseComponent
-from taurusbasecontainer import TaurusBaseContainer
+from .taurusbasecontainer import TaurusBaseContainer
 
 
 class TaurusFrame(Qt.QFrame, TaurusBaseContainer):
--- lib/taurus/qt/qtgui/container/taurusgroupbox.py	(original)
+++ lib/taurus/qt/qtgui/container/taurusgroupbox.py	(refactored)
@@ -24,13 +24,14 @@
 #############################################################################
 
 """This module provides basic taurus group box widget"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusGroupBox"]
 
 __docformat__ = 'restructuredtext'
 
 from taurus.external.qt import Qt
-from taurusbasecontainer import TaurusBaseContainer
+from .taurusbasecontainer import TaurusBaseContainer
 
 
 class TaurusGroupBox(Qt.QGroupBox, TaurusBaseContainer):
--- lib/taurus/qt/qtgui/container/taurusgroupwidget.py	(original)
+++ lib/taurus/qt/qtgui/container/taurusgroupwidget.py	(refactored)
@@ -24,14 +24,15 @@
 #############################################################################
 
 """This module provides a taurus group widget"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusGroupWidget"]
 
 __docformat__ = 'restructuredtext'
 
 from taurus.external.qt import Qt
-from qcontainer import QGroupWidget
-from taurusbasecontainer import TaurusBaseContainer
+from .qcontainer import QGroupWidget
+from .taurusbasecontainer import TaurusBaseContainer
 
 
 class TaurusGroupWidget(QGroupWidget, TaurusBaseContainer):
--- lib/taurus/qt/qtgui/container/taurusmainwindow.py	(original)
+++ lib/taurus/qt/qtgui/container/taurusmainwindow.py	(refactored)
@@ -26,6 +26,7 @@
 """
 mainwindow.py: a main window implementation with many added features by default
 """
+from __future__ import absolute_import
 
 __all__ = ["TaurusMainWindow"]
 
@@ -37,7 +38,7 @@
 from taurus import tauruscustomsettings
 from taurus.core.util import deprecation_decorator
 from taurus.external.qt import Qt
-from taurusbasecontainer import TaurusBaseContainer
+from .taurusbasecontainer import TaurusBaseContainer
 
 from taurus.qt.qtcore.configuration import BaseConfigurableClass
 from taurus.qt.qtgui.util import ExternalAppAction
@@ -620,7 +621,7 @@
             ba = Qt.from_qvariant(settings.value(
                 "TaurusConfig"), 'toByteArray') or Qt.QByteArray()
             self.applyQConfig(ba)
-        except Exception, e:
+        except Exception as e:
             msg = 'Problem loading configuration from "%s". Some settings may not be restored.\n Details: %s' % (
                 unicode(settings.fileName()), repr(e))
             self.error(msg)
--- lib/taurus/qt/qtgui/container/taurusscrollarea.py	(original)
+++ lib/taurus/qt/qtgui/container/taurusscrollarea.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides basic taurus scroll area widget"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusScrollArea"]
 
@@ -32,7 +33,7 @@
 from taurus.external.qt import Qt
 from taurus.qt.qtgui.base import TaurusBaseComponent
 
-from taurusbasecontainer import TaurusBaseContainer
+from .taurusbasecontainer import TaurusBaseContainer
 
 
 class TaurusScrollArea(Qt.QScrollArea, TaurusBaseContainer):
--- lib/taurus/qt/qtgui/container/tauruswidget.py	(original)
+++ lib/taurus/qt/qtgui/container/tauruswidget.py	(refactored)
@@ -24,13 +24,14 @@
 #############################################################################
 
 """This module provides basic taurus container widget"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusWidget"]
 
 __docformat__ = 'restructuredtext'
 
 from taurus.external.qt import Qt
-from taurusbasecontainer import TaurusBaseContainer
+from .taurusbasecontainer import TaurusBaseContainer
 
 
 class TaurusWidget(Qt.QWidget, TaurusBaseContainer):
--- lib/taurus/qt/qtgui/dialog/taurusinputdialog.py	(original)
+++ lib/taurus/qt/qtgui/dialog/taurusinputdialog.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides a set of dialog based widgets"""
+from __future__ import print_function
 
 __all__ = ["TaurusInputDialog", "get_input"]
 
@@ -199,7 +200,7 @@
               data_type='Text', key="Memo", default_value="By default a memo is\na long thing")
 
     for d in [d1, d2, d3, d4, d5, d6, d7, d8]:
-        print get_input(input_data=d, title=d['prompt'])
+        print(get_input(input_data=d, title=d['prompt']))
 
 if __name__ == "__main__":
     main()
--- lib/taurus/qt/qtgui/dialog/taurusmessagebox.py	(original)
+++ lib/taurus/qt/qtgui/dialog/taurusmessagebox.py	(refactored)
@@ -334,7 +334,7 @@
     try:
         PyTango.Except.throw_exception('TangoException',
                                        'A simple tango exception', 'right here')
-    except PyTango.DevFailed, df1:
+    except PyTango.DevFailed as df1:
         try:
             import traceback
             import StringIO
--- lib/taurus/qt/qtgui/display/qled.py	(original)
+++ lib/taurus/qt/qtgui/display/qled.py	(refactored)
@@ -98,7 +98,7 @@
         :type  color: str
         :return: True is the given color name is valid or False otherwise
         :rtype: bool"""
-        return LedColor.has_key(name.upper())
+        return name.upper() in LedColor
 
     def _refresh(self):
         """internal usage only"""
--- lib/taurus/qt/qtgui/display/qpixmapwidget.py	(original)
+++ lib/taurus/qt/qtgui/display/qpixmapwidget.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module contains a pure Qt widget that displays an image"""
+from __future__ import absolute_import
 
 __all__ = ["QPixmapWidget"]
 
@@ -225,7 +226,7 @@
 
 def demo():
     "QPixmap Widget"
-    import demo.qpixmapwidgetdemo
+    from . import demo.qpixmapwidgetdemo
     return demo.qpixmapwidgetdemo.main()
 
 
--- lib/taurus/qt/qtgui/display/qsevensegment.py	(original)
+++ lib/taurus/qt/qtgui/display/qsevensegment.py	(refactored)
@@ -26,6 +26,7 @@
 """
 qsevensegmentdisplay.py
 """
+from __future__ import print_function
 
 __all__ = ['Q7SegDigit']
 
@@ -574,7 +575,7 @@
     dw = Q7SegDigit()
     dw.setValue(int(sys.argv[1]))
     dw.setVisible(True)
-    print dw
+    print(dw)
     a.exec_()
 
 
--- lib/taurus/qt/qtgui/display/tauruslabel.py	(original)
+++ lib/taurus/qt/qtgui/display/tauruslabel.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides a set of basic Taurus widgets based on QLabel"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusLabel"]
 
@@ -619,7 +620,7 @@
 
 def demo():
     "Label"
-    import demo.tauruslabeldemo
+    from . import demo.tauruslabeldemo
     return demo.tauruslabeldemo.main()
 
 
--- lib/taurus/qt/qtgui/display/tauruslcd.py	(original)
+++ lib/taurus/qt/qtgui/display/tauruslcd.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides a Taurus widget based on QLCDNumber"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusLCD"]
 
@@ -106,7 +107,7 @@
                 for i in idx:
                     value = value[i]
             return widget.displayValue(value)
-        except Exception, e:
+        except Exception as e:
             return widget.getNoneValue()
 
 
@@ -386,7 +387,7 @@
 
 def demo():
     "LCD"
-    import demo.tauruslcddemo
+    from . import demo.tauruslcddemo
     return demo.tauruslcddemo.main()
 
 
--- lib/taurus/qt/qtgui/display/taurusled.py	(original)
+++ lib/taurus/qt/qtgui/display/taurusled.py	(refactored)
@@ -25,6 +25,7 @@
 #############################################################################
 
 """This module provides a set of basic Taurus widgets based on QLed"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusLed"]
 
@@ -38,7 +39,7 @@
 from taurus.core import DataFormat, AttrQuality, DataType
 
 from taurus.qt.qtgui.base import TaurusBaseWidget
-from qled import QLed
+from .qled import QLed
 
 _QT_PLUGIN_INFO = {
     'module': 'taurus.qt.qtgui.display',
@@ -454,7 +455,7 @@
 
 def demo():
     "Led"
-    import demo.taurusleddemo
+    from . import demo.taurusleddemo
     return demo.taurusleddemo.main()
 
 
--- lib/taurus/qt/qtgui/extra_guiqwt/builder.py	(original)
+++ lib/taurus/qt/qtgui/extra_guiqwt/builder.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """Extension of :mod:`guiqwt.builder`"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusPlotItemBuilder", "make"]
 
@@ -31,8 +32,8 @@
 
 import guiqwt.builder
 
-from curve import TaurusCurveItem, TaurusTrendItem
-from image import (TaurusImageItem, TaurusRGBImageItem, TaurusEncodedImageItem,
+from .curve import TaurusCurveItem, TaurusTrendItem
+from .image import (TaurusImageItem, TaurusRGBImageItem, TaurusEncodedImageItem,
                    TaurusEncodedRGBImageItem, TaurusXYImageItem)
 from guiqwt.curve import CurveParam
 from guiqwt.image import ImageParam, XYImageItem
--- lib/taurus/qt/qtgui/extra_guiqwt/curve.py	(original)
+++ lib/taurus/qt/qtgui/extra_guiqwt/curve.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """Extension of :mod:`guiqwt.curve`"""
+from __future__ import print_function
 
 __all__ = ["TaurusCurveItem"]
 
@@ -356,11 +357,11 @@
         elif n == 2:
             mx, my = mx_my
         else:
-            print "Invalid model: %s\n" % mx_my
+            print("Invalid model: %s\n" % mx_my)
             parser.print_help(sys.stderr)
             sys.exit(1)
         # cycle colors
-        style = make.style.next()
+        style = next(make.style)
         color = style[0]
         linestyle = style[1:]
         plot.add_item(make.curve(mx, my, color=color,
--- lib/taurus/qt/qtgui/extra_guiqwt/curvesmodel.py	(original)
+++ lib/taurus/qt/qtgui/extra_guiqwt/curvesmodel.py	(refactored)
@@ -26,6 +26,7 @@
 """
 curvesmodel Model and view for new CurveItem configuration
 """
+from __future__ import print_function
 __all__ = ['TaurusCurveItemTableModel', 'CurveItemConf', 'CurveItemConfDlg']
 #raise UnimplementedError('Under Construction!')
 
@@ -108,7 +109,7 @@
         self.taurusparam = taurusparam
         if curveparam is None:
             curveparam = CurveParam()
-            style = make.style.next()  # cycle through colors and linestyles
+            style = next(make.style)  # cycle through colors and linestyles
             update_style_attr(style, curveparam)
             curveparam.line.width = 2
         self.curveparam = curveparam
@@ -488,7 +489,7 @@
         self.applied.emit()
 
     def onReload(self):
-        print "RELOAD!!! (todo)"
+        print("RELOAD!!! (todo)")
 
 
 #
--- lib/taurus/qt/qtgui/extra_guiqwt/image.py	(original)
+++ lib/taurus/qt/qtgui/extra_guiqwt/image.py	(refactored)
@@ -69,7 +69,7 @@
             # TODO: units should be used for setting some title in the colorbar
         try:
             v = self.filterData(v)
-        except Exception, e:
+        except Exception as e:
             self.info('Ignoring event. Reason: %s', e.message)
             return
         # this is the range of the z axis (color scale)
@@ -143,7 +143,7 @@
 
             try:
                 fmt, decoded_data = codec.decode(data)
-            except Exception, e:
+            except Exception as e:
                 self.info('Decoder error: %s', e.message)
                 raise e
 
--- lib/taurus/qt/qtgui/extra_guiqwt/plot.py	(original)
+++ lib/taurus/qt/qtgui/extra_guiqwt/plot.py	(refactored)
@@ -152,7 +152,7 @@
             else:
                 self.warning('Invalid model "%s" (Skipping)' % mx_my)
             # cycle styles
-            style = self.style.next()
+            style = next(self.style)
             color = style[0]
             linestyle = style[1:]
             # add the item
@@ -289,7 +289,7 @@
         # create and attach new TaurusCurveItems
         for m in modelNames:
             # cycle styles
-            style = self.style.next()
+            style = next(self.style)
             # add the item
             item = make.ttrend(m, color=style[0], linestyle=style[
                                1:], linewidth=2, taurusparam=copy.deepcopy(self.defaultTaurusparam))
--- lib/taurus/qt/qtgui/extra_guiqwt/scales.py	(original)
+++ lib/taurus/qt/qtgui/extra_guiqwt/scales.py	(refactored)
@@ -26,6 +26,7 @@
 """
 scales.py: Custom scales used by taurus.qt.qtgui.plot module
 """
+from __future__ import print_function
 __all__ = ["DateTimeScaleEngine", "DeltaTimeScaleEngine", "FixedLabelsScaleEngine",
            "FancyScaleDraw", "TaurusTimeScaleDraw", "DeltaTimeScaleDraw",
            "FixedLabelsScaleDraw"]
@@ -326,8 +327,8 @@
         t = datetime.fromtimestamp(val)
         try:  # If the scaleDiv was created by a DateTimeScaleEngine it has a _datetimeLabelFormat
             s = t.strftime(self._datetimeLabelFormat)
-        except AttributeError, e:
-            print "Warning: cannot get the datetime label format (Are you using a DateTimeScaleEngine?)"
+        except AttributeError as e:
+            print("Warning: cannot get the datetime label format (Are you using a DateTimeScaleEngine?)")
             s = t.isoformat(' ')
         return qwt.QwtText(s)
 
--- lib/taurus/qt/qtgui/graphic/jdraw/jdraw_parser.py	(original)
+++ lib/taurus/qt/qtgui/graphic/jdraw/jdraw_parser.py	(refactored)
@@ -325,7 +325,7 @@
     try:
         p = yacc.yacc(tabmodule=jdraw_yacctab, debugfile=None, write_tables=1,
                       **common_kwargs)
-    except Exception, e:
+    except Exception as e:
         msg = ('Error creating jdraw parser.\n' +
                'HINT: Try removing jdraw_lextab.* and jdraw_yacctab.* from %s' %
                outputdir)
--- lib/taurus/qt/qtgui/graphic/jdraw/jdraw.py	(original)
+++ lib/taurus/qt/qtgui/graphic/jdraw/jdraw.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module contains the graphics factory for the jdraw file format"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusJDrawGraphicsFactory"]
 
@@ -371,9 +372,9 @@
                 pen.setWidth(lineWidth)
                 pen.setStyle(LINESTYLE_JDW2QT[params.get("lineStyle", 0)])
             item.setPen(pen)
-        except AttributeError, ae:
+        except AttributeError as ae:
             pass
-        except Exception, e:
+        except Exception as e:
             self.warning('jdraw.set_common_params(%s(%s)).(foreground,width,style) failed!: \n\t%s' % (
                 type(item).__name__, name, traceback.format_exc()))
 
@@ -419,5 +420,5 @@
         return
 
 if __name__ == "__main__":
-    import jdraw_view
+    from . import jdraw_view
     jdraw_view.jdraw_view_main()
--- lib/taurus/qt/qtgui/graphic/jdraw/jdraw_view.py	(original)
+++ lib/taurus/qt/qtgui/graphic/jdraw/jdraw_view.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module contains the graphics view widget for jdraw files"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusJDrawSynopticsView"]
 
@@ -39,7 +40,7 @@
 from taurus.qt.qtcore.mimetypes import TAURUS_ATTR_MIME_TYPE, TAURUS_DEV_MIME_TYPE, TAURUS_MODEL_MIME_TYPE
 from taurus.qt.qtgui.base import TaurusBaseWidget
 
-import jdraw_parser
+from . import jdraw_parser
 
 
 class TaurusJDrawSynopticsView(Qt.QGraphicsView, TaurusBaseWidget):
@@ -268,7 +269,7 @@
         # self.fitting()
 
     def getGraphicsFactory(self, delayed=False):
-        import jdraw
+        from . import jdraw
         # self.parent())
         return jdraw.TaurusJDrawGraphicsFactory(self, alias=(self.alias or None), delayed=delayed)
 
--- lib/taurus/qt/qtgui/graphic/taurusgraphic.py	(original)
+++ lib/taurus/qt/qtgui/graphic/taurusgraphic.py	(refactored)
@@ -25,6 +25,7 @@
 """
 taurusgraphic.py:
 """
+from __future__ import print_function
 
 # TODO: Tango-centric
 
@@ -140,7 +141,7 @@
         p = self.parent()
         while True:
             item = p.getQueue().get(True)
-            if type(item) in types.StringTypes:
+            if type(item) in (str,):
                 if item == "exit":
                     break
                 else:
@@ -214,7 +215,7 @@
                 self.debug = self.info = self.warning = self.error = lambda l: self.logger.warning(
                     l)
         except:
-            print 'Unable to initialize TaurusGraphicsSceneLogger: %s' % traceback.format_exc()
+            print('Unable to initialize TaurusGraphicsSceneLogger: %s' % traceback.format_exc())
 
         try:
             if parent and parent.panelClass() is not None:
@@ -439,7 +440,7 @@
                     elif not last_was_separator:
                         menu.addSeparator()
                         last_was_separator = True
-                except Exception, e:
+                except Exception as e:
                     self.warning('Unable to add Menu Action: %s:%s' % (k, e))
                 return last_was_separator
             if (mouseEvent.button() == Qt.Qt.RightButton):
@@ -575,7 +576,7 @@
                 if item not in self._selectedItems:
                     self._selectedItems.append(item)
                 retval = True
-            except Exception, e:
+            except Exception as e:
                 self.warning('selectGraphicsItem(%s) failed! %s' %
                              (getattr(item, '_name', item), str(e)))
                 self.warning(traceback.format_exc())
--- lib/taurus/qt/qtgui/icon/catalog.py	(original)
+++ lib/taurus/qt/qtgui/icon/catalog.py	(refactored)
@@ -24,6 +24,7 @@
 """
 This module provides an icon catalog widget
 """
+from __future__ import print_function
 
 import os
 import hashlib
@@ -57,7 +58,7 @@
 
         for path in Qt.QDir.searchPaths(prefix):
             if not os.path.exists(path):
-                print " %s not found. Skipping.!" % path
+                print(" %s not found. Skipping.!" % path)
                 continue
 
             for fname in os.listdir(path):
--- lib/taurus/qt/qtgui/icon/icon.py	(original)
+++ lib/taurus/qt/qtgui/icon/icon.py	(refactored)
@@ -135,7 +135,7 @@
     for filename in pathfilenames:
         try:
             pathmap = json.load(open(filename))
-        except Exception, e:
+        except Exception as e:
             __LOGGER.error('Error registering "%s": %r', filename, e)
             pathmap = []
 
--- lib/taurus/qt/qtgui/icon/__init__.py	(original)
+++ lib/taurus/qt/qtgui/icon/__init__.py	(refactored)
@@ -27,6 +27,7 @@
 Utilities for using the bundled icons in Taurus and for registering external
 sources of icons.
 """
+from __future__ import absolute_import
 
-from icon import *
-from catalog import QIconCatalog
+from .icon import *
+from .catalog import QIconCatalog
--- lib/taurus/qt/qtgui/__init__.py	(original)
+++ lib/taurus/qt/qtgui/__init__.py	(refactored)
@@ -27,12 +27,13 @@
 taurus models. The widgets are generic in the sence that they do not assume any
 behavior associated with a specific HW device. They intend to represent only
 abstract model data."""
+from __future__ import absolute_import
 
 __docformat__ = 'restructuredtext'
 
 
 # register icon path files and icon theme on import of taurus.qt.qtgui
-import icon as __icon
+from . import icon as __icon
 import os
 import sys
 import glob
--- lib/taurus/qt/qtgui/input/choicedlg.py	(original)
+++ lib/taurus/qt/qtgui/input/choicedlg.py	(refactored)
@@ -24,6 +24,7 @@
 ###########################################################################
 
 """This package provides a dialog for graphically choosing a Taurus class"""
+from __future__ import print_function
 
 __all__ = ["GraphicalChoiceDlg", "GraphicalChoiceWidget"]
 
@@ -255,7 +256,7 @@
         for k in row:
             pixmaps[k] = getCachedPixmap('snapshot:%s.png' % k)
 
-    print GraphicalChoiceDlg.getChoice(parent=None, title='Panel chooser', msg='Choose the type of Panel:', choices=choices, pixmaps=pixmaps)
+    print(GraphicalChoiceDlg.getChoice(parent=None, title='Panel chooser', msg='Choose the type of Panel:', choices=choices, pixmaps=pixmaps))
 
     sys.exit()
 
--- lib/taurus/qt/qtgui/input/taurusspinbox.py	(original)
+++ lib/taurus/qt/qtgui/input/taurusspinbox.py	(refactored)
@@ -26,10 +26,11 @@
 """
 This module provides a set of basic taurus widgets based on QAbstractSpinBox
 """
+from __future__ import absolute_import
 
 from taurus.external.qt import Qt
 
-from tauruslineedit import TaurusValueLineEdit
+from .tauruslineedit import TaurusValueLineEdit
 from taurus.qt.qtgui.icon import getStandardIcon
 from taurus.external.pint import Quantity
 
--- lib/taurus/qt/qtgui/input/tauruswheel.py	(original)
+++ lib/taurus/qt/qtgui/input/tauruswheel.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides a set of basic taurus widgets based on QWheelEdit"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusWheelEdit"]
 
@@ -34,7 +35,7 @@
 
 from taurus.core.taurusbasetypes import TaurusEventType
 from taurus.qt.qtgui.base import TaurusBaseWritableWidget
-from qwheel import QWheelEdit
+from .qwheel import QWheelEdit
 
 
 class TaurusWheelEdit(QWheelEdit, TaurusBaseWritableWidget):
--- lib/taurus/qt/qtgui/panel/qdataexportdialog.py	(original)
+++ lib/taurus/qt/qtgui/panel/qdataexportdialog.py	(refactored)
@@ -25,6 +25,7 @@
 
 """DataExportDlg.py: A Qt dialog for showing and exporting x-y Ascii data from
 one or more curves"""
+from __future__ import print_function
 
 __all__ = ["QDataExportDialog"]
 
@@ -123,9 +124,9 @@
                 else:
                     for x,y in zip(xdata, ydata):
                         text+="%r\t%r\n" % (x, y)
-                print >> ofile, str(text)
-            else:
-                print >> ofile, str(self.dataTE.toPlainText())
+                print(str(text), file=ofile)
+            else:
+                print(str(self.dataTE.toPlainText()), file=ofile)
         except:
             Qt.QMessageBox.warning(self,
                                    "File saving failed",
--- lib/taurus/qt/qtgui/panel/qdoublelist.py	(original)
+++ lib/taurus/qt/qtgui/panel/qdoublelist.py	(refactored)
@@ -28,6 +28,7 @@
 qdoublelist.py: Provides a generic dialog containing two list which can move
 items from one to the other
 """
+from __future__ import print_function
 
 __all__ = ["QDoubleListDlg"]
 
@@ -132,9 +133,9 @@
                          list1=['11', '22'], list2=['123', '33'])
     result = dlg.exec_()
 
-    print "Result", result
-    print "list1", dlg.getAll1()
-    print "list2", dlg.getAll2()
+    print("Result", result)
+    print("list1", dlg.getAll1())
+    print("list2", dlg.getAll2())
 
 
 if __name__ == "__main__":
--- lib/taurus/qt/qtgui/panel/report/albareport.py	(original)
+++ lib/taurus/qt/qtgui/panel/report/albareport.py	(refactored)
@@ -24,13 +24,14 @@
 #############################################################################
 
 """This module provides a panel to display taurus messages"""
+from __future__ import absolute_import
 
 __all__ = ["TicketReportHandler"]
 
 __docformat__ = 'restructuredtext'
 
 from taurus.external.qt import Qt
-from basicreport import SendMailDialog, SMTPReportHandler
+from .basicreport import SendMailDialog, SMTPReportHandler
 
 
 class SendTicketDialog(SendMailDialog):
--- lib/taurus/qt/qtgui/panel/taurusconfigeditor.py	(original)
+++ lib/taurus/qt/qtgui/panel/taurusconfigeditor.py	(refactored)
@@ -138,7 +138,7 @@
                 key = val[0]
             dict[key] = self.removeBranch(dict[key], path)
             if self._delete == True:
-                if not dict.has_key('__orderedConfigNames__'):
+                if '__orderedConfigNames__' not in dict:
                     return dict
                 dict['__orderedConfigNames__'] = self.removeBranch(
                     dict['__orderedConfigNames__'], path)
@@ -150,7 +150,7 @@
                     return dict
                 dict.remove(val[0])
                 return dict
-            if not dict.has_key('__orderedConfigNames__'):
+            if '__orderedConfigNames__' not in dict:
                 self._delete = True
             dict.pop(val[0])
             return dict
@@ -346,7 +346,7 @@
         if qstate is not None and not qstate.isNull():
             try:
                 result = pickle.loads(qstate.data())
-            except Exception, e:
+            except Exception as e:
                 msg = 'problems loading TaurusConfig: \n%s' % repr(e)
                 Qt.QMessageBox.critical(None, 'Error loading settings', msg)
         return result
--- lib/taurus/qt/qtgui/panel/taurusdemo.py	(original)
+++ lib/taurus/qt/qtgui/panel/taurusdemo.py	(refactored)
@@ -23,6 +23,7 @@
 ##
 #############################################################################
 
+from __future__ import print_function
 import sys
 import operator
 
@@ -75,10 +76,10 @@
                 continue
             try:
                 self.addDemo(demo_func.__doc__, demo_func, group)
-            except Exception, e:
-                print 80 * "-"
-                print "Problems adding demo", demo_name
-                print e
+            except Exception as e:
+                print(80 * "-")
+                print("Problems adding demo", demo_name)
+                print(e)
 
     def addGroup(self, name):
         g = Qt.QGroupBox(name)
@@ -111,12 +112,12 @@
             dialog.setLayout(layout)
             layout.addWidget(w)
             dialog.exec_()
-        except Exception, e:
+        except Exception as e:
             if dialog is not None:
                 dialog.done(0)
                 dialog.hide()
                 dialog = None
-            print str(e)
+            print(str(e))
             return
             d = Qt.QErrorMessage()
             d.showMessage(str(e))
--- lib/taurus/qt/qtgui/panel/taurusform.py	(original)
+++ lib/taurus/qt/qtgui/panel/taurusform.py	(refactored)
@@ -24,6 +24,8 @@
 #############################################################################
 
 """This module contains taurus Qt form widgets"""
+from __future__ import print_function
+from __future__ import absolute_import
 
 __all__ = ["TaurusAttrForm", "TaurusCommandsForm", "TaurusForm"]
 
@@ -40,7 +42,7 @@
                                         TAURUS_MODEL_LIST_MIME_TYPE, TAURUS_MODEL_MIME_TYPE)
 from taurus.qt.qtgui.container import TaurusWidget, TaurusScrollArea
 from taurus.qt.qtgui.button import QButtonBox, TaurusCommandButton
-from taurusmodelchooser import TaurusModelChooser
+from .taurusmodelchooser import TaurusModelChooser
 
 
 class ParameterCB(Qt.QComboBox):
@@ -979,7 +981,7 @@
     class DummyCW(TaurusValue):
 
         def setModel(self, model):
-            print "!!!!! IN DUMMYCW.SETMODEL", model
+            print("!!!!! IN DUMMYCW.SETMODEL", model)
             TaurusValue.setModel(self, model + '/double_scalar')
 
     models = ['sys/database/2', 'sys/tg_test/1', 'sys/tg_test/1/short_spectrum',
--- lib/taurus/qt/qtgui/panel/taurusinputpanel.py	(original)
+++ lib/taurus/qt/qtgui/panel/taurusinputpanel.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides an Input panel (usually used inside a TaurusDialog)"""
+from __future__ import print_function
 
 __all__ = ["TaurusInputPanel"]
 
@@ -402,7 +403,7 @@
     class Listener(object):
 
         def on_accept(self):
-            print "user selected", self.panel.value()
+            print("user selected", self.panel.value())
 
     d = dict(prompt="What's your favourite car brand?",
              data_type=["Mazda", "Skoda", "Citroen",
--- lib/taurus/qt/qtgui/panel/taurusmessagepanel.py	(original)
+++ lib/taurus/qt/qtgui/panel/taurusmessagepanel.py	(refactored)
@@ -580,7 +580,7 @@
     try:
         PyTango.Except.throw_exception(
             'TangoException', 'A simple tango exception', 'right here')
-    except PyTango.DevFailed, df1:
+    except PyTango.DevFailed as df1:
         try:
             import traceback
             import StringIO
--- lib/taurus/qt/qtgui/panel/taurusmodelchooser.py	(original)
+++ lib/taurus/qt/qtgui/panel/taurusmodelchooser.py	(refactored)
@@ -26,6 +26,8 @@
 """
 AttributeChooser.py: widget for choosing (a list of) attributes from a tango DB
 """
+from __future__ import print_function
+from __future__ import absolute_import
 
 __all__ = ["TaurusModelSelectorTree", "TaurusModelChooser"]
 
@@ -35,7 +37,7 @@
 from taurus.qt.qtgui.container import TaurusWidget
 from taurus.qt.qtgui.tree import TaurusDbTreeWidget
 from taurus.core.util.containers import CaselessList
-from taurusmodellist import TaurusModelList
+from .taurusmodellist import TaurusModelList
 
 
 class TaurusModelSelectorTree(TaurusWidget):
@@ -358,7 +360,7 @@
         host = None
 
     app = Qt.QApplication(args)
-    print TaurusModelChooser.modelChooserDlg(host=host)
+    print(TaurusModelChooser.modelChooserDlg(host=host))
     sys.exit()
 
 if __name__ == "__main__":
--- lib/taurus/qt/qtgui/panel/taurusvalue.py	(original)
+++ lib/taurus/qt/qtgui/panel/taurusvalue.py	(refactored)
@@ -820,7 +820,7 @@
         try:
             klass = self.readWidgetClassFactory(self.readWidgetClassID)
             self._readWidget = self._newSubwidget(self._readWidget, klass)
-        except Exception, e:
+        except Exception as e:
             self._destroyWidget(self._readWidget)
             self._readWidget = Qt.QLabel('[Error]')
             msg = 'Error creating read widget:\n' + str(e)
@@ -1145,7 +1145,7 @@
                 widget_configdict = configdict[key]
                 getattr(self, 'set%sClass' % key)(
                     widget_configdict.get('classid', None))
-                if widget_configdict.has_key('delegate'):
+                if 'delegate' in widget_configdict:
                     widget = getattr(self, key[0].lower() + key[1:])()
                     if isinstance(widget, BaseConfigurableClass):
                         widget.applyConfig(widget_configdict[
--- lib/taurus/qt/qtgui/plot/arrayedit.py	(original)
+++ lib/taurus/qt/qtgui/plot/arrayedit.py	(refactored)
@@ -26,12 +26,13 @@
 """
 arrayedit.py: Widget for editing a spectrum/array via control points
 """
+from __future__ import absolute_import
 
 
 import numpy
 from taurus.external.qt import Qt, Qwt5
 from taurus.qt.qtgui.util.ui import UILoadable
-from curvesAppearanceChooserDlg import CurveAppearanceProperties
+from .curvesAppearanceChooserDlg import CurveAppearanceProperties
 
 
 @UILoadable
--- lib/taurus/qt/qtgui/plot/curveprops.py	(original)
+++ lib/taurus/qt/qtgui/plot/curveprops.py	(refactored)
@@ -26,6 +26,7 @@
 """
 curveprops: Model and view for curve properties
 """
+from __future__ import absolute_import
 __all__ = ['CurveConf', 'CurvesTableModel',
            'ExtendedSelectionModel', 'CurvePropertiesView']
 #raise NotImplementedError('Under Construction!')
@@ -40,7 +41,7 @@
 from taurus.qt.qtcore.mimetypes import TAURUS_MODEL_LIST_MIME_TYPE, TAURUS_ATTR_MIME_TYPE
 from taurus.qt.qtgui.util.ui import UILoadable
 
-from curvesAppearanceChooserDlg import NamedLineStyles, ReverseNamedLineStyles, \
+from .curvesAppearanceChooserDlg import NamedLineStyles, ReverseNamedLineStyles, \
     NamedCurveStyles, ReverseNamedCurveStyles, \
     NamedSymbolStyles, ReverseNamedSymbolStyles, \
     NamedColors, CurveAppearanceProperties
--- lib/taurus/qt/qtgui/plot/curvesAppearanceChooserDlg.py	(original)
+++ lib/taurus/qt/qtgui/plot/curvesAppearanceChooserDlg.py	(refactored)
@@ -28,6 +28,7 @@
     A Qt dialog for choosing plot appearance (symbols and lines)
     for a QwtPlot-derived widget (like Taurusplot)
 """
+from __future__ import print_function
 
 import copy
 
@@ -430,10 +431,10 @@
 
     def _print(self):
         """Just for debug"""
-        print "-" * 77
+        print("-" * 77)
         for k in self.propertyList:
-            print k + "= ", self.__getattribute__(k)
-        print "-" * 77
+            print(k + "= ", self.__getattribute__(k))
+        print("-" * 77)
 
     @staticmethod
     def inConflict_update_a(a, b):
--- lib/taurus/qt/qtgui/plot/monitor.py	(original)
+++ lib/taurus/qt/qtgui/plot/monitor.py	(refactored)
@@ -26,6 +26,7 @@
 """
 monitor.py: Specialized mini-trend widget to monitor some scalar value
 """
+from __future__ import print_function
 
 from taurus.external.qt import Qt
 from taurus.qt.qtgui.plot import TaurusTrend
@@ -109,7 +110,7 @@
         elif a.startswith('-config='):
             CONFIG = a.split('=')[-1]
         elif a.startswith('-'):  # whatever other argument starting by "-"
-            print "\n Usage: \n%s [-xe|-xt] [-config=configfilename] [model1 [model2] ...]\n" % sys.argv[0]
+            print("\n Usage: \n%s [-xe|-xt] [-config=configfilename] [model1 [model2] ...]\n" % sys.argv[0])
             sys.exit(1)
         else:  # anything that is not a parameter is interpreted as a model
             MODELS.append(a)
--- lib/taurus/qt/qtgui/plot/qwtdialog.py	(original)
+++ lib/taurus/qt/qtgui/plot/qwtdialog.py	(refactored)
@@ -26,6 +26,8 @@
 """
 qwtdialog.py: Dialogs for Taurusplot
 """
+from __future__ import print_function
+from __future__ import absolute_import
 
 __all__ = ["TaurusPlotConfigDialog"]
 
@@ -72,7 +74,7 @@
 
         # insert the CurvesAppearanceWidget
         #(@TODO:must be changed to be done directly in the ui, but I couldn't make the widget available to TaurusDesigner)
-        from curvesAppearanceChooserDlg import CurvesAppearanceChooser
+        from .curvesAppearanceChooserDlg import CurvesAppearanceChooser
         layout = Qt.QVBoxLayout()
         self.curvesAppearanceChooser = CurvesAppearanceChooser(None)
         layout.addWidget(self.curvesAppearanceChooser)
@@ -165,7 +167,7 @@
             elif scaleType == Qwt5.QwtScaleTransformation.Log10:
                 axes[axis].setCurrentIndex(1)
             else:
-                raise TypeError, "TaurusPlotConfigDialog::__init__(): unexpected axis scale type (linear or logarihtmic expected)"
+                raise TypeError("TaurusPlotConfigDialog::__init__(): unexpected axis scale type (linear or logarihtmic expected)")
         self.ui.xModeComboBox.setEnabled(not self.parent.getXIsTime())
 
         # determine which axes are visible
@@ -268,11 +270,11 @@
         if strtime[-1] in timeunits.keys():
             try:
                 return float(strtime[:-1]) * timeunits[strtime[-1]]
-            except Exception, e:
-                print '[str2deltatime] No format could be applied to "%s"' % strtime
+            except Exception as e:
+                print('[str2deltatime] No format could be applied to "%s"' % strtime)
                 return None
         else:
-            print '[str2deltatime] Non-supported unit "%s"' % strtime[-1]
+            print('[str2deltatime] Non-supported unit "%s"' % strtime[-1])
             return None
 
     def strtime2epoch(self, strtime):
@@ -321,12 +323,12 @@
                     t = (lt[0], lt[1], lt[2], t[3], t[
                          4], lt[5], lt[6], lt[7], lt[8])
                     break
-            except Exception, e:
+            except Exception as e:
                 pass
         if t:
             return time.mktime(t)
         else:
-            print 'No format could be applied to "%s"' % strtime
+            print('No format could be applied to "%s"' % strtime)
             return None
 
     def validate(self):
--- lib/taurus/qt/qtgui/plot/qwtplot.py	(original)
+++ lib/taurus/qt/qtgui/plot/qwtplot.py	(refactored)
@@ -23,9 +23,9 @@
 ##
 #############################################################################
 
-print "*" * 77
-print \
-    """
+from __future__ import print_function
+print("*" * 77)
+print("""
 If you are seeing this, it is because you tried to access qwtplot.py directly.
 All funcionality has been moved to taurusplot.py, taurustrend.py and scales.py
 
@@ -34,5 +34,5 @@
 
 If you were trying to launch a stand-alone Taurusplot or TaurusTrend from a script,
 you should update such script.
-"""
-print "*" * 77
+""")
+print("*" * 77)
--- lib/taurus/qt/qtgui/plot/scales.py	(original)
+++ lib/taurus/qt/qtgui/plot/scales.py	(refactored)
@@ -26,6 +26,7 @@
 """
 scales.py: Custom scales used by taurus.qt.qtgui.plot module
 """
+from __future__ import print_function
 __all__ = ["DateTimeScaleEngine", "DeltaTimeScaleEngine", "FixedLabelsScaleEngine",
            "FancyScaleDraw", "TaurusTimeScaleDraw", "DeltaTimeScaleDraw",
            "FixedLabelsScaleDraw"]
@@ -318,8 +319,8 @@
         t = datetime.fromtimestamp(val)
         try:  # If the scaleDiv was created by a DateTimeScaleEngine it has a _datetimeLabelFormat
             s = t.strftime(self._datetimeLabelFormat)
-        except AttributeError, e:
-            print "Warning: cannot get the datetime label format (Are you using a DateTimeScaleEngine?)"
+        except AttributeError as e:
+            print("Warning: cannot get the datetime label format (Are you using a DateTimeScaleEngine?)")
             s = t.isoformat(' ')
         return Qwt5.QwtText(s)
 
--- lib/taurus/qt/qtgui/plot/taurusarrayedit.py	(original)
+++ lib/taurus/qt/qtgui/plot/taurusarrayedit.py	(refactored)
@@ -24,12 +24,13 @@
 #############################################################################
 
 
+from __future__ import absolute_import
 from taurus.external.qt import Qt
 import taurus
 import numpy
 
 from taurus.qt.qtgui.container import TaurusWidget
-from arrayedit import ArrayEditor
+from .arrayedit import ArrayEditor
 
 
 class TaurusArrayEditor(TaurusWidget):
@@ -137,7 +138,7 @@
                 x = numpy.arange(y.size)
             else:
                 x = numpy.array(self._xAttr.read().rvalue)
-        except Exception, e:
+        except Exception as e:
             self.error('Error reading from attribute(s): %s' % (str(e)))
             if not quiet:
                 Qt.QMessageBox.warning(
@@ -182,7 +183,7 @@
             if self._xAttr is not None and numpy.any(self._xAttr.read(cache=False).wvalue != x):
                 raise IOError('Unexpected Write error: %s' %
                               self._xAttr.getFullName())
-        except Exception, e:
+        except Exception as e:
             self.error('Error writing to attribute(s): %s' % (str(e)))
             if not quiet:
                 Qt.QMessageBox.warning(
--- lib/taurus/qt/qtgui/plot/taurusplotconf.py	(original)
+++ lib/taurus/qt/qtgui/plot/taurusplotconf.py	(refactored)
@@ -26,6 +26,8 @@
 """
 TaurusPlotConf: widget for configurating the contents and appearance of a TaurusPlot
 """
+from __future__ import print_function
+from __future__ import absolute_import
 
 __all__ = ['TaurusPlotConfDlg']
 
@@ -35,7 +37,7 @@
 from taurus.external.qt import Qt, Qwt5
 from taurus.qt.qtgui.util.ui import UILoadable
 
-import curveprops
+from . import curveprops
 try:
     import taurus.qt.qtgui.extra_nexus as extra_nexus
 except:
@@ -121,7 +123,7 @@
         return new
 
     def onModelsAdded(self, models):
-        print models
+        print(models)
         nmodels = len(models)
         rowcount = self.model.rowCount()
         self.model.insertRows(rowcount, nmodels)
@@ -130,14 +132,14 @@
                                value=Qt.QVariant(m))
 
     def onApply(self):
-        print "APPLY!!! (todo)"
+        print("APPLY!!! (todo)")
         curveConfs = self.model.dumpData()
 
         for c in curveConfs:
-            print repr(c)
+            print(repr(c))
 
     def onReload(self):
-        print "RELOAD!!! (todo)"
+        print("RELOAD!!! (todo)")
 
 
 class demo(Qt.QDialog):
@@ -200,7 +202,7 @@
 
     def onData(self):
         cmds = self.model.dumpData()
-        print self.model.curves
+        print(self.model.curves)
 
 
 def main1():
--- lib/taurus/qt/qtgui/plot/taurusplot.py	(original)
+++ lib/taurus/qt/qtgui/plot/taurusplot.py	(refactored)
@@ -26,6 +26,8 @@
 """
 taurusplot.py: Generic graphical plotting widget for Taurus
 """
+from __future__ import print_function
+from __future__ import absolute_import
 __all__ = ["TaurusCurve", "TaurusCurveMarker",
            "TaurusXValues", "TaurusPlot", "isodatestr2float"]
 
@@ -48,7 +50,7 @@
 from taurus.qt.qtgui.base import TaurusBaseComponent, TaurusBaseWidget
 from taurus.qt.qtgui.plot import TaurusPlotConfigDialog, FancyScaleDraw,\
     DateTimeScaleEngine, FixedLabelsScaleEngine, FixedLabelsScaleDraw
-from curvesAppearanceChooserDlg import CurveAppearanceProperties
+from .curvesAppearanceChooserDlg import CurveAppearanceProperties
 
 
 def isodatestr2float(s, sep='_'):
@@ -535,7 +537,7 @@
         '''
         if self.isRawData:
             #self.warning('fireEvent of a RawData curve has been called by %s'%repr(self.sender()))
-            raise StandardError('called handleEvent of a RawData curve')
+            raise Exception('called handleEvent of a RawData curve')
             return
         model = src if src is not None else self.getModelObj()
         if model is None:
@@ -554,7 +556,7 @@
             return
         try:
             self.setXYFromModel(value)
-        except Exception, e:
+        except Exception as e:
             self._onDroppedEvent(reason=str(e))
             return
         self._updateMarkers()
@@ -1457,7 +1459,7 @@
 
     def __debug(self, *args, **kwargs):
         '''put code here that you want to debug'''
-        print "!!!!!!!!!!!!!!!1", self.pos()
+        print("!!!!!!!!!!!!!!!1", self.pos())
         Qt.QToolTip.showText(self.mapToGlobal(self.pos()),
                              "ASDASDASDASD DASDAS ASDA", self)
 
@@ -1568,7 +1570,7 @@
         TaurusPlot.getPlot()'''
         self.info(
             'DEPRECATION WARNING!: Calling TaurusPlot.getPlot() is deprecated. Use the TaurusPlot object itself instead')
-        print self.sender()
+        print(self.sender())
         return self
 
     def getCurve(self, name):
@@ -1807,11 +1809,11 @@
             properties = CurveAppearanceProperties(
                 lColor=self._curvePens.next().color(), lWidth=2)
         # Deprecation Warning:
-        if rawdata.has_key("pen") or rawdata.has_key("style"):
+        if "pen" in rawdata or "style" in rawdata:
             raise DeprecationWarning(
                 "'pen' or 'style' are no longer supported. Use the properties parameter instead")
-        if rawdata.has_key("name"):
-            if rawdata.has_key("title"):
+        if "name" in rawdata:
+            if "title" in rawdata:
                 self.error(
                     'Inconsistence: both "name" and "title" passed for rawdata. Use "title" only')
             else:
@@ -1861,7 +1863,7 @@
             name = id
         self.curves_lock.acquire()
         try:
-            if self.curves.has_key(name):
+            if name in self.curves:
                 curve = self.curves.get(name)
                 if curve.isRawData:
                     self.detachRawData(name)
@@ -1942,7 +1944,7 @@
         """
         self.curves_lock.acquire()
         try:
-            if self.curves.has_key(curvename):
+            if curvename in self.curves:
                 data = self.curves[curvename].data()
                 x = [data.x(i) for i in xrange(data.size())]
                 y = [data.y(i) for i in xrange(data.size())]
@@ -1992,7 +1994,7 @@
                 xname = xnames[i]
                 name = str(name)
                 self.debug('updating curve %s' % name)
-                if not self.curves.has_key(name):
+                if name not in self.curves:
                     curve = TaurusCurve(name, xname, self,
                                         optimized=self.isOptimizationEnabled())
                     curve.attach(self)
@@ -2003,7 +2005,7 @@
                         curve.attachMaxMarker(self)
                     if self._showMinPeaks:
                         curve.attachMinMarker(self)
-                    curve.setPen(self._curvePens.next())
+                    curve.setPen(next(self._curvePens))
                     curve.setUseParentModel(self.getUseParentModel())
                     curve.setTitleText(self.getDefaultCurvesTitle())
                     curve.registerDataChanged(self, self.curveDataChanged)
@@ -2399,7 +2401,7 @@
                     rawdatadict[name] = curve.getRawData()
                 else:
                     tangodict[name] = curve.getModel()
-        except Exception, e:
+        except Exception as e:
             self.error(
                 'Exception while gathering curves configuration info' + str(e))
         finally:
@@ -2889,8 +2891,8 @@
         :param axis: (Qwt5.QwtPlot.Axis) the axis
         """
         if not Qwt5.QwtPlot.axisValid(axis):
-            raise ValueError, "TaurusPlot::setCurvesYAxis. Invalid axis ID: " + \
-                repr(axis)
+            raise ValueError("TaurusPlot::setCurvesYAxis. Invalid axis ID: " + \
+                repr(axis))
         self.curves_lock.acquire()
         try:
             for curveName in curvesNamesList:
@@ -3725,12 +3727,12 @@
 
         def exportIfAllCurves(curve, trend=w, counters=curves):
             curve = str(curve)
-            print '*' * 10 + ' %s: Event received for %s  ' % (datetime.now().isoformat(), curve) + '*' * 10
+            print('*' * 10 + ' %s: Event received for %s  ' % (datetime.now().isoformat(), curve) + '*' * 10)
             if curve in counters:
                 counters[curve] += 1
                 if all(counters.values()):
                     trend.exportPdf(options.export_file)
-                    print '*' * 10 + ' %s: Exported to : %s  ' % (datetime.now().isoformat(), options.export_file) + '*' * 10
+                    print('*' * 10 + ' %s: Exported to : %s  ' % (datetime.now().isoformat(), options.export_file) + '*' * 10)
                     trend.close()
             return
         if not curves:
--- lib/taurus/qt/qtgui/plot/taurustrend.py	(original)
+++ lib/taurus/qt/qtgui/plot/taurustrend.py	(refactored)
@@ -26,6 +26,7 @@
 """
 taurustrend.py: Generic trend widget for Taurus
 """
+from __future__ import print_function
 __all__ = ["ScanTrendsSet", "TaurusTrend", "TaurusTrendsSet"]
 
 from datetime import datetime
@@ -338,7 +339,7 @@
                 v = value.rvalue
             try:
                 self._yBuffer.append(v)
-            except Exception, e:
+            except Exception as e:
                 self.warning('Problem updating history (%s=%s):%s',
                              model, v, e)
                 value = None
@@ -354,7 +355,7 @@
                 if self.parent().getXDynScale() or not self.parent().axisAutoScale(Qwt5.QwtPlot.xBottom):
                     try:
                         getArchivedTrendValues(self, model, insert=True)
-                    except Exception, e:
+                    except Exception as e:
                         import traceback
                         self.warning('%s: reading from archiving failed: %s' % (
                             datetime.now().isoformat('_'), traceback.format_exc()))
@@ -438,7 +439,7 @@
         try:
             self._xValues, self._yValues = self._updateHistory(
                 model=model or self.getModel(), value=value)
-        except Exception, e:
+        except Exception as e:
             self._onDroppedEvent(reason=str(e))
             raise
 
@@ -1171,7 +1172,7 @@
                     raise ValueError(
                         'composed ("X|Y") models are not supported by TaurusTrend')
                 # create a new TrendSet if not already there
-                if not self.trendSets.has_key(name):
+                if name not in self.trendSets:
                     # check if the model name is of scan type and provides a
                     # door
                     matchScan = re.search(r"scan:\/\/(.*)", name)
@@ -1926,12 +1927,12 @@
 
         def exportIfAllCurves(curve, trend=w, counters=curves):
             curve = str(curve)
-            print '*' * 10 + ' %s: Event received for %s  ' % (datetime.now().isoformat(), curve) + '*' * 10
+            print('*' * 10 + ' %s: Event received for %s  ' % (datetime.now().isoformat(), curve) + '*' * 10)
             if curve in counters:
                 counters[curve] += 1
                 if all(counters.values()):
                     trend.exportPdf(options.export_file)
-                    print '*' * 10 + ' %s: Exported to : %s  ' % (datetime.now().isoformat(), options.export_file) + '*' * 10
+                    print('*' * 10 + ' %s: Exported to : %s  ' % (datetime.now().isoformat(), options.export_file) + '*' * 10)
                     trend.close()
             return
         if not curves:
--- lib/taurus/qt/qtgui/resource/__init__.py	(original)
+++ lib/taurus/qt/qtgui/resource/__init__.py	(refactored)
@@ -27,6 +27,7 @@
 Old module supporting resources (now it just contains a reimplementation
 based on taurus.qt.qtgui.icon for bck-compat)
 """
+from __future__ import absolute_import
 
 from taurus.core.util.log import deprecated as __deprecated
 
@@ -34,4 +35,4 @@
            alt='taurus.qt.qtgui.icon',
            rel='4.0')
 
-from taurus_resource_utils import *
+from .taurus_resource_utils import *
--- lib/taurus/qt/qtgui/table/qdictionary.py	(original)
+++ lib/taurus/qt/qtgui/table/qdictionary.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides basic python dictionary/list editor widgets"""
+from __future__ import print_function
 
 __all__ = ["QDictionaryEditor", "QListEditor"]
 
--- lib/taurus/qt/qtgui/table/qlogtable.py	(original)
+++ lib/taurus/qt/qtgui/table/qlogtable.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides Qt table widgets which display logging messages from the
 python :mod:`logging` module"""
+from __future__ import absolute_import
 
 __all__ = ["QLoggingTableModel", "QLoggingTable", "QLoggingWidget",
            "QRemoteLoggingTableModel"]
@@ -47,7 +48,7 @@
 from taurus.qt.qtgui.model import FilterToolBar
 from taurus.qt.qtgui.util import ActionFactory
 
-from qtable import QBaseTableWidget
+from .qtable import QBaseTableWidget
 
 LEVEL, TIME, MSG, NAME, ORIGIN = range(5)
 HORIZ_HEADER = 'Level', 'Time', 'Message', 'By', 'Origin'
--- lib/taurus/qt/qtgui/table/taurusdbtable.py	(original)
+++ lib/taurus/qt/qtgui/table/taurusdbtable.py	(refactored)
@@ -25,6 +25,7 @@
 
 """This module provides a base widget that can be used to display a taurus
 model in a table widget"""
+from __future__ import absolute_import
 
 # todo: tango-centric!!!
 
@@ -37,7 +38,7 @@
 from taurus.qt.qtcore.model import *
 from taurus.core.taurusauthority import TaurusAuthority
 from taurus.qt.qtgui.icon import getElementTypeIcon, getElementTypeIconName
-from taurustable import TaurusBaseTableWidget
+from .taurustable import TaurusBaseTableWidget
 
 
 class TaurusDbTableWidget(TaurusBaseTableWidget):
--- lib/taurus/qt/qtgui/table/taurusdevicepropertytable.py	(original)
+++ lib/taurus/qt/qtgui/table/taurusdevicepropertytable.py	(refactored)
@@ -26,6 +26,7 @@
 """
 taurusdevicepropertytable.py:
 """
+from __future__ import print_function
 
 # todo: tango-centric
 
@@ -54,7 +55,7 @@
             self.defineStyle()
             self.db = None
 
-        except Exception, e:
+        except Exception as e:
             self.traceback()
 
     #-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-
--- lib/taurus/qt/qtgui/table/taurusgrid.py	(original)
+++ lib/taurus/qt/qtgui/table/taurusgrid.py	(refactored)
@@ -29,6 +29,7 @@
 integrated with taurus and regular expressions by srubio
 alba, 2009
 """
+from __future__ import print_function
 
 # This module needs a total cleanup. Both re. code conventions and algorithms.
 #   --cpascual 20140827
@@ -128,7 +129,7 @@
                                  taurus_dp.attribute_list_query(
                                  ) if re_match_low(attribute, att.name)]
                         targets.extend(dev + '/' + att for att in attrs)
-                    except Exception, e:
+                    except Exception as e:
                         # self.warning( 'ERROR! TaurusGrid.get_all_models(): Unable to get attributes for device %s: %s' % (dev,str(e)))
                         pass
                 else:
@@ -195,7 +196,7 @@
                                  ) if re_match_low(attribute,
                                                    att.name) and att.isReadOnly()]
                         targets.extend(dev + '/' + att for att in attrs)
-                    except Exception, e:
+                    except Exception as e:
                         pass
                 else:
                     targets.append(dev + '/' + attribute)
@@ -494,7 +495,7 @@
                     else:
                         # print 'In setModel(): Thread already started! (%d
                         # objs in queue)'%(self.modelsThread.queue.qsize())
-                        self.modelsThread.next()
+                        next(self.modelsThread)
                 else:
                     self.trace('In setModel(): models loading delayed!')
                     pass
@@ -526,7 +527,7 @@
             try:
                 labels = eval(text)
                 return labels
-            except Exception, e:
+            except Exception as e:
                 self.warning(
                     'ERROR! Unable to parse labels property: %s' % str(e))
                 return []
@@ -546,7 +547,7 @@
                 section = self.rows[i]
                 self.table.setVerticalHeaderItem(
                     i, QtGui.QTableWidgetItem(section))
-        except Exception, e:
+        except Exception as e:
             self.debug("setRowLabels(): Exception! %s" % e)
             # self.create_widgets_table(self._columnsNames)
 
@@ -567,7 +568,7 @@
                 equipment = self.columns[i]
                 self.table.setHorizontalHeaderItem(
                     i, QtGui.QTableWidgetItem(equipment))
-        except Exception, e:
+        except Exception as e:
             self.debug("setColumnLabels(): Exception! %s" % e)
             # self.create_widgets_table(self._columnsNames)
 
@@ -1022,9 +1023,9 @@
     from taurus.qt.qtgui.application import TaurusApplication
 
     if len(sys.argv) < 2:
-        print "The format of the call is something like:"
-        print '\t/usr/bin/python taurusgrid.py grid.pickle.file'
-        print '\t/usr/bin/python taurusgrid.py "model=lt.*/VC.*/.*/((C*)|(P*)|(I*))" cols=IP,CCG,PNV rows=LT01,LT02 others=False rowframe=True colframe=False'
+        print("The format of the call is something like:")
+        print('\t/usr/bin/python taurusgrid.py grid.pickle.file')
+        print('\t/usr/bin/python taurusgrid.py "model=lt.*/VC.*/.*/((C*)|(P*)|(I*))" cols=IP,CCG,PNV rows=LT01,LT02 others=False rowframe=True colframe=False')
         exit()
 
     app = TaurusApplication(sys.argv[0:1])
@@ -1037,7 +1038,7 @@
     except:
         args = sysargs_to_dict(
             ['model', 'rows', 'cols', 'others', 'rowframe', 'colframe'])
-        print "args = %s" % args
+        print("args = %s" % args)
         if args.get('rows'):
             gui.setRowLabels(args['rows'])
         if args.get('cols'):
@@ -1048,6 +1049,6 @@
         gui.showColumnFrame('colframe' in args and args['colframe'] and True)
         gui.showOthers('others' in args and args['others'] or True)
 
-    print "current TaurusGrid model= %s" % (gui.getModel())
+    print("current TaurusGrid model= %s" % (gui.getModel()))
     gui.show()
     sys.exit(app.exec_())
--- lib/taurus/qt/qtgui/table/taurustable.py	(original)
+++ lib/taurus/qt/qtgui/table/taurustable.py	(refactored)
@@ -25,13 +25,14 @@
 
 """This module provides a base widget that can be used to display a taurus
 model in a table widget"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusBaseTableWidget"]
 
 __docformat__ = 'restructuredtext'
 
 from taurus.qt.qtgui.model import TaurusBaseModelWidget
-from qtable import QBaseTableWidget
+from .qtable import QBaseTableWidget
 
 
 class TaurusBaseTableWidget(QBaseTableWidget, TaurusBaseModelWidget):
--- lib/taurus/qt/qtgui/table/taurusvaluestable.py	(original)
+++ lib/taurus/qt/qtgui/table/taurusvaluestable.py	(refactored)
@@ -117,7 +117,7 @@
             value = self.typeCastingMap[tabledata.dtype.kind](value)
             return Qt.QVariant(value)
         elif role == Qt.Qt.DecorationRole:
-            if (self._modifiedDict.has_key((index.row(), index.column()))) and\
+            if ((index.row(), index.column()) in self._modifiedDict) and\
                     (self._writeMode):
                 if self.getAttr().type in [DataType.Integer, DataType.Float]:
                     value = self._modifiedDict[(index.row(), index.column())]
@@ -130,7 +130,7 @@
                 return Qt.QVariant(icon)
         elif role == Qt.Qt.EditRole:
             value = None
-            if self._modifiedDict.has_key((index.row(), index.column())) and\
+            if (index.row(), index.column()) in self._modifiedDict and\
                     (self._writeMode):
                 value = self._modifiedDict[(index.row(), index.column())]
             else:
@@ -144,7 +144,7 @@
             else:
                 return Qt.QVariant(Qt.QColor('white'))
         elif role == Qt.Qt.ForegroundRole:
-            if self._modifiedDict.has_key((index.row(), index.column())) and\
+            if (index.row(), index.column()) in self._modifiedDict and\
                     (self._writeMode):
                 if self.getAttr().type in [DataType.Integer, DataType.Float]:
                     value = self._modifiedDict[(index.row(), index.column())]
@@ -156,11 +156,11 @@
                     return Qt.QVariant(Qt.QColor('blue'))
             return Qt.QVariant(Qt.QColor('black'))
         elif role == Qt.Qt.FontRole:
-            if self._modifiedDict.has_key((index.row(), index.column())) and\
+            if (index.row(), index.column()) in self._modifiedDict and\
                     (self._writeMode):
                 return Qt.QVariant(Qt.QFont("Arial", 10, Qt.QFont.Bold))
         elif role == Qt.Qt.ToolTipRole:
-            if self._modifiedDict.has_key((index.row(), index.column())) and\
+            if (index.row(), index.column()) in self._modifiedDict and\
                     (self._writeMode):
                 value = str(self._modifiedDict[(index.row(), index.column())])
                 msg = 'Original value: %s.\nNew value that will be saved: %s' %\
@@ -243,7 +243,7 @@
 
         :param index:  (QModelIndex) table index
         '''
-        if self._modifiedDict.has_key((index.row(), index.column())):
+        if (index.row(), index.column()) in self._modifiedDict:
             self._modifiedDict.pop((index.row(), index.column()))
 
     def flags(self, index):
@@ -748,7 +748,7 @@
             index = self._tableView.selectedIndexes()[0]
             if index.isValid():
                 val = self._tableView.model().getReadValue(index)
-                if self._tableView.model().getModifiedDict().has_key((index.row(), index.column())):
+                if (index.row(), index.column()) in self._tableView.model().getModifiedDict():
                     menu.addAction(Qt.QIcon.fromTheme(
                         'edit-undo'), "Reset to original value (%s) " % repr(val), self._tableView.removeChange)
                     menu.addSeparator()
--- lib/taurus/qt/qtgui/taurusgui/appsettingswizard.py	(original)
+++ lib/taurus/qt/qtgui/taurusgui/appsettingswizard.py	(refactored)
@@ -32,6 +32,7 @@
 time and those customizations will also be stored, this file defines what a
 user will find when launching the GUI for the first time.
 """
+from __future__ import print_function
 
 __all__ = ["AppSettingsWizard", "ExternalAppEditor"]
 
@@ -241,7 +242,7 @@
         if not os.path.exists(dirname):
             try:
                 os.makedirs(dirname)
-            except Exception, e:
+            except Exception as e:
                 Qt.QMessageBox.warning(self, 'Error creating project directory',
                                        'Could not create the project directory.\nReason:%s' % repr(
                                            e),
@@ -260,7 +261,7 @@
             if option == Qt.QMessageBox.Yes:
                 try:
                     self.wizard().loadXml(fname)
-                except Exception, e:
+                except Exception as e:
                     Qt.QMessageBox.warning(self, 'Error loading project configuration',
                                            'Could not load the existing configuration.\nReason:%s' % repr(
                                                e),
@@ -1304,7 +1305,7 @@
     def validatePage(self):
         try:
             self.createProject()
-        except Exception, e:
+        except Exception as e:
             Qt.QMessageBox.warning(self, 'Error creating project',
                                    'Could not create project files. \nReason:%s' % repr(
                                        e),
@@ -1398,9 +1399,9 @@
                              'Application project created', msg, Qt.QMessageBox.Ok, self)
         dlg.setDetailedText(details)
         dlg.exec_()
-        print 
-        print msg + details
-        print
+        print() 
+        print(msg + details)
+        print()
 
 
 class AppSettingsWizard(Qt.QWizard):
@@ -1487,7 +1488,7 @@
     def getXml(self):
         try:
             return self.__getitem__("xml")
-        except Exception, e:
+        except Exception as e:
             return None
 
     def __setitem__(self, name, value):
@@ -1499,7 +1500,7 @@
             if isinstance(p, BasePage):
                 try:
                     return p[name]()
-                except Exception, e:
+                except Exception as e:
                     pass
         return self._item_funcs[name]()
 
--- lib/taurus/qt/qtgui/taurusgui/conf/tgconf_example01/__init__.py	(original)
+++ lib/taurus/qt/qtgui/taurusgui/conf/tgconf_example01/__init__.py	(refactored)
@@ -23,4 +23,5 @@
 ##
 ###########################################################################
 
-from config import *
+from __future__ import absolute_import
+from .config import *
--- lib/taurus/qt/qtgui/taurusgui/conf/tgconf_macrogui/__init__.py	(original)
+++ lib/taurus/qt/qtgui/taurusgui/conf/tgconf_macrogui/__init__.py	(refactored)
@@ -23,4 +23,5 @@
 ##
 ###########################################################################
 
-from config import *
+from __future__ import absolute_import
+from .config import *
--- lib/taurus/qt/qtgui/taurusgui/__init__.py	(original)
+++ lib/taurus/qt/qtgui/taurusgui/__init__.py	(refactored)
@@ -49,14 +49,15 @@
 prevail).
 
 """
+from __future__ import absolute_import
 
 __docformat__ = 'restructuredtext'
 
-import utils
-from paneldescriptionwizard import *
-from taurusgui import *
-from appsettingswizard import *
+from . import utils
+from .paneldescriptionwizard import *
+from .taurusgui import *
+from .appsettingswizard import *
 try:
-    from macrolistener import *
+    from .macrolistener import *
 except ImportError:
     pass  # allow for sardana not being installed
--- lib/taurus/qt/qtgui/taurusgui/macrolistener.py	(original)
+++ lib/taurus/qt/qtgui/taurusgui/macrolistener.py	(refactored)
@@ -33,6 +33,7 @@
 
 .. note:: This module will be moved to sardana.taurus at some point.
 """
+from __future__ import print_function
 
  # TODO: move to sardana.taurus
 
@@ -596,5 +597,5 @@
 
     b.setModel('door/cp1/1')
 
-    print '...'
+    print('...')
     sys.exit(app.exec_())
--- lib/taurus/qt/qtgui/taurusgui/paneldescriptionwizard.py	(original)
+++ lib/taurus/qt/qtgui/taurusgui/paneldescriptionwizard.py	(refactored)
@@ -23,6 +23,7 @@
 ##
 ###########################################################################
 
+from __future__ import print_function
 __all__ = ["PanelDescriptionWizard"]
 """
 paneldescriptionwizard.py:
@@ -99,7 +100,7 @@
             # We use this because __import__('x.y') returns x instead of y !!
             self.module = sys.modules[modulename]
             self.moduleNameLE.setStyleSheet('QLineEdit {color: green}')
-        except Exception, e:
+        except Exception as e:
             Logger().debug(repr(e))
             self.moduleNameLE.setStyleSheet('QLineEdit {color: red}')
             return
@@ -129,7 +130,7 @@
             membername = str(self.membersCB.currentText())
             member = getattr(self.module, membername, None)
             result = {'modulename': self.module.__name__}
-        except Exception, e:
+        except Exception as e:
             Logger().debug('Cannot get member description: %s', repr(e))
             return None
         if inspect.isclass(member):
@@ -307,7 +308,7 @@
             paneldesc.name = Qt.from_qvariant(self.field('panelname'), str)
             # allow the wizard to proceed
             return True
-        except Exception, e:
+        except Exception as e:
             Qt.QMessageBox.warning(
                 self, 'Invalid panel', 'The requested panel cannot be created. \nReason:\n%s' % repr(e))
             return False
@@ -406,7 +407,7 @@
     def initializePage(self):
         try:
             widget = self.wizard().getPanelDescription().getWidget()
-        except Exception, e:
+        except Exception as e:
             Logger().debug(repr(e))
             widget = None
         # prevent the user from changing the model if it was already set
@@ -417,7 +418,7 @@
         try:
             if isinstance(Qt.qApp.SDM, SharedDataManager):
                 sdm = Qt.qApp.SDM
-        except Exception, e:
+        except Exception as e:
             Logger().debug(repr(e))
             sdm = None
         #@todo set selection filter in modelChooser based on the widget's modelclass
@@ -652,7 +653,7 @@
     form = PanelDescriptionWizard()
 
     def kk(d):
-        print d
+        print(d)
     Qt.qApp.SDM = SharedDataManager(form)
     Qt.qApp.SDM.connectReader('111111', kk)
     Qt.qApp.SDM.connectWriter('222222', form, 'thisisasignalname')
@@ -664,7 +665,7 @@
 def test2():
     from taurus.qt.qtgui.application import TaurusApplication
     app = TaurusApplication(sys.argv)
-    print ExpertWidgetChooserDlg.getDialog()
+    print(ExpertWidgetChooserDlg.getDialog())
     sys.exit()
 
 
@@ -675,7 +676,7 @@
     form = Qt.QMainWindow()
 
     def kk(d):
-        print d
+        print(d)
     Qt.qApp.SDM = SharedDataManager(form)
     Qt.qApp.SDM.connectReader('someUID', kk)
     Qt.qApp.SDM.connectWriter('anotherUID', form, 'thisisasignalname')
@@ -688,7 +689,7 @@
         w = paneldesc.getWidget(sdm=Qt.qApp.SDM)
         form.setCentralWidget(w)
         form.setWindowTitle(paneldesc.name)
-    print Qt.qApp.SDM.info()
+    print(Qt.qApp.SDM.info())
 
     sys.exit(app.exec_())
 
--- lib/taurus/qt/qtgui/taurusgui/taurusgui.py	(original)
+++ lib/taurus/qt/qtgui/taurusgui/taurusgui.py	(refactored)
@@ -162,7 +162,7 @@
                     module = __import__(modulename, fromlist=[''])
                     klass = getattr(module, classname)
                     w = klass()
-                except Exception, e:
+                except Exception as e:
                     raise RuntimeError(
                         'Cannot create widget from classname "%s". Reason: %s' % (classname, repr(e)))
             # set customwidgetmap if necessary
@@ -191,7 +191,7 @@
                 'widgetClassName'), modulename=configdict.get('widgetModuleName', None))
             if isinstance(self.widget(), BaseConfigurableClass):
                 self.widget().applyConfig(configdict['widget'])
-        except Exception, e:
+        except Exception as e:
             self.info(
                 'Failed to set the widget for this panel. Reason: %s' % repr(e))
             self.traceback(self.Debug)
@@ -820,7 +820,7 @@
             synoptic = TaurusJDrawSynopticsView()
             synoptic.setModel(jdwFileName)
             self.__synoptics.append(synoptic)
-        except Exception, e:
+        except Exception as e:
             # print repr(e)
             msg = 'Error loading synoptic file "%s".\nSynoptic won\'t be available' % jdwFileName
             self.error(msg)
@@ -880,7 +880,7 @@
             instruments = ms.getElementsOfType('Instrument')
             if instruments is None:
                 raise
-        except Exception, e:
+        except Exception as e:
             msg = 'Could not fetch Instrument list from "%s"' % macroservername
             self.error(msg)
             result = Qt.QMessageBox.critical(self, 'Initialization error', '%s\n\n%s' % (
@@ -984,7 +984,7 @@
             else:  # if confname is not a dir name, we assume it is a module name in the python path
                 conf = self._importConfiguration(confname)
                 self._confDirectory = os.path.dirname(conf.__file__)
-        except Exception, e:
+        except Exception as e:
             import traceback
             msg = 'Error loading configuration: %s' % traceback.format_exc()  # repr(e)
             self.error(msg)
@@ -1010,7 +1010,7 @@
                 xmlstring = xmlFile.read()
                 xmlFile.close()
                 xmlroot = etree.fromstring(xmlstring)
-            except Exception, e:
+            except Exception as e:
                 msg = 'Error reading the XML file: "%s"' % xmlfname
                 self.error(msg)
                 self.traceback(level=taurus.Info)
@@ -1185,7 +1185,7 @@
                 # create a panel
                 self.createPanel(w, p.name, floating=p.floating, registerconfig=registerconfig,
                                  instrumentkey=instrumentkey, permanent=True)
-            except Exception, e:
+            except Exception as e:
                 msg = 'Cannot create panel %s' % getattr(
                     p, 'name', '__Unknown__')
                 self.error(msg)
@@ -1227,7 +1227,7 @@
                 if isinstance(w, BaseConfigurableClass):
                     self.registerConfigDelegate(w, d.name)
 
-            except Exception, e:
+            except Exception as e:
                 msg = 'Cannot add toolbar %s' % getattr(
                     d, 'name', '__Unknown__')
                 self.error(msg)
@@ -1273,7 +1273,7 @@
                 # register the toolbar as delegate if it supports it
                 if isinstance(w, BaseConfigurableClass):
                     self.registerConfigDelegate(w, d.name)
-            except Exception, e:
+            except Exception as e:
                 msg = 'Cannot add applet %s' % getattr(
                     d, 'name', '__Unknown__')
                 self.error(msg)
@@ -1509,7 +1509,7 @@
                 f = open(self._xmlConfigFileName, 'r')
                 xmlroot = etree.fromstring(f.read())
                 f.close()
-            except Exception, e:
+            except Exception as e:
                 self.error('Cannot parse file "%s": %s',
                            self._xmlConfigFileName, str(e))
                 return
@@ -1564,7 +1564,7 @@
                 f.write(xml)
                 f.close()
                 break
-            except Exception, e:
+            except Exception as e:
                 msg = 'Cannot write to %s: %s' % (fname, str(e))
                 self.error(msg)
                 Qt.QMessageBox.warning(
--- lib/taurus/qt/qtgui/taurusgui/utils.py	(original)
+++ lib/taurus/qt/qtgui/taurusgui/utils.py	(refactored)
@@ -387,7 +387,7 @@
             # if model is a sequence, convert to space-separated string
             try:
                 model = " ".join(model)
-            except Exception, e:
+            except Exception as e:
                 msg = ('Cannot convert %s to a space-separated string: %s' %
                        (model, e))
                 Logger().debug(msg)
--- lib/taurus/qt/qtgui/tree/taurusdbtree.py	(original)
+++ lib/taurus/qt/qtgui/tree/taurusdbtree.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module provides widgets that display the database in a tree format"""
+from __future__ import absolute_import
 
 # todo: tango-centric!!
 
@@ -37,7 +38,7 @@
 from taurus.qt.qtcore.model import *
 from taurus.qt.qtgui.base import TaurusBaseWidget
 from taurus.qt.qtgui.icon import getElementTypeIcon, getElementTypeIconName
-from taurustree import TaurusBaseTreeWidget
+from .taurustree import TaurusBaseTreeWidget
 
 
 class TaurusDbTreeWidget(TaurusBaseTreeWidget):
--- lib/taurus/qt/qtgui/tree/taurusdevicetree.py	(original)
+++ lib/taurus/qt/qtgui/tree/taurusdevicetree.py	(refactored)
@@ -26,6 +26,7 @@
 """
 taurusdevicetree.py:
 """
+from __future__ import print_function
 
 # @todo: This module is not being used anywhere in Taurus and depends on
 # non-standard and non-provided modules. It is also quite specific and
@@ -568,7 +569,7 @@
     def trace(self, msg):
         if self.TRACE_ALL or self.getLogLevel() in ('DEBUG', 40,):
             # @TODO: use the taurus logger instead! ~~cpascual 20121121
-            print 'TaurusDevTree.%s: %s' % (self.getLogLevel(), msg)
+            print('TaurusDevTree.%s: %s' % (self.getLogLevel(), msg))
 
     def setTangoHost(self, tango_host=None):
         self.db = taurus.Authority(tango_host)
@@ -761,12 +762,12 @@
                 label = aname == my_attr.label and aname.lower(
                 ) or "%s (%s)" % (aname.lower(), my_attr.label)
                 dct[str(my_device).lower() + '/' + label] = 0
-        except PyTango.DevFailed, e:
+        except PyTango.DevFailed as e:
             self.warning('addAttrToDev(%s): %s' % (my_device, str(e)))
             qmsg = Qt.QMessageBox(Qt.QMessageBox.Critical, '%s Error' %
                                   my_device, '%s not available' % my_device, Qt.QMessageBox.Ok, self)
             qmsg.show()
-        except Exception, e:
+        except Exception as e:
             self.warning('addAttrToDev(%s): %s' % (my_device, str(e)))
             qmsg = Qt.QMessageBox(Qt.QMessageBox.Critical, '%s Error' %
                                   my_device, str(e), Qt.QMessageBox.Ok, self)
@@ -1006,7 +1007,7 @@
                          for item in self.item_list if item.isExpanded()]
                 self.debug('findInTree(%s): Node not found' % (regexp))
             if queue:
-                self.Expander.next()
+                next(self.Expander)
         except:
             self.warning('findInTree(%s): failed' % (regexp))
             self.error(traceback.format_exc())
@@ -1019,7 +1020,7 @@
             allChildren[str(it.text(0))] = it
 
         sorter = lambda k, ks=[re.compile(c) for c in order]: str(
-            (i for i, r in enumerate(ks) if r.match(k.lower())).next()) + str(k)
+            next((i for i, r in enumerate(ks) if r.match(k.lower())))) + str(k)
         for c, it in sorted(allChildren.items(), key=lambda k: sorter(k[0])):
             self.debug('tree.sortCustom(%s): %s inserted at %d' %
                        (order, it.text(0), self.topLevelItemCount()))
@@ -1298,7 +1299,7 @@
                     elif not last_was_separator:
                         menu.addSeparator()
                         last_was_separator = True
-                except Exception, e:
+                except Exception as e:
                     self.warning('Unable to add Menu Action: %s:%s' % (t, e))
 
         if hasattr(node, 'ExpertMenu'):
@@ -1319,7 +1320,7 @@
                     elif not last_was_separator:
                         expert.addSeparator()
                         last_was_separator = True
-                except Exception, e:
+                except Exception as e:
                     self.warning('Unable to add Expert Action: %s:%s' % (t, e))
         # menu.addSeparator()
         menu.exec_(event.globalPos())
@@ -1666,7 +1667,7 @@
             try:
                 setattr(self, k, partial(
                     self.method_forwarder, method=k, object=self.tree))
-            except Exception, e:
+            except Exception as e:
                 self.warning('Unable to add slot %s: %s' % (k, e))
         # Event forwarding ...
         self.tree.refreshTree.connect(self.refreshTree)
--- lib/taurus/qt/qtgui/tree/taurustree.py	(original)
+++ lib/taurus/qt/qtgui/tree/taurustree.py	(refactored)
@@ -25,13 +25,14 @@
 
 """This module provides a base widget that can be used to display a taurus
 model in a tree widget"""
+from __future__ import absolute_import
 
 __all__ = ["TaurusBaseTreeWidget"]
 
 __docformat__ = 'restructuredtext'
 
 from taurus.qt.qtgui.model import TaurusBaseModelWidget
-from qtree import QBaseTreeWidget
+from .qtree import QBaseTreeWidget
 
 
 class TaurusBaseTreeWidget(QBaseTreeWidget, TaurusBaseModelWidget):
--- lib/taurus/qt/qtgui/util/taurusactionfactory.py	(original)
+++ lib/taurus/qt/qtgui/util/taurusactionfactory.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module is designed to provide a factory class for taurus Qt actions """
+from __future__ import absolute_import
 
 __all__ = ["ActionFactory"]
 
@@ -33,7 +34,7 @@
 from taurus.core.util.singleton import Singleton
 from taurus.external.qt import Qt
 
-import taurusaction
+from . import taurusaction
 
 
 class ActionFactory(Singleton, Logger):
--- lib/taurus/qt/qtgui/util/taurusaction.py	(original)
+++ lib/taurus/qt/qtgui/util/taurusaction.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """This module is designed to provide a library of taurus Qt actions"""
+from __future__ import absolute_import
 
 __all__ = ["ExternalAppAction",
            "TaurusMenu",
@@ -171,7 +172,7 @@
         self.buildFromXML(m_node)
 
     def getActionFactory(self):
-        import taurusactionfactory
+        from . import taurusactionfactory
         return taurusactionfactory.ActionFactory()
 
     def buildFromXML(self, m_node):
--- lib/taurus/qt/qtgui/util/tauruscolor.py	(original)
+++ lib/taurus/qt/qtgui/util/tauruscolor.py	(refactored)
@@ -57,10 +57,10 @@
 
         f = self._qbrush_cache_fg
         b = self._qbrush_cache_bg
-        if not f.has_key(name):
+        if name not in f:
             f[name] = Qt.QBrush(self.qcolor(stoq)[1])
 
-        if not b.has_key(name):
+        if name not in b:
             b[name] = Qt.QBrush(self.qcolor(stoq)[0])
             if name == 'None':
                 b[name].setStyle(Qt.Qt.BDiagPattern)
@@ -73,10 +73,10 @@
 
         f = self._qcolor_cache_fg
         b = self._qcolor_cache_bg
-        if not f.has_key(name):
+        if name not in f:
             f[name] = Qt.QColor(self.number(name, True))
 
-        if not b.has_key(name):
+        if name not in b:
             b[name] = Qt.QColor(self.number(name))
 
         return (b[name], f[name])
@@ -87,7 +87,7 @@
 
         f = self._qvariant_cache_fg
         b = self._qvariant_cache_bg
-        if not f.has_key(name):
+        if name not in f:
             (back, fore) = self.qcolor(name)
             f[name] = Qt.QVariant(fore)
             b[name] = Qt.QVariant(back)
--- lib/taurus/qt/qtgui/util/taurusropepatch.py	(original)
+++ lib/taurus/qt/qtgui/util/taurusropepatch.py	(refactored)
@@ -39,7 +39,7 @@
     """Monkey patching rope for better performances"""
     import rope
     if rope.VERSION not in ('0.9.3', '0.9.2'):
-        raise ImportError, "rope %s can't be patched" % rope.VERSION
+        raise ImportError("rope %s can't be patched" % rope.VERSION)
 
     # Patching pycore.PyCore, so that forced builtin modules (i.e. modules
     # that were declared as 'extension_modules' in rope preferences)
--- lib/taurus/qt/qtgui/util/tauruswidgetfactory.py	(original)
+++ lib/taurus/qt/qtgui/util/tauruswidgetfactory.py	(refactored)
@@ -120,9 +120,9 @@
                         qt_ret[dir_name] = package, attr
                         if issubclass(attr, taurus.qt.qtgui.base.TaurusBaseWidget):
                             taurus_ret[dir_name] = package, attr
-                except Exception, e:
+                except Exception as e:
                     pass
-        except Exception, e:
+        except Exception as e:
             return taurus_ret, qt_ret
 
         if not recursive:
@@ -161,13 +161,13 @@
             try:
                 self.debug("Trying to find extra module %s", m_name)
                 f, fname, data = imp.find_module(m_name, [path])
-            except ImportError, ie:
+            except ImportError as ie:
                 self.debug("Could not find extra module %s:%s", m_name, ie)
                 continue
             try:
                 self.debug("Trying to load extra module %s", m_name)
                 mod = imp.load_module(m_name, f, fname, data)
-            except ImportError, ie:
+            except ImportError as ie:
                 self.debug("Could not load extra module %s:%s", m_name, ie)
                 continue
             dir_names = dir(mod)
@@ -184,7 +184,7 @@
                             taurus_ret[dir_name] = qt_info['module'], attr
                             qt_widgets[dir_name] = qt_info['module'], attr
                             self.debug("registered taurus widget %s", dir_name)
-                except Exception, e:
+                except Exception as e:
                     pass
 
     def getWidgets(self):
--- lib/taurus/qt/qtgui/util/test/test_ui/test_ui.py	(original)
+++ lib/taurus/qt/qtgui/util/test/test_ui/test_ui.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 """Unit tests for UILoadable decorator"""
+from __future__ import absolute_import
 
 import os.path
 
@@ -31,7 +32,7 @@
 from taurus.external.qt import Qt
 from taurus.qt.qtgui.util.ui import UILoadable
 from taurus.qt.qtgui.test import BaseWidgetTestCase
-from mywidget3 import MyWidget3
+from .mywidget3 import MyWidget3
 
 
 class UILoadableTestCase(unittest.TestCase):
--- lib/taurus/test/fuzzytest.py	(original)
+++ lib/taurus/test/fuzzytest.py	(refactored)
@@ -24,6 +24,7 @@
 #############################################################################
 
 '''Utility functions to deal with non-ideal (fuzzy) tests'''
+from __future__ import print_function
 
 
 def loopTest(testname, maxtries=100, maxfails=10):
@@ -97,8 +98,8 @@
              times that the test should be passed to have a confidence>99%%
              that the bug is fixed'
     '''
-    print ("Running the test %i times (or until it fails %i times)" +
-           "to estimate the failure rate") % (maxtries, maxfails)
+    print(("Running the test %i times (or until it fails %i times)" +
+           "to estimate the failure rate") % (maxtries, maxfails))
     import numpy
 
     if isinstance(test, str):
@@ -108,11 +109,11 @@
                                       maxfails=maxfails, **kwargs)
     r = float(fails) / tries
     dr = numpy.sqrt(fails) / tries
-    print 'Failure rate = %g +/- %g  (%i/%i)' % (r, dr, fails, tries)
+    print('Failure rate = %g +/- %g  (%i/%i)' % (r, dr, fails, tries))
     # calculating n using p-value=1% and failure rate with -1 sigma
     n = numpy.ceil(numpy.log(.01) / numpy.log(1 - (r - dr)))
-    print ('Number of consecutive times that the test should be passed ' +
-           'to have a confidence>99%% that the bug is fixed: %g') % n
+    print(('Number of consecutive times that the test should be passed ' +
+           'to have a confidence>99%% that the bug is fixed: %g') % n)
     return r, dr, n
 
 
@@ -127,7 +128,7 @@
             exit(1)
         return
 
-    print calculateTestFuzziness(kk)
+    print(calculateTestFuzziness(kk))
 
 #     print calculateTestFuzziness('test_pytango_bug659.TestPyTango_Bug659')
 #
--- lib/taurus/test/moduleexplorer.py	(original)
+++ lib/taurus/test/moduleexplorer.py	(refactored)
@@ -25,6 +25,7 @@
 ###########################################################################
 
 '''Utility code for returning info about a module'''
+from __future__ import print_function
 
 import sys
 import os
@@ -50,7 +51,7 @@
         for p in paterns:
             if re.match(p, name) is not None:
                 if self.verbose:
-                    print 'excluding "%s" (matches %s)' % (name, p.pattern)
+                    print('excluding "%s" (matches %s)' % (name, p.pattern))
                 return True
         return False
 
@@ -90,7 +91,7 @@
                  externalmembernames, submodules, warnings
         '''
         if self.verbose:
-            print "Exploring %s..." % modulename
+            print("Exploring %s..." % modulename)
         warnings = []
         try:
             module = __import__(modulename, fromlist=[''])
@@ -99,7 +100,7 @@
                 modulename, repr(e))
             warnings.append(msg)
             if self.verbose:
-                print msg
+                print(msg)
             return dict(modulename=modulename,
                         basemodulename=modulename.split('.')[-1],
                         modulepath=None,
@@ -213,12 +214,12 @@
          ):
     moduleinfo, allw = ModuleExplorer.explore(
         modulename, exclude_patterns=exclude_patterns, verbose=True)
-    print '\n\n' + '*' * 50
-    print "Exploration finished with %i warnings:" % (len(allw))
+    print('\n\n' + '*' * 50)
+    print("Exploration finished with %i warnings:" % (len(allw)))
     for m, w in allw:
-        print w
-    print '*' * 50 + '\n'
-    print
+        print(w)
+    print('*' * 50 + '\n')
+    print()
     assert len(allw) == 0
 
     # import pprint
--- lib/taurus/test/resource.py	(original)
+++ lib/taurus/test/resource.py	(refactored)
@@ -24,6 +24,7 @@
 ###########################################################################
 
 '''Utility code for working with test resources'''
+from __future__ import print_function
 
 import os
 import sys
@@ -62,8 +63,8 @@
 
 
 if __name__ == "__main__":
-    print getResourcePath('taurus.test')
-    print getResourcePath('taurus.test', 'resource.py')
+    print(getResourcePath('taurus.test'))
+    print(getResourcePath('taurus.test', 'resource.py'))
     # print getResourcePath('taurus.qt.qtgui.plot', 'taurusplot.py')
     # print getResourcePath('taurus.test', 'kk.py')
     # print getResourcePath('taurus.kk', 'resource.py')
--- lib/taurus/test/test_import.py	(original)
+++ lib/taurus/test/test_import.py	(refactored)
@@ -24,6 +24,7 @@
 
 
 """Taurus import tests"""
+from __future__ import absolute_import
 
 from taurus.external import unittest
 
@@ -36,7 +37,7 @@
 
     def setUp(self):
         """Preconditions: moduleexplorer utility has to be available """
-        from moduleexplorer import ModuleExplorer
+        from .moduleexplorer import ModuleExplorer
         self.explore = ModuleExplorer.explore
 
     def testImportSubmodules(self):
--- lib/taurus/test/testsuite.py	(original)
+++ lib/taurus/test/testsuite.py	(refactored)
@@ -31,6 +31,7 @@
   testsuite.run()
 
 """
+from __future__ import print_function
 
 __docformat__ = 'restructuredtext'
 
@@ -47,7 +48,7 @@
     for e in suite:
         if isinstance(e, unittest.TestCase):
             if re.match(exclude_pattern, e.id()):
-                print "Excluded %s" % e.id()
+                print("Excluded %s" % e.id())
                 continue
             ret.addTest(e)
         else:
@@ -99,7 +100,7 @@
     args = parser.parse_args()
 
     if args.version:
-        print Release.version
+        print(Release.version)
         sys.exit(0)
 
     if args.skip_gui:
